--- cg_o/cgminer.c	2014-09-22 14:22:33.032837307 +0300
+++ cgminer_hex/cgminer.c	2014-09-24 08:23:04.316888406 +0300
@@ -93,6 +93,42 @@
 #include "driver-cointerra.h"
 #endif
 
+#ifdef USE_HEXMINERA
+#include "driver-hexminera.h"
+#endif
+
+#ifdef USE_HEXMINERB
+#include "driver-hexminerb.h"
+#endif
+
+#ifdef USE_HEXMINERC
+#include "driver-hexminerc.h"
+#endif
+
+#ifdef USE_HEXMINERU
+#include "driver-hexmineru.h"
+#endif
+
+#ifdef USE_HEXMINER8
+#include "driver-hexminer8.h"
+#endif
+
+#ifdef USE_HEXMINERM
+#include "driver-hexminerm.h"
+#endif
+
+#ifdef USE_HEXMINERR
+#include "driver-hexminerr.h"
+#endif
+
+#ifdef USE_HEXMINERBE200
+#include "driver-hexminerbe200.h"
+#endif
+
+#ifdef USE_HEXMINER3
+#include "driver-hexminer3.h"
+#endif
+
 #ifdef USE_HASHFAST
 #include "driver-hashfast.h"
 #endif
@@ -155,8 +191,8 @@
 bool opt_compact;
 const int opt_cutofftemp = 95;
 int opt_log_interval = 5;
-int opt_queue = 9999;
-static int max_queue = 1;
+int opt_queue = 60;
+static int max_queue = 2;
 int opt_scantime = -1;
 int opt_expiry = 120;
 static const bool opt_time = true;
@@ -185,7 +221,7 @@
 #endif
 static bool opt_widescreen;
 static bool alt_status;
-static bool switch_status;
+static bool switch_status  = true;
 static bool opt_submit_stale = true;
 static int opt_shares;
 bool opt_fail_only;
@@ -207,7 +243,8 @@
 bool opt_api_network;
 bool opt_delaynet;
 bool opt_disable_pool;
-static bool no_work;
+//static 
+bool no_work;
 #ifdef USE_ICARUS
 char *opt_icarus_options = NULL;
 char *opt_icarus_timing = NULL;
@@ -229,6 +266,30 @@
 #ifdef USE_HASHRATIO
 #include "driver-hashratio.h"
 #endif
+#ifdef USE_HEXMINERA
+char *opt_hexminera_options = NULL;
+#endif
+#ifdef USE_HEXMINERB
+char *opt_hexminerb_options = NULL;
+#endif
+#ifdef USE_HEXMINERC
+char *opt_hexminerc_options = NULL;
+#endif
+#ifdef USE_HEXMINER8
+char *opt_hexminer8_options = NULL;
+#endif
+#ifdef USE_HEXMINERBE200
+char *opt_hexminerbe200_options = NULL;
+#endif
+#ifdef USE_HEXMINERM
+char *opt_hexminerm_options = NULL;
+#endif
+#ifdef USE_HEXMINERR
+char *opt_hexminerr_options = NULL;
+#endif
+#ifdef USE_HEXMINER3
+char *opt_hexminer3_options = NULL;
+#endif
 #ifdef USE_KLONDIKE
 char *opt_klondike_options = NULL;
 #endif
@@ -276,7 +337,10 @@
 int opt_usbdump = -1;
 bool opt_usb_list_all;
 cgsem_t usb_resource_sem;
+#if defined(USE_HEXMINERA) || defined(USE_HEXMINERB) || defined(USE_HEXMINERC) || defined(USE_HEXMINERU) || defined(USE_HEXMINER8) || defined(USE_HEXMINERM) || defined(USE_HEXMINERR) || defined(USE_HEXMINERBE200) || defined(USE_HEXMINER3)
+#else
 static pthread_t usb_poll_thread;
+#endif
 static bool usb_polling;
 #endif
 
@@ -326,8 +390,8 @@
 static pthread_mutex_t lp_lock;
 static pthread_cond_t lp_cond;
 
-pthread_mutex_t restart_lock;
-pthread_cond_t restart_cond;
+//pthread_mutex_t restart_lock;
+//pthread_cond_t restart_cond;
 
 pthread_cond_t gws_cond;
 
@@ -346,7 +410,9 @@
 double total_diff_accepted, total_diff_rejected, total_diff_stale;
 static int staged_rollable;
 unsigned int new_blocks;
-static unsigned int work_block;
+//static
+unsigned int work_block;
+unsigned int	work_pool_update;
 unsigned int found_blocks;
 
 unsigned int local_work;
@@ -357,6 +423,11 @@
 
 int total_pools, enabled_pools;
 enum pool_strategy pool_strategy = POOL_FAILOVER;
+
+#if defined(USE_HEXMINERA) || defined(USE_HEXMINERB) || defined(USE_HEXMINERC) || defined(USE_HEXMINERU) || defined(USE_HEXMINER8) || defined(USE_HEXMINERM) || defined(USE_HEXMINERR) || defined(USE_HEXMINERBE200) || defined(USE_HEXMINER3)
+enum default_hex_miner default_hex_miner = D_HEXA;
+#endif
+
 int opt_rotate_period;
 static int total_urls, total_users, total_passes, total_userpasses;
 
@@ -709,9 +780,11 @@
 {
 	struct pool *pool;
 
-	cg_rlock(&control_lock);
+	//cg_rlock
+	cg_wlock(&control_lock);
 	pool = currentpool;
-	cg_runlock(&control_lock);
+	cg_wunlock(&control_lock);
+	//cg_runlock
 
 	return pool;
 }
@@ -789,6 +862,72 @@
 		*val2 = *val1;
 }
 
+
+#ifdef USE_HEXMINERA
+static char *set_default_to_a(enum default_hex_miner *which)
+{
+	*which = D_HEXA;
+	return NULL;
+}
+#endif
+
+
+#ifdef USE_HEXMINERB
+static char *set_default_to_b(enum default_hex_miner *which)
+{
+	*which = D_HEXB;
+	return NULL;
+}
+#endif
+
+#ifdef USE_HEXMINERC
+static char *set_default_to_c(enum default_hex_miner *which)
+{
+	*which = D_HEXC;
+	return NULL;
+}
+#endif
+
+#ifdef USE_HEXMINER8
+static char *set_default_to_8(enum default_hex_miner *which)
+{
+	*which = D_HEX8;
+	return NULL;
+}
+#endif
+
+#ifdef USE_HEXMINERM
+static char *set_default_to_m(enum default_hex_miner *which)
+{
+	*which = D_HEXM;
+	return NULL;
+}
+#endif
+
+#ifdef USE_HEXMINERR
+static char *set_default_to_r(enum default_hex_miner *which)
+{
+	*which = D_HEXR;
+	return NULL;
+}
+#endif
+
+#ifdef USE_HEXMINERBE200
+static char *set_default_to_e(enum default_hex_miner *which)
+{
+	*which = D_HEXBE200;
+	return NULL;
+}
+#endif
+
+
+#ifdef USE_HEXMINER3
+static char *set_default_to_3(enum default_hex_miner *which)
+{
+	*which = D_HEX3;
+	return NULL;
+}
+#endif
 static char *set_balance(enum pool_strategy *strategy)
 {
 	*strategy = POOL_BALANCE;
@@ -1076,6 +1215,7 @@
 	return NULL;
 }
 
+
 /* These options are available from config file or commandline */
 static struct opt_table opt_config_table[] = {
 #ifdef USE_ICARUS
@@ -1363,6 +1503,171 @@
 		     opt_set_charp, NULL, &opt_klondike_options,
 		     "Set klondike options clock:temptarget"),
 #endif
+#ifdef USE_HEXMINERA
+	OPT_WITH_ARG("--hexminera-options",
+		     opt_set_charp, NULL, &opt_hexminera_options,
+		     "Set HEXMinerA options asic_count:freq"),
+	OPT_WITH_ARG("--hexminera-voltage",
+		     opt_set_intval, NULL, &opt_hexminera_core_voltage,
+		     "Set HEXMinerA core voltage, in millivolts"),
+	OPT_WITHOUT_ARG("--set_default_to_a",
+		     set_default_to_a, &default_hex_miner,
+		     "Handle USB detect errors as hexA"),
+#endif
+#ifdef USE_HEXMINERB
+	OPT_WITH_ARG("--hexminerb-options",
+		     opt_set_charp, NULL, &opt_hexminerb_options,
+		     "Set HEXMinerB options asic_count:freq"),
+	OPT_WITH_ARG("--hexminerb-voltage",
+				 opt_set_intval, NULL, &opt_hexminerb_core_voltage,
+		     "Set HEXMinerB core voltage, in millivolts"),
+  OPT_WITHOUT_ARG("--set_default_to_b",
+		     set_default_to_b, &default_hex_miner,
+		     "Handle USB detect errors as hexB"),
+#endif
+#ifdef USE_HEXMINERC
+	OPT_WITH_ARG("--hexminerc-options",
+		     opt_set_charp, NULL, &opt_hexminerc_options,
+		     "Set HEXMinerC options asic_count:freq"),
+	OPT_WITH_ARG("--hexminerc-voltage",
+		     opt_set_intval, NULL, &opt_hexminerc_core_voltage,
+		     "Set HEXMinerC core voltage, in millivolts"),
+  OPT_WITHOUT_ARG("--set_default_to_c",
+		     set_default_to_c, &default_hex_miner,
+		     "Handle USB detect errors as hexC"),
+#endif
+#ifdef USE_HEXMINERU
+	OPT_WITH_ARG("--hexmineru-frequency",
+		     opt_set_intval, NULL, &opt_hexmineru_core_freq,
+		     "Set HEXMinerU frequency"),
+#endif
+#ifdef USE_HEXMINER8
+OPT_WITH_ARG("--hexminer8-options",
+		     opt_set_charp, NULL, &opt_hexminer8_options,
+		     "Set HEXMiner8 options asic_count:freq"),
+	OPT_WITH_ARG("--hexminer8-voltage",
+		     opt_set_intval, NULL, &opt_hexminer8_core_voltage,
+		     "Set HEXMiner8 core voltage, in millivolts"),
+	OPT_WITHOUT_ARG("--set_default_to_8",
+		     set_default_to_8, &default_hex_miner,
+		     "Handle USB detect errors as hex8"),
+	OPT_WITH_ARG("--hexminer8-chip-mask",
+		     opt_set_intval, NULL, &opt_hexminer8_chip_mask,
+		     "Set HEXMiner8 eneable or disable chips"),	     
+	OPT_WITH_ARG("--hexminer8-set-diff-to-one",
+		     opt_set_intval, NULL, &opt_hexminer8_set_config_diff_to_one,
+		     "Set HEXMiner8 ASIC difficulty to one"),	     
+#endif
+#ifdef USE_HEXMINERM
+OPT_WITH_ARG("--hexminerm-options",
+		     opt_set_charp, NULL, &opt_hexminerm_options,
+		     "Set HEXMinerM options asic_count:freq"),
+	OPT_WITH_ARG("--hexminerm-voltage",
+		     opt_set_intval, NULL, &opt_hexminerm_core_voltage,
+		     "Set HEXMinerM core voltage, in millivolts"),
+  OPT_WITH_ARG("--hexminerm-pic-roll",
+		     set_int_0_to_255, NULL, &opt_hexminerm_pic_roll,
+		     "Set HEXMinerM pic work roll"),	 
+	OPT_WITHOUT_ARG("--set_default_to_m",
+		     set_default_to_m, &default_hex_miner,
+		     "Handle USB detect errors as hexM"),
+	OPT_WITH_ARG("--hexminerm-chip-mask",
+		     opt_set_intval, NULL, &opt_hexminerm_chip_mask,
+		     "Set HEXMinerM eneable or disable chips"),	
+  OPT_WITH_ARG("--hexminerm-hw-err-res",
+  			 opt_set_intval, NULL, &opt_hexminerm_hw_err_res,
+		     "Set HEXMinerM reset chip due to N consecutive HW errors"),	 
+	OPT_WITH_ARG("--hexminerm-nonce-timeout-secs",
+		     opt_set_intval, NULL, &opt_hexminerm_nonce_timeout_secs,
+		     "Set HEXMinerM reset chip due to inactivity in seconds"),
+  OPT_WITH_ARG("--hexminerm-reset-below-threshold",
+  			 set_int_0_to_100, NULL, &opt_hexminerm_reset_below_threshold,
+		     "Set HEXMinerM reset board due to low performance"),	 
+	OPT_WITH_ARG("--hexminerm-reset-wait",
+		     set_int_0_to_9999, NULL, &opt_hexminerm_reset_below_threshold_wait,
+		     "Set HEXMinerM wait for 1m speed stats to settle"),   	       
+#endif
+
+#ifdef USE_HEXMINERR
+OPT_WITH_ARG("--hexminerr-options",
+		     opt_set_charp, NULL, &opt_hexminerr_options,
+		     "Set HEXMinerR options asic_count:freq"),
+	OPT_WITH_ARG("--hexminerr-voltage",
+		     opt_set_intval, NULL, &opt_hexminerr_core_voltage,
+		     "Set HEXMinerR core voltage, in millivolts"),
+  OPT_WITH_ARG("--hexminerr-pic-roll",
+		     set_int_0_to_255, NULL, &opt_hexminerr_pic_roll,
+		     "Set HEXMinerR pic work roll"),	 
+	OPT_WITHOUT_ARG("--set_default_to_r",
+		     set_default_to_r, &default_hex_miner,
+		     "Handle USB detect errors as hexR"),
+	OPT_WITH_ARG("--hexminerr-chip-mask",
+		     opt_set_intval, NULL, &opt_hexminerr_chip_mask,
+		     "Set HEXMinerR eneable or disable chips"),	
+	OPT_WITH_ARG("--hexminerr-asic-diff",
+		     opt_set_intval, NULL, &opt_hexminerr_leading_zeros,
+		     "Set HEXMinerR ASIC difficulty"),
+/*		     
+  OPT_WITH_ARG("--hexminerr-hw-err-res",
+  			 opt_set_intval, NULL, &opt_hexminerr_hw_err_res,
+		     "Set HEXMinerR reset chip due to N consecutive HW errors"),	 
+	OPT_WITH_ARG("--hexminerr-nonce-timeout-secs",
+		     opt_set_intval, NULL, &opt_hexminerr_nonce_timeout_secs,
+		     "Set HEXMinerR reset chip due to inactivity in seconds"),		     
+	OPT_WITH_ARG("--hexminerr-reset-below-threshold",
+  			 set_int_0_to_100, NULL, &opt_hexminerr_reset_below_threshold,
+		     "Set HEXMinerR reset board due to low performance"),	 
+	OPT_WITH_ARG("--hexminerr-reset-wait",
+		     set_int_0_to_9999, NULL, &opt_hexminerr_reset_below_threshold_wait,
+		     "Set HEXMinerR wait for 1m speed stats to settle"),            
+*/
+#endif
+
+#ifdef USE_HEXMINERBE200
+OPT_WITH_ARG("--hexminerbe200-options",
+		     opt_set_charp, NULL, &opt_hexminerbe200_options,
+		     "Set HEXMinerBE200 options asic_count:freq"),
+	OPT_WITH_ARG("--hexminerbe200-voltage",
+		     opt_set_intval, NULL, &opt_hexminerbe200_core_voltage,
+		     "Set HEXMinerBE200 core voltage, in millivolts"),
+  OPT_WITH_ARG("--hexminerbe200-pic-roll",
+		     set_int_0_to_255, NULL, &opt_hexminerbe200_pic_roll,
+		     "Set HEXMinerBE200 pic work roll"),	 
+	OPT_WITH_ARG("--hexminerbe200-asic-diff",
+		     opt_set_intval, NULL, &opt_hexminerbe200_diff,
+		     "Set HEXMinerBE200 ASIC difficulty"),
+	OPT_WITH_ARG("--hexminerbe200-chip-mask",
+		      opt_set_intval, NULL, &opt_hexminerbe200_chip_mask,
+		     "Set HEXMinerBE200 eneable or disable chips"),	
+  OPT_WITH_ARG("--hexminerbe200-skip-hw-res",
+         opt_set_intval, NULL, &opt_hexminerbe200_skip_hw_res,
+		     "Enable or disable HEXMinerBE200 automatic reset"),	 	
+  OPT_WITH_ARG("--hexminerbe200-hw-err-res",
+		      opt_set_intval, NULL, &opt_hexminerbe200_hw_err_res,
+		     "Set HEXMinerBE200 reset chip due to N consecutive HW errors"),	 
+	OPT_WITH_ARG("--hexminerbe200-nonce-timeout-secs",
+		     opt_set_intval, NULL, &opt_hexminerbe200_nonce_timeout_secs,
+		     "Set HEXMinerBE200 reset chip due to inactivity in seconds"),	      
+  OPT_WITHOUT_ARG("--set_default_to_be200",
+		     set_default_to_e, &default_hex_miner,
+		     "Handle USB detect errors as hexE"),
+	
+#endif
+
+#ifdef USE_HEXMINER3
+OPT_WITH_ARG("--hexminer3-options",
+		     opt_set_charp, NULL, &opt_hexminer3_options,
+		     "Set HEXMiner3 options asic_count:freq"),
+	OPT_WITH_ARG("--hexminer3-voltage",
+		     opt_set_intval, NULL, &opt_hexminer3_core_voltage,
+		     "Set HEXMiner3 core voltage, in millivolts"),
+	OPT_WITHOUT_ARG("--set_default_to_3",
+		     set_default_to_3, &default_hex_miner,
+		     "Handle USB detect errors as hex3"),
+	OPT_WITH_ARG("--hexminer3-chip-mask",
+		     opt_set_intval, NULL, &opt_hexminer3_chip_mask,
+		     "Set HEXMiner3 eneable or disable chips"),	          
+#endif
 	OPT_WITHOUT_ARG("--load-balance",
 		     set_loadbalance, &pool_strategy,
 		     "Change multipool strategy from failover to quota based balance"),
@@ -1776,6 +2081,33 @@
 #ifdef USE_MINION
 		"minion "
 #endif
+#ifdef USE_HEXMINERA
+		"hexminera "
+#endif
+#ifdef USE_HEXMINERB
+		"hexminerb "
+#endif
+#ifdef USE_HEXMINERC
+		"hexminerc "
+#endif
+#ifdef USE_HEXMINERU
+		"hexmineru "
+#endif
+#ifdef USE_HEXMINER8
+		"hexminer8 "
+#endif
+#ifdef USE_HEXMINERM
+		"hexminerm "
+#endif
+#ifdef USE_HEXMINERR
+		"hexminerr "
+#endif
+#ifdef USE_HEXMINERBE200
+		"hexminerbe200 "
+#endif
+#ifdef USE_HEXMINER3
+		"hexminer3 "
+#endif
 #ifdef USE_MODMINER
 		"modminer "
 #endif
@@ -1873,6 +2205,7 @@
 	int ret;
 
 	cg_wlock(&control_lock);
+	local_work++;
 	ret = total_work++;
 	cg_wunlock(&control_lock);
 
@@ -1967,8 +2300,11 @@
 		if (rc) {
 			applog(LOG_DEBUG, "Successfully retrieved and updated GBT from pool %u %s",
 			       pool->pool_no, pool->rpc_url);
-			if (pool == current_pool())
+			if (pool == current_pool()) {
+				work_pool_update++;
+				clear_pool_work(pool);
 				opt_work_update = true;
+			}
 		} else {
 			applog(LOG_DEBUG, "Successfully retrieved but FAILED to decipher GBT from pool %u %s",
 			       pool->pool_no, pool->rpc_url);
@@ -2029,7 +2365,7 @@
 	}
 
 	calc_midstate(work);
-	local_work++;
+	//local_work++;
 	work->pool = pool;
 	work->gbt = true;
 	work->longpoll = false;
@@ -2519,7 +2855,7 @@
 
 /* Convert a uint64_t value into a truncated string for displaying with its
  * associated suitable for Mega, Giga etc. Buf array needs to be long enough */
-static void suffix_string(uint64_t val, char *buf, size_t bufsiz, int sigdigits)
+void suffix_string(uint64_t val, char *buf, size_t bufsiz, int sigdigits)
 {
 	const double  dkilo = 1000.0;
 	const uint64_t kilo = 1000ull;
@@ -2720,7 +3056,8 @@
 
 static void curses_print_devstatus(struct cgpu_info *cgpu, int devno, int count)
 {
-	static int devno_width = 1, dawidth = 1, drwidth = 1, hwwidth = 1, wuwidth = 1;
+	//static int devno_width = 1, dawidth = 1, drwidth = 1, hwwidth = 1, wuwidth = 1;
+	static int devno_width = 1, dawidth = 1, drwidth = 1, hwwidth = 1, hwwidthp = 1, prwidthp = 1, wuwidth = 1;
 	char logline[256], unique_id[12];
 	struct timeval now;
 	double dev_runtime, wu;
@@ -2749,20 +3086,28 @@
 	wu = cgpu->diff1 / dev_runtime * 60;
 
 	wmove(statuswin,devcursor + count, 0);
+#if defined(USE_HEXMINERA) || defined(USE_HEXMINERB) || defined(USE_HEXMINERC) || defined(USE_HEXMINERU) || defined(USE_HEXMINER8) || defined(USE_HEXMINERM) || defined(USE_HEXMINERR) || defined(USE_HEXMINERBE200) || defined(USE_HEXMINER3)
+	double hwp = (cgpu->hw_errors + cgpu->diff1) ?
+		     (double)100 *(double)(cgpu->hw_errors) / (double)(cgpu->hw_errors + cgpu->diff1) : 0;
+		     
+ double prp = (cgpu->diff_accepted + cgpu->diff_rejected) ?
+		     (double)100 *(double)(cgpu->diff_rejected) / (double)(cgpu->diff_rejected + cgpu->diff_accepted) : 0;
+#endif
 	adj_width(devno, &devno_width);
 	if (cgpu->unique_id) {
 		unique_id[8] = '\0';
 		memcpy(unique_id, blanks, 8);
 		strncpy(unique_id, cgpu->unique_id, 8);
 	} else
-		sprintf(unique_id, "%-8d", cgpu->device_id);
-	cg_wprintw(statuswin, " %*d: %s %-8s: ", devno_width, devno, cgpu->drv->name,
+		sprintf(unique_id, "%-3d", cgpu->device_id);
+		unique_id[3] = '\0';
+	cg_wprintw(statuswin, " %*d: %s %-3s: ", devno_width, devno, cgpu->drv->name,
 		   unique_id);
 	logline[0] = '\0';
 	cgpu->drv->get_statline_before(logline, sizeof(logline), cgpu);
 	devstatlen = strlen(logline);
-	if (devstatlen < STATBEFORELEN)
-		strncat(logline, blanks, STATBEFORELEN - devstatlen);
+	if (devstatlen < STATBEFORELEN - 7)
+		strncat(logline, blanks, STATBEFORELEN - 7 - devstatlen);
 	cg_wprintw(statuswin, "%s | ", logline);
 
 
@@ -2813,13 +3158,39 @@
 		adj_fwidth(cgpu->diff_accepted, &dawidth);
 		adj_fwidth(cgpu->diff_rejected, &drwidth);
 		adj_width(cgpu->hw_errors, &hwwidth);
-		cg_wprintw(statuswin, "A:%*.0f R:%*.0f HW:%*d",
+#if defined(USE_HEXMINERA) || defined(USE_HEXMINERB) || defined(USE_HEXMINERC) || defined(USE_HEXMINERU) || defined(USE_HEXMINER8) || defined(USE_HEXMINERM) || defined(USE_HEXMINERR) || defined(USE_HEXMINERBE200) || defined(USE_HEXMINER3)
+	if(usb_ident(cgpu) == IDENT_HEXA || usb_ident(cgpu) == IDENT_HEXB || usb_ident(cgpu) == IDENT_HEXC || usb_ident(cgpu) == IDENT_HEXU || usb_ident(cgpu) == IDENT_HEX8 || usb_ident(cgpu) == IDENT_HEXM || usb_ident(cgpu) == IDENT_HEXR || usb_ident(cgpu) == IDENT_HEXBE200 || usb_ident(cgpu) == IDENT_HEX3) {
+		adj_width(prp, &prwidthp);
+		adj_width(hwp, &hwwidthp);
+	}
+#endif
+ 	
+ 		adj_width(wu, &wuwidth);
+#if defined(USE_HEXMINERA) || defined(USE_HEXMINERB) || defined(USE_HEXMINERC) || defined(USE_HEXMINERU) || defined(USE_HEXMINER8) || defined(USE_HEXMINERM) || defined(USE_HEXMINERR) || defined(USE_HEXMINERBE200) || defined(USE_HEXMINER3)
+	if(usb_ident(cgpu) == IDENT_HEXA || usb_ident(cgpu) == IDENT_HEXB || usb_ident(cgpu) == IDENT_HEXC || usb_ident(cgpu) == IDENT_HEXU || usb_ident(cgpu) == IDENT_HEX8 || usb_ident(cgpu) == IDENT_HEXM || usb_ident(cgpu) == IDENT_HEXR || usb_ident(cgpu) == IDENT_HEXBE200 || usb_ident(cgpu) == IDENT_HEX3) {
+		cg_wprintw(statuswin, "A:%*.0f R:%*.0f/%*.2f%% HW:%*d/%*.2f%%",
 				dawidth, cgpu->diff_accepted,
 				drwidth, cgpu->diff_rejected,
-				hwwidth, cgpu->hw_errors);
+				prwidthp +1, prp,
+				hwwidth, cgpu->hw_errors,
+				hwwidthp + 1, hwp);
+	} else {
+		cg_wprintw(statuswin, "A:%*.0f R:%*.0f HW:%*d",
+			dawidth, cgpu->diff_accepted,
+			drwidth, cgpu->diff_rejected,
+			hwwidth, cgpu->hw_errors);
 	}
+#else
+ 		cg_wprintw(statuswin, "A:%*.0f R:%*.0f HW:%*d",
+ 				dawidth, cgpu->diff_accepted,
+ 				drwidth, cgpu->diff_rejected,
+ 				hwwidth, cgpu->hw_errors);
+#endif
 
-	logline[0] = '\0';
+ 	}
+ 
+ 	logline[0] = '\0';
+	
 	cgpu->drv->get_statline(logline, sizeof(logline), cgpu);
 	cg_wprintw(statuswin, "%s", logline);
 
@@ -4005,7 +4376,8 @@
 	mutex_unlock(&pool->pool_lock);
 }
 
-static bool stale_work(struct work *work, bool share);
+//static 
+bool stale_work(struct work *work, bool share);
 
 static inline bool should_roll(struct work *work)
 {
@@ -4059,7 +4431,7 @@
 	ntime = be32toh(*work_ntime);
 	ntime++;
 	*work_ntime = htobe32(ntime);
-	local_work++;
+	//local_work++;
 	work->rolls++;
 	work->nonce = 0;
 	applog(LOG_DEBUG, "Successfully rolled work");
@@ -4132,6 +4504,7 @@
 
 static bool clone_available(void)
 {
+	return false;
 	struct work *work_clone = NULL, *work, *tmp;
 	bool cloned = false;
 
@@ -4153,7 +4526,7 @@
 	mutex_unlock(stgd_lock);
 
 	if (cloned) {
-		applog(LOG_DEBUG, "Pushing cloned available work to stage thread");
+		applog(LOG_ERR, "Pushing cloned available work to stage thread");
 		stage_work(work_clone);
 	}
 	return cloned;
@@ -4164,6 +4537,7 @@
  * the future */
 static struct work *clone_work(struct work *work)
 {
+	return work;
 	int mrs = mining_threads + opt_queue - total_staged();
 	struct work *work_clone;
 	bool cloned;
@@ -4174,7 +4548,7 @@
 	cloned = false;
 	work_clone = make_clone(work);
 	while (mrs-- > 0 && can_roll(work) && should_roll(work)) {
-		applog(LOG_DEBUG, "Pushing rolled converted work to stage thread");
+		applog(LOG_ERR, "Pushing rolled converted work to stage thread");
 		stage_work(work_clone);
 		roll_work(work);
 		work_clone = make_clone(work);
@@ -4278,6 +4652,51 @@
 	return work;
 }
 
+#if defined(USE_HEXMINERA) || defined(USE_HEXMINERB) || defined(USE_HEXMINERC) || defined(USE_HEXMINERU) || defined(USE_HEXMINER8) || defined(USE_HEXMINERM) || defined(USE_HEXMINERR) || defined(USE_HEXMINERBE200) || defined(USE_HEXMINER3)
+
+struct work *copy_work_noffset_fast_no_id(struct work *base_work, int noffset)
+{
+	
+  struct work *work = calloc(1, sizeof(struct work));
+
+	if (unlikely(!work))
+		quit(1, "Failed to calloc work in make_work");
+ 
+
+	memcpy(work, base_work, sizeof(struct work));
+	/* Keep the unique new id assigned during make_work to prevent copied
+	 * work from having the same id. */
+	if (base_work->job_id)
+		work->job_id = strdup(base_work->job_id);
+	if (base_work->nonce1)
+		work->nonce1 = strdup(base_work->nonce1);
+	if (base_work->ntime) {
+		/* If we are passed an noffset the binary work->data ntime and
+		 * the work->ntime hex string need to be adjusted. */
+		if (noffset) {
+			uint32_t *work_ntime = (uint32_t *)(work->data + 68);
+			uint32_t ntime = be32toh(*work_ntime);
+
+			ntime += noffset;
+			*work_ntime = htobe32(ntime);
+			work->ntime = offset_ntime(base_work->ntime, noffset);
+		} else
+			work->ntime = strdup(base_work->ntime);
+	} else if (noffset) {
+		uint32_t *work_ntime = (uint32_t *)(work->data + 68);
+		uint32_t ntime = be32toh(*work_ntime);
+
+		ntime += noffset;
+		*work_ntime = htobe32(ntime);
+	}
+	if (base_work->coinbase)
+		work->coinbase = strdup(base_work->coinbase);
+
+	return work;
+}
+
+#endif
+
 void pool_died(struct pool *pool)
 {
 	if (!pool_tset(pool, &pool->idle)) {
@@ -4290,7 +4709,8 @@
 	}
 }
 
-static bool stale_work(struct work *work, bool share)
+//static 
+bool stale_work(struct work *work, bool share)
 {
 	struct timeval now;
 	time_t work_expiry;
@@ -4301,7 +4721,7 @@
 		return false;
 
 	if (work->work_block != work_block) {
-		applog(LOG_DEBUG, "Work stale due to block mismatch");
+		//applog(LOG_DEBUG, "Work stale due to block mismatch");
 		return true;
 	}
 
@@ -4319,19 +4739,19 @@
 		bool same_job;
 
 		if (!pool->stratum_active || !pool->stratum_notify) {
-			applog(LOG_DEBUG, "Work stale due to stratum inactive");
+			//applog(LOG_DEBUG, "Work stale due to stratum inactive");
 			return true;
 		}
 
 		same_job = true;
-
-		cg_rlock(&pool->data_lock);
+    cg_wlock(&pool->data_lock);
+	
 		if (strcmp(work->job_id, pool->swork.job_id))
 			same_job = false;
-		cg_runlock(&pool->data_lock);
+		cg_wunlock(&pool->data_lock);
 
 		if (!same_job) {
-			applog(LOG_DEBUG, "Work stale due to stratum job_id mismatch");
+			//applog(LOG_DEBUG, "Work stale due to stratum job_id mismatch");
 			return true;
 		}
 	}
@@ -4345,13 +4765,13 @@
 
 	cgtime(&now);
 	if ((now.tv_sec - work->tv_staged.tv_sec) >= work_expiry) {
-		applog(LOG_DEBUG, "Work stale due to expiry");
+		//applog(LOG_DEBUG, "Work stale due to expiry");
 		return true;
 	}
 
 	if (opt_fail_only && !share && pool != current_pool() && !work->mandatory &&
 	    pool_strategy != POOL_LOADBALANCE && pool_strategy != POOL_BALANCE) {
-		applog(LOG_DEBUG, "Work stale due to fail only pool mismatch");
+		//applog(LOG_DEBUG, "Work stale due to fail only pool mismatch");
 		return true;
 	}
 
@@ -4560,6 +4980,7 @@
  * work restart is required. Returns the value of pthread_cond_timedwait
  * which is zero if the condition was met or ETIMEDOUT if not.
  */
+/*
 int restart_wait(struct thr_info *thr, unsigned int mstime)
 {
 	struct timeval now, then, tdiff;
@@ -4582,12 +5003,12 @@
 
 	return rc;
 }
-
+*/
 static void *restart_thread(void __maybe_unused *arg)
 {
 	struct pool *cp = current_pool();
-	struct cgpu_info *cgpu;
-	int i, mt;
+	//struct cgpu_info *cgpu;
+	//int i, mt;
 
 	pthread_detach(pthread_self());
 
@@ -4597,7 +5018,7 @@
 
 	/* Discard staged work that is now stale */
 	discard_stale();
-
+/*
 	rd_lock(&mining_thr_lock);
 	mt = mining_threads;
 	rd_unlock(&mining_thr_lock);
@@ -4616,12 +5037,15 @@
 	mutex_lock(&restart_lock);
 	pthread_cond_broadcast(&restart_cond);
 	mutex_unlock(&restart_lock);
-
+*/
 #ifdef USE_USBUTILS
 	/* Cancels any cancellable usb transfers. Flagged as such it means they
 	 * are usualy waiting on a read result and it's safe to abort the read
 	 * early. */
+	#if defined(USE_HEXMINERA) || defined(USE_HEXMINERB) || defined(USE_HEXMINERC) || defined(USE_HEXMINERU) || defined(USE_HEXMINER8) || defined(USE_HEXMINERM) || defined(USE_HEXMINERR) || defined(USE_HEXMINERBE200) || defined(USE_HEXMINER3)
+	#else
 	cancel_usb_transfers();
+	#endif
 #endif
 	return NULL;
 }
@@ -4639,15 +5063,18 @@
 
 static void signal_work_update(void)
 {
+	/*
 	int i;
-
+*/
 	applog(LOG_INFO, "Work update message received");
 
 	cgtime(&update_tv_start);
+	/*
 	rd_lock(&mining_thr_lock);
 	for (i = 0; i < mining_threads; i++)
 		mining_thr[i]->work_update = true;
 	rd_unlock(&mining_thr_lock);
+	*/
 }
 
 static void set_curblock(char *hexstr, unsigned char *bedata)
@@ -4770,7 +5197,8 @@
 		}
 
 		work->work_block = ++work_block;
-
+    //clear_pool_work(pool);
+    discard_stale();
 		if (work->longpoll) {
 			if (work->stratum) {
 				applog(LOG_NOTICE, "Stratum from pool %d detected new block",
@@ -4810,6 +5238,8 @@
 #endif
 		if (work->longpoll) {
 			work->work_block = ++work_block;
+			discard_stale();
+			//clear_pool_work(pool);
 			if (shared_strategy() || work->pool == current_pool()) {
 				if (work->stratum) {
 					applog(LOG_NOTICE, "Stratum from pool %d requested work restart",
@@ -4832,19 +5262,19 @@
 {
 	return worka->tv_staged.tv_sec - workb->tv_staged.tv_sec;
 }
-
+/*
 static bool work_rollable(struct work *work)
 {
 	return (!work->clone && work->rolltime);
 }
-
+*/
 static bool hash_push(struct work *work)
 {
 	bool rc = true;
 
 	mutex_lock(stgd_lock);
-	if (work_rollable(work))
-		staged_rollable++;
+	//if (work_rollable(work))
+		//staged_rollable++;
 	if (likely(!getq->frozen)) {
 		HASH_ADD_INT(staged_work, id, work);
 		HASH_SORT(staged_work, tv_sort);
@@ -5019,7 +5449,6 @@
 	/* Simple bool,int and char options */
 	for (opt = opt_config_table; opt->type != OPT_END; opt++) {
 		char *p, *name = strdup(opt->names);
-
 		for (p = strtok(name, "|"); p; p = strtok(NULL, "|")) {
 			if (p[1] != '-')
 				continue;
@@ -5068,6 +5497,34 @@
 	}
 
 	/* Special case options */
+#ifdef USE_HEXMINERA
+	if (default_hex_miner == D_HEXA)
+		 fputs(",\n\"set_default_to_a\" : true", fcfg);
+#endif
+#ifdef USE_HEXMINERB
+	if (default_hex_miner == D_HEXB)
+		 fputs(",\n\"set_default_to_b\" : true", fcfg);
+#endif
+#ifdef USE_HEXMINERC
+	if (default_hex_miner == D_HEXC)
+		 fputs(",\n\"set_default_to_c\" : true", fcfg);
+#endif
+#ifdef USE_HEXMINER8
+	if (default_hex_miner == D_HEX8)
+		 fputs(",\n\"set_default_to_8\" : true", fcfg);
+#endif
+#ifdef USE_HEXMINERM
+	if (default_hex_miner == D_HEXM)
+		 fputs(",\n\"set_default_to_m\" : true", fcfg);
+#endif
+#ifdef USE_HEXMINERR
+	if (default_hex_miner == D_HEXR)
+		 fputs(",\n\"set_default_to_r\" : true", fcfg);
+#endif
+#ifdef USE_HEXMINERBE200
+	if (default_hex_miner == D_HEXBE200)
+		 fputs(",\n\"set_default_to_be200\" : true", fcfg);
+#endif
 	if (pool_strategy == POOL_BALANCE)
 		fputs(",\n\"balance\" : true", fcfg);
 	if (pool_strategy == POOL_LOADBALANCE)
@@ -6734,15 +7191,15 @@
  * be handled. */
 static struct work *hash_pop(bool blocking)
 {
-	struct work *work = NULL, *tmp;
-	int hc;
+	struct work *work = NULL;//, *tmp;
+	//int hc;
 
 	mutex_lock(stgd_lock);
 	if (!HASH_COUNT(staged_work)) {
 		/* Increase the queue if we reach zero and we know we can reach
 		 * the maximum we're asking for. */
 		if (work_filled && max_queue < opt_queue) {
-			max_queue++;
+			if(max_queue < most_devices * 2) max_queue++;
 			work_filled = false;
 		}
 		work_emptied = true;
@@ -6773,18 +7230,18 @@
 		no_work = false;
 	}
 
-	hc = HASH_COUNT(staged_work);
+	//hc = HASH_COUNT(staged_work);
 	/* Find clone work if possible, to allow masters to be reused */
-	if (hc > staged_rollable) {
-		HASH_ITER(hh, staged_work, work, tmp) {
-			if (!work_rollable(work))
-				break;
-		}
-	} else
+	//if (hc > staged_rollable) {
+		//HASH_ITER(hh, staged_work, work, tmp) {
+			//if (!work_rollable(work))
+				//break;
+		//}
+	//} else
 		work = staged_work;
 	HASH_DEL(staged_work, work);
-	if (work_rollable(work))
-		staged_rollable--;
+	//if (work_rollable(work))
+		//staged_rollable--;
 
 	/* Signal the getwork scheduler to look for more work */
 	pthread_cond_signal(&gws_cond);
@@ -6908,7 +7365,7 @@
 	memcpy(pool->coinbase + pool->nonce2_offset, &nonce2le, pool->n2size);
 	work->nonce2 = pool->nonce2++;
 	work->nonce2_len = pool->n2size;
-
+  work->job_id = strdup(pool->swork.job_id);
 	/* Downgrade to a read lock to read off the pool variables */
 	cg_dwlock(&pool->data_lock);
 
@@ -6933,7 +7390,7 @@
 	work->sdiff = pool->sdiff;
 
 	/* Copy parameters required for share submission */
-	work->job_id = strdup(pool->swork.job_id);
+//	work->job_id = strdup(pool->swork.job_id);
 	work->nonce1 = strdup(pool->nonce1);
 	work->ntime = strdup(pool->ntime);
 	cg_runlock(&pool->data_lock);
@@ -6954,7 +7411,7 @@
 	calc_midstate(work);
 	set_target(work->target, work->sdiff);
 
-	local_work++;
+	//local_work++;
 	work->pool = pool;
 	work->stratum = true;
 	work->nonce = 0;
@@ -7095,7 +7552,7 @@
 
 	calc_midstate(work);
 
-	local_work++;
+	//local_work++;
 	work->gbt = true;
 	work->pool = pool;
 	work->nonce = 0;
@@ -7138,7 +7595,7 @@
 	time_t diff_t;
 
 	thread_reportout(thr);
-	applog(LOG_DEBUG, "Popping work from get queue to get work");
+	//applog(LOG_DEBUG, "Popping work from get queue to get work");
 	diff_t = time(NULL);
 	while (!work) {
 		work = hash_pop(true);
@@ -7152,10 +7609,10 @@
 	 * the device's last valid work to not make outages appear to be
 	 * device failures. */
 	if (diff_t > 0) {
-		applog(LOG_DEBUG, "Get work blocked for %d seconds", (int)diff_t);
+	//	applog(LOG_DEBUG, "Get work blocked for %d seconds", (int)diff_t);
 		cgpu->last_device_valid_work += diff_t;
 	}
-	applog(LOG_DEBUG, "Got work from get queue to get work for thread %d", thr_id);
+	//applog(LOG_DEBUG, "Got work from get queue to get work for thread %d", thr_id);
 
 	work->thr_id = thr_id;
 	if (opt_benchmark)
@@ -7239,6 +7696,18 @@
 	thr->cgpu->drv->hw_error(thr);
 }
 
+void inc_hw_errors_hex8(struct thr_info *thr, int diff)
+{
+	applog(LOG_INFO, "%s%d: invalid nonce - HW error", thr->cgpu->drv->name,
+	       thr->cgpu->device_id);
+
+	mutex_lock(&stats_lock);
+	hw_errors-=diff;
+	thr->cgpu->hw_errors-=diff;
+	mutex_unlock(&stats_lock);
+
+	thr->cgpu->drv->hw_error(thr);
+}
 /* Fills in the work nonce and builds the output data in work->hash */
 static void rebuild_nonce(struct work *work, uint32_t nonce)
 {
@@ -7285,9 +7754,23 @@
 	}
 
 	mutex_lock(&stats_lock);
+#if defined(USE_HEXMINERA) || defined(USE_HEXMINERB) || defined(USE_HEXMINERC) || defined(USE_HEXMINERU) || defined(USE_HEXMINER8) || defined(USE_HEXMINERM) || defined(USE_HEXMINERR) || defined(USE_HEXMINERBE200) || defined(USE_HEXMINER3)
+if(work->ping) {
 	total_diff1 += work->device_diff;
 	thr->cgpu->diff1 += work->device_diff;
 	work->pool->diff1 += work->device_diff;
+ } else {
+ 	total_diff1 += work->work_difficulty;
+	thr->cgpu->diff1 += work->work_difficulty;
+	work->pool->diff1 += work->work_difficulty;
+ }
+#else
+	total_diff1 += work->device_diff;
+	thr->cgpu->diff1 += work->device_diff;
+	work->pool->diff1 += work->device_diff;
+#endif
+
+	
 	thr->cgpu->last_device_valid_work = time(NULL);
 	mutex_unlock(&stats_lock);
 }
@@ -7309,6 +7792,47 @@
 	return true;
 }
 
+#if defined(USE_HEXMINERA) || defined(USE_HEXMINERB) || defined(USE_HEXMINERC) || defined(USE_HEXMINERU) || defined(USE_HEXMINER8) || defined(USE_HEXMINERM) || defined(USE_HEXMINERR) || defined(USE_HEXMINERBE200) || defined(USE_HEXMINER3)
+
+bool submit_tested_work_fast_clone(struct thr_info *thr, struct work *work, bool diff1)
+{
+	struct work *work_sub;
+	update_work_stats(thr, work);
+	
+  if(diff1) {
+		if (!fulltest(work->hash, work->target)) {
+			applog(LOG_INFO, "%s %d: Share above target",
+				thr->cgpu->drv->name, thr->cgpu->device_id);
+			return false;
+		}
+	}
+	
+  work_sub = copy_work_noffset_fast_no_id (work, 0);
+  
+	submit_work_async(work_sub);
+	return true;
+}
+
+bool submit_tested_work_no_clone(struct thr_info *thr, struct work *work, bool diff1)
+{
+
+	update_work_stats(thr, work);
+	
+  if(diff1) {
+		if (!fulltest(work->hash, work->target)) {
+			applog(LOG_INFO, "%s %d: Share above target",
+				thr->cgpu->drv->name, thr->cgpu->device_id);
+				free_work (work);
+			return false;
+		}
+	}
+	
+	submit_work_async(work);
+	return true;
+}
+
+#endif
+
 /* Returns true if nonce for work was a valid share */
 bool submit_nonce(struct thr_info *thr, struct work *work, uint32_t nonce)
 {
@@ -7404,9 +7928,10 @@
 	while (likely(!cgpu->shutdown)) {
 		struct work *work = get_work(mythr, thr_id);
 		int64_t hashes;
-
+		
 		mythr->work_restart = false;
 		cgpu->new_work = true;
+		
 
 		cgtime(&tv_workstart);
 		work->nonce = 0;
@@ -7769,6 +8294,7 @@
 		free_work(work);
 		applog(LOG_DEBUG, "Discarded queued work item");
 	}
+	
 }
 
 /* This version of hash work is for devices that are fast enough to always
@@ -7786,17 +8312,19 @@
 	while (likely(!cgpu->shutdown)) {
 		struct timeval diff;
 		int64_t hashes;
-
+    
 		mythr->work_update = false;
-
+  //	if(mythr->work_restart)
+  //applog(LOG_ERR,"mythr->work_restart cg 11");
 		fill_queue(mythr, cgpu, drv, thr_id);
 
 		hashes = drv->scanwork(mythr);
 
 		/* Reset the bool here in case the driver looks for it
 		 * synchronously in the scanwork loop. */
+		
 		mythr->work_restart = false;
-
+  	
 		if (unlikely(hashes == -1 )) {
 			applog(LOG_ERR, "%s %d failure, disabling!", drv->name, cgpu->device_id);
 			cgpu->deven = DEV_DISABLED;
@@ -7818,8 +8346,8 @@
 		if (unlikely(mythr->pause || cgpu->deven != DEV_ENABLED))
 			mt_disable(mythr, thr_id, drv);
 
-		if (mythr->work_update)
-			drv->update_work(cgpu);
+ 		//if (mythr->work_update)
+			//drv->update_work(cgpu);
 	}
 	cgpu->deven = DEV_DISABLED;
 }
@@ -7869,8 +8397,8 @@
 		if (unlikely(mythr->pause || cgpu->deven != DEV_ENABLED))
 			mt_disable(mythr, thr_id, drv);
 
-		if (mythr->work_update)
-			drv->update_work(cgpu);
+   // if (mythr->work_update)
+			//drv->update_work(cgpu);
 	}
 	cgpu->deven = DEV_DISABLED;
 }
@@ -8482,7 +9010,12 @@
 				dev_error(cgpu, REASON_DEV_SICK_IDLE_60);
 				if (opt_restart) {
 					applog(LOG_ERR, "%s: Attempting to restart", dev_str);
-					reinit_device(cgpu);
+				reinit_device(cgpu);
+			/*
+		 	  	cgpu->deven = DEV_DISABLED;
+				  dev_error(cgpu, REASON_THREAD_ZERO_HASH); 
+					cgpu->shutdown = true;
+			*/      
 				}
 			} else if (cgpu->status == LIFE_SICK && (now.tv_sec - thr->last.tv_sec > WATCHDOG_DEAD_TIME)) {
 				cgpu->status = LIFE_DEAD;
@@ -8494,8 +9027,8 @@
 				   (cgpu->status == LIFE_SICK || cgpu->status == LIFE_DEAD)) {
 				/* Attempt to restart a GPU that's sick or dead once every minute */
 				cgtime(&thr->sick);
-				if (opt_restart)
-					reinit_device(cgpu);
+		 		if (opt_restart)
+						reinit_device(cgpu);      
 			}
 		}
 	}
@@ -8600,9 +9133,12 @@
 static void clean_up(bool restarting)
 {
 #ifdef USE_USBUTILS
-	usb_polling = false;
-	pthread_join(usb_poll_thread, NULL);
-        libusb_exit(NULL);
+ usb_polling = false;
+#if defined(USE_HEXMINERA) || defined(USE_HEXMINERB) || defined(USE_HEXMINERC) || defined(USE_HEXMINERU) || defined(USE_HEXMINER8) || defined(USE_HEXMINERM) || defined(USE_HEXMINERR) || defined(USE_HEXMINERBE200) || defined(USE_HEXMINER3)
+#else
+ pthread_join(usb_poll_thread, NULL);      
+#endif
+ libusb_exit(NULL);
 #endif
 
 	cgtime(&total_tv_end);
@@ -9266,6 +9802,8 @@
 #define DRIVER_DRV_DETECT_ALL(X) X##_drv.drv_detect(false);
 
 #ifdef USE_USBUTILS
+#if defined(USE_HEXMINERA) || defined(USE_HEXMINERB)  || defined(USE_HEXMINERC) || defined(USE_HEXMINERU) || defined(USE_HEXMINER8) || defined(USE_HEXMINERM) || defined(USE_HEXMINERR) || defined(USE_HEXMINERBE200) || defined(USE_HEXMINER3)
+#else
 static void *libusb_poll_thread(void __maybe_unused *arg)
 {
 	struct timeval tv_end = {1, 0};
@@ -9286,7 +9824,7 @@
 
 	return NULL;
 }
-
+#endif
 static void initialise_usb(void) {
 	int err = libusb_init(NULL);
 
@@ -9297,7 +9835,10 @@
 	}
 	initialise_usblocks();
 	usb_polling = true;
+	#if defined(USE_HEXMINERA) || defined(USE_HEXMINERB)  || defined(USE_HEXMINERC) || defined(USE_HEXMINERU) || defined(USE_HEXMINER8) || defined(USE_HEXMINERM) || defined(USE_HEXMINERR) || defined(USE_HEXMINERBE200) || defined(USE_HEXMINER3)
+	#else
 	pthread_create(&usb_poll_thread, NULL, libusb_poll_thread, NULL);
+	#endif
 }
 #else
 #define initialise_usb() {}
@@ -9345,11 +9886,11 @@
 	mutex_init(&lp_lock);
 	if (unlikely(pthread_cond_init(&lp_cond, NULL)))
 		early_quit(1, "Failed to pthread_cond_init lp_cond");
-
+/*
 	mutex_init(&restart_lock);
 	if (unlikely(pthread_cond_init(&restart_cond, NULL)))
 		early_quit(1, "Failed to pthread_cond_init restart_cond");
-
+*/
 	if (unlikely(pthread_cond_init(&gws_cond, NULL)))
 		early_quit(1, "Failed to pthread_cond_init gws_cond");
 
@@ -9733,8 +10274,8 @@
 
 		/* If the primary pool is a getwork pool and cannot roll work,
 		 * try to stage one extra work per mining thread */
-		if (!pool_localgen(cp) && !staged_rollable)
-			max_staged += mining_threads;
+		//if (!pool_localgen(cp) && !staged_rollable)
+			//max_staged += mining_threads;
 
 		mutex_lock(stgd_lock);
 		ts = __total_staged();
@@ -9745,7 +10286,7 @@
 		/* Wait until hash_pop tells us we need to create more work */
 		if (ts > max_staged) {
 			if (work_emptied && max_queue < opt_queue) {
-				max_queue++;
+				if(max_queue < most_devices * 2) max_queue++;
 				work_emptied = false;
 			}
 			work_filled = true;
@@ -9754,12 +10295,12 @@
 		}
 		mutex_unlock(stgd_lock);
 
-		if (ts > max_staged) {
+		if (ts > max_staged ) {
 			/* Keeps slowly generating work even if it's not being
 			 * used to keep last_getwork incrementing and to see
 			 * if pools are still alive. */
 			if (work_emptied && max_queue < opt_queue) {
-				max_queue++;
+				if(max_queue < most_devices * 2) max_queue++;
 				work_emptied = false;
 			}
 			work_filled = true;
--- cg_o/configure.ac	2014-09-22 14:22:33.036837532 +0300
+++ cgminer_hex/configure.ac	2014-09-22 19:28:38.671387123 +0300
@@ -329,6 +329,105 @@
 AM_CONDITIONAL([HAS_MINION], [test x$minion = xyes])
 
 
+hexminera="no"
+
+AC_ARG_ENABLE([hexminera],
+	[AC_HELP_STRING([--enable-hexminera],[Compile support for hexminera (default disabled)])],
+	[hexminera=$enableval]
+	)
+if test "x$hexminera" = xyes; then
+	AC_DEFINE([USE_HEXMINERA], [1], [Defined to 1 if hexminera support is wanted])
+fi
+AM_CONDITIONAL([HAS_HEXMINERA], [test x$hexminera = xyes])
+
+hexminerb="no"
+
+AC_ARG_ENABLE([hexminerb],
+	[AC_HELP_STRING([--enable-hexminerb],[Compile support for hexminerb (default disabled)])],
+	[hexminerb=$enableval]
+	)
+if test "x$hexminerb" = xyes; then
+	AC_DEFINE([USE_HEXMINERB], [1], [Defined to 1 if hexminerb support is wanted])
+fi
+AM_CONDITIONAL([HAS_HEXMINERB], [test x$hexminerb = xyes])
+
+hexmineru="no"
+
+AC_ARG_ENABLE([hexmineru],
+	[AC_HELP_STRING([--enable-hexmineru],[Compile support for hexmineru (default disabled)])],
+	[hexmineru=$enableval]
+	)
+if test "x$hexmineru" = xyes; then
+	AC_DEFINE([USE_HEXMINERU], [1], [Defined to 1 if hexmineru support is wanted])
+fi
+AM_CONDITIONAL([HAS_HEXMINERU], [test x$hexmineru = xyes])
+
+hexminerc="no"
+
+AC_ARG_ENABLE([hexminerc],
+	[AC_HELP_STRING([--enable-hexminerc],[Compile support for hexminerc (default disabled)])],
+	[hexminerc=$enableval]
+	)
+if test "x$hexminerc" = xyes; then
+	AC_DEFINE([USE_HEXMINERC], [1], [Defined to 1 if hexminerc support is wanted])
+fi
+AM_CONDITIONAL([HAS_HEXMINERC], [test x$hexminerc = xyes])
+
+hexminer8="no"
+
+AC_ARG_ENABLE([hexminer8],
+	[AC_HELP_STRING([--enable-hexminer8],[Compile support for hexminer8 (default disabled)])],
+	[hexminer8=$enableval]
+	)
+if test "x$hexminer8" = xyes; then
+	AC_DEFINE([USE_HEXMINER8], [1], [Defined to 1 if hexminer8 support is wanted])
+fi
+AM_CONDITIONAL([HAS_HEXMINER8], [test x$hexminer8 = xyes])
+
+hexminerm="no"
+
+AC_ARG_ENABLE([hexminerm],
+	[AC_HELP_STRING([--enable-hexminerm],[Compile support for hexminerm (default disabled)])],
+	[hexminerm=$enableval]
+	)
+if test "x$hexminerm" = xyes; then
+	AC_DEFINE([USE_HEXMINERM], [1], [Defined to 1 if hexminerm support is wanted])
+fi
+AM_CONDITIONAL([HAS_HEXMINERM], [test x$hexminerm = xyes])
+
+hexminerr="no"
+
+AC_ARG_ENABLE([hexminerr],
+	[AC_HELP_STRING([--enable-hexminerr],[Compile support for hexminerr (default disabled)])],
+	[hexminerr=$enableval]
+	)
+if test "x$hexminerr" = xyes; then
+	AC_DEFINE([USE_HEXMINERR], [1], [Defined to 1 if hexminerr support is wanted])
+fi
+AM_CONDITIONAL([HAS_HEXMINERR], [test x$hexminerr = xyes])
+
+hexminerbe200="no"
+
+AC_ARG_ENABLE([hexminerbe200],
+	[AC_HELP_STRING([--enable-hexminerbe200],[Compile support for hexminerbe200 (default disabled)])],
+	[hexminerbe200=$enableval]
+	)
+if test "x$hexminerbe200" = xyes; then
+	AC_DEFINE([USE_HEXMINERBE200], [1], [Defined to 1 if hexminerbe200 support is wanted])
+fi
+AM_CONDITIONAL([HAS_HEXMINERBE200], [test x$hexminerbe200 = xyes])
+
+hexminer3="no"
+
+AC_ARG_ENABLE([hexminer3],
+	[AC_HELP_STRING([--enable-hexminer3],[Compile support for hexminer3 (default disabled)])],
+	[hexminer3=$enableval]
+	)
+if test "x$hexminer3" = xyes; then
+	AC_DEFINE([USE_HEXMINER3], [1], [Defined to 1 if hexminer3 support is wanted])
+fi
+AM_CONDITIONAL([HAS_HEXMINER3], [test x$hexminer3 = xyes])
+
 modminer="no"
 
 AC_ARG_ENABLE([modminer],
@@ -390,7 +489,7 @@
 	])
 fi
 
-if test x$avalon$avalon2$bitforce$bitfury$modminer$bflsc$icarus$hashfast$hashratio$klondike$drillbit$cointerra$ants1$ants2 != xnononononononononononononono; then
+if test x$hexminera$hexminerb$hexminerc$hexmineru$hexminer8$hexminerm$hexminerr$hexminerbe200$hexminer3$avalon$avalon2$bitforce$bitfury$modminer$bflsc$icarus$hashfast$hashratio$klondike$drillbit$cointerra$ants1$ants2 != xnononononononononononononono; then
 	want_usbutils=true
 else
 	want_usbutils=false
@@ -613,6 +712,56 @@
 	echo "  BlackArrow.ASICs.....: Disabled"
 fi
 
+if test "x$hexminera" = xyes; then
+	echo "  HEX16A.ASICs.........: Enabled"
+else
+	echo "  HEX16A.ASICs.........: Disabled"
+fi
+
+if test "x$hexminerb" = xyes; then
+	echo "  HEX16B.ASICs.........: Enabled"
+else
+	echo "  HEX16B.ASICs.........: Disabled"
+fi
+
+if test "x$hexminerc" = xyes; then
+	echo "  HEX16C.ASICs.........: Enabled"
+else
+	echo "  HEX16C.ASICs.........: Disabled"
+fi
+
+if test "x$hexminer8" = xyes; then
+	echo "  HEX8A1.ASICs.........: Enabled"
+else
+	echo "  HEX8A1.ASICs.........: Disabled"
+fi
+if test "x$hexminerm" = xyes; then
+	echo "  HEX8M.ASICs..........: Enabled"
+else
+	echo "  HEX8M.ASICs..........: Disabled"
+fi
+if test "x$hexminerr" = xyes; then
+	echo "  HEX8R.ASICs..........: Enabled"
+else
+	echo "  HEX8R.ASICs..........: Disabled"
+fi
+if test "x$hexminerbe200" = xyes; then
+	echo "  HEX16B200.ASICs......: Enabled"
+else
+	echo "  HEX16B200.ASICs......: Disabled"
+fi
+if test "x$hexminer3" = xyes; then
+	echo "  HEX3A3.ASICs.........: Enabled"
+else
+	echo "  HEX3A3.ASICs.........: Disabled"
+fi
+
+if test "x$hexmineru" = xyes; then
+	echo "  HEX16U.ASICs.........: Enabled"
+else
+	echo "  HEX16U.ASICs.........: Disabled"
+fi
+
 if test "x$bflsc" = xyes; then
 	echo "  BFL.ASICs............: Enabled"
 else
@@ -699,7 +848,7 @@
 	echo "  ModMiner.FPGAs.......: Disabled"
 fi
 
-if test "x$avalon$avalon2$bab$bflsc$bitforce$bitfury$hashfast$hashratio$icarus$klondike$knc$modminer$drillbit$minion$cointerra$bitmine_A1$ants1$ants2$sp10$sp30" = xnononononononononononononononononononono; then
+if test "x$hexminera$hexminerb$hexminerc$hexmineru$hexminer8$hexminerm$hexminerr$hexminerbe200$hexminer3$avalon$avalon2$bab$bflsc$bitforce$bitfury$hashfast$hashratio$icarus$klondike$knc$modminer$drillbit$minion$cointerra$bitmine_A1$ants1$ants2$sp10$sp30" = xnononononononononononononononononononono; then
 	AC_MSG_ERROR([No mining configured in])
 fi
 
--- cg_o/driver-hexminerb.c	1970-01-01 02:00:00.000000000 +0200
+++ cgminer_hex/driver-hexminerb.c	2014-09-22 19:28:38.671387123 +0300
@@ -0,0 +1,496 @@
+/*$T indentinput.c GC 1.140 10/16/13 10:19:47 */
+#include "config.h"
+#include <limits.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <ctype.h>
+#include <dirent.h>
+#include <unistd.h>
+#ifndef WIN32
+#include <sys/select.h>
+#include <termios.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#ifndef O_CLOEXEC
+#define O_CLOEXEC 0
+#endif
+#else
+#include "compat.h"
+#include <windows.h>
+#include <io.h>
+#endif
+#include "elist.h"
+#include "miner.h"
+#include "usbutils.h"
+#include "driver-hexminerb.h"
+#include "util.h"
+extern unsigned int work_block;
+extern unsigned int work_pool_update;
+extern struct work *copy_work_noffset_fast_no_id (struct work *base_work,
+                                                  int noffset);
+extern bool stale_work (struct work *work, bool share);
+extern bool submit_tested_work_fast_clone (struct thr_info *thr,
+                                           struct work *work, bool diff1);
+struct device_drv hexminerb_drv;
+int opt_hexminerb_core_voltage = HEXB_DEFAULT_CORE_VOLTAGE;
+
+#include "libhexb.c"
+
+static int
+hexminerb_send_task (struct hexminerb_task *ht, struct cgpu_info *hexminerb)
+{
+  int ret = 0;
+  size_t nr_len = HEXMINERB_TASK_SIZE;
+  struct hexminerb_info *info;
+  info = hexminerb->device_data;
+  libhexb_csum (&ht->startbyte, &ht->csum, &ht->csum);
+  ret = libhexb_sendHashData (hexminerb, &ht->startbyte, nr_len);
+  if (ret != nr_len)
+    {
+      libhexb_reset (hexminerb);
+      info->usb_w_errors++;
+      return -1;
+    }
+  return ret;
+}
+
+static inline void
+hexminerb_create_task (bool reset_work, struct hexminerb_task *ht,
+                       struct work *work)
+{
+  if (reset_work)
+    ht->status = HEXB_STAT_NEW_WORK_CLEAR_OLD;
+  else
+    ht->status = HEXB_STAT_NEW_WORK;
+  memcpy (ht->midstate, work->midstate, 32);
+  memcpy (ht->merkle, work->data + 64, 12);
+  ht->id = (uint8_t) work->subid;
+  BITFURY_MS3compute (work, ht);
+}
+
+static inline void
+hexminerb_init_task (struct hexminerb_task *ht, struct hexminerb_info *info)
+{
+  ht->startbyte = 0x53;
+  ht->datalength = (uint8_t) ((HEXMINERB_TASK_SIZE - 6) / 2);
+  ht->command = 0x57;
+  ht->address = htole16 (HEXB_WORKQUEUE_ADR);
+  libhexb_setvoltage (info->core_voltage, &ht->refvoltage);
+  ht->chipcount = htole16 (info->asic_count);
+  ht->hashclock = htole16 ((uint16_t) info->frequency);
+}
+
+static void
+do_write_hexb (struct thr_info *thr)
+{
+  struct cgpu_info *hexminerb = thr->cgpu;
+  struct hexminerb_info *info = hexminerb->device_data;
+  struct work *tmpwork = NULL;
+  int send_jobs, ret;
+  int jobs_to_send = info->jobs_to_send;
+  send_jobs = 0;
+  while (!libhexb_usb_dead (hexminerb) && (send_jobs < jobs_to_send))
+    {
+    again:
+      if (!info->work)
+        {
+          info->roll = 0;
+          info->work = get_work (thr, thr->id);
+          info->work->ping = 1;
+        }
+      if (stale_work (info->work, false))
+        {
+          free_work (info->work);
+          info->work = NULL;
+          if (info->work_block_local != work_block || info->work_pool_update != work_pool_update)
+            {
+              info->reset_work = true;
+              send_jobs = 0;
+              jobs_to_send = 4;
+              info->work_block_local = work_block;
+              info->work_pool_update = work_pool_update;
+            }
+          goto again;
+        }
+      if (info->write_pos >= HEXMINERB_ARRAY_SIZE_REAL || info->reset_work)
+        info->write_pos = 0;
+      info->work->subid = info->write_pos;
+      tmpwork = copy_work_noffset_fast_no_id (info->work, info->roll++);
+      hexminerb_create_task (info->reset_work, info->ht, tmpwork);
+      free_work (info->hexworks[info->write_pos]);
+      info->hexworks[info->write_pos] = tmpwork;
+      if (info->work->drv_rolllimit)
+        info->work->drv_rolllimit--;
+      else
+        {
+          free_work (info->work);
+          info->work = NULL;
+        }
+      ret = hexminerb_send_task (info->ht, hexminerb);
+      info->write_pos++;
+      send_jobs++;
+      if (ret == HEXMINERB_TASK_SIZE && info->reset_work)
+        {
+          info->reset_work = false;
+          gettimeofday (&info->last_wr, NULL);
+        }
+    }
+}
+
+static int
+free_buff_space (int cur, int last)
+{
+  int ret = cur - last;
+  if (ret > 0)
+    return ret;
+  ret += 254;
+  return ret;
+}
+
+static int64_t
+hexminerb_scanhash (struct thr_info *thr)
+{
+  struct cgpu_info *hexminerb = thr->cgpu;
+  struct hexminerb_info *info = hexminerb->device_data;
+  uint32_t nonce;
+  int notdupe, found;
+  int ret_r = 0;
+  int64_t hash_count = 0;
+  int64_t tdif;
+  int rminder = 0;
+  struct timeval now;
+  struct timeval diff;
+  int free_sp = free_buff_space (info->write_pos, info->wr->lastnonceid);
+  if (info->work_block_local != work_block || info->work_pool_update != work_pool_update)
+    {
+      info->reset_work = true;
+      info->jobs_to_send = 4;
+      info->work_block_local = work_block;
+      info->work_pool_update = work_pool_update;
+      if (info->work)
+        {
+          free_work (info->work);
+          info->work = NULL;
+        }
+      gettimeofday (&info->last_wr, NULL);
+      do_write_hexb (thr);
+      goto done_wr;
+    }
+  gettimeofday (&now, NULL);
+  tdif = timediff (&now, &info->last_wr);
+  info->jobs_to_send = (int) (tdif / info->wsem_ustiming);
+  rminder = (int) (tdif % info->wsem_ustiming);
+  if (info->jobs_to_send > 0 || free_sp < 32)
+    {
+      gettimeofday (&info->last_wr, NULL);
+      if (free_sp > 32)
+        goto done_wr;
+      now.tv_sec = 0;
+      now.tv_usec = rminder;
+      timersub (&info->last_wr, &now, &diff);
+      memcpy (&info->last_wr, &diff, sizeof (struct timeval));
+      if (free_sp < 32)
+        info->jobs_to_send++;
+      if (info->jobs_to_send > 8)
+        info->jobs_to_send = 6;
+      do_write_hexb (thr);
+    }
+done_wr:
+  if (libhexb_usb_dead (hexminerb))
+    {
+      hexminerb->shutdown = true;
+      return -1;
+    }
+  if (info->hash_write_pos + HEXB_USB_R_SIZE > HEXB_HASH_BUF_SIZE_OK)
+    {
+      info->hash_write_pos = info->hash_write_pos - info->hash_read_pos;
+      memcpy (info->readbuf, info->readbuf + info->hash_read_pos,
+              info->hash_write_pos);
+      info->hash_read_pos = 0;
+    }
+  if (info->hash_write_pos - info->hash_read_pos > 7)
+    {
+    again:
+    	if (info->work_block_local != work_block || info->work_pool_update != work_pool_update)
+    		goto new_block;
+      ret_r =
+        libhexb_eatHashData (info->wr, info->readbuf, &info->hash_read_pos,
+                             &info->hash_write_pos);
+      if (ret_r > HEXB_BUF_DATA)
+        goto out;
+      if (info->wr->lastnonceid > HEXMINERB_ARRAY_SIZE_REAL)
+        info->wr->lastnonceid = 0;
+      if (info->wr->prevnonceid > HEXMINERB_ARRAY_SIZE_REAL)
+        info->wr->prevnonceid = 0;
+      if (info->wr->lastchippos > 15)
+        info->wr->lastchippos = 15;
+      nonce = decnonce (htole32 (info->wr->lastnonce));
+      notdupe =
+        libhexb_cachenonce (&info->array_nonce_cache[info->wr->lastchippos],
+                            nonce);
+      if (notdupe)
+        {
+          found =
+            hexminerb_predecode_nonce (hexminerb, thr, nonce,
+                                       info->wr->lastnonceid);
+          if (found == 0)
+            found =
+              hexminerb_predecode_nonce (hexminerb, thr, nonce,
+                                         info->wr->prevnonceid);
+          if (found > 0)
+            {
+              if (hash_count == 0)
+                libhexb_getvoltage (htole16 (info->wr->lastvoltage),
+                                    &info->pic_voltage_readings);
+              hash_count += found;
+              info->matching_work[info->wr->lastchippos]++;
+            }
+        }
+      else
+        info->dupe[info->wr->lastchippos]++;
+    out:
+      if (ret_r == HEXB_BUF_ERR)
+        info->usb_r_errors++;
+      if (ret_r != HEXB_BUF_SKIP)
+        goto again;
+    }
+  if (info->work_block_local != work_block || info->work_pool_update != work_pool_update)
+    		goto new_block;
+  ret_r =
+    libhexb_readHashData (hexminerb, info->readbuf, &info->hash_write_pos,
+                          HEXMINERB_BULK_READ_TIMEOUT);
+  if (ret_r != LIBUSB_SUCCESS)
+    info->usb_bad_reads++;
+  else
+    info->usb_bad_reads = 0;
+  if (info->usb_bad_reads > 20)
+    libhexb_reset (hexminerb);
+  new_block:
+  hash_count = (int64_t) (0xffffffffull * hash_count);
+  if (libhexb_usb_dead (hexminerb))
+    {
+      hexminerb->shutdown = true;
+      return -1;
+    }
+  return hash_count;
+}
+
+static struct cgpu_info *
+hexminerb_detect_one (libusb_device * dev, struct usb_find_devices *found)
+{
+  int asic_count, frequency;
+  struct hexminerb_info *info;
+  struct cgpu_info *hexminerb;
+  bool configured = false;
+  int i = 0;
+  hexminerb = usb_alloc_cgpu (&hexminerb_drv, HEXB_MINER_THREADS);
+  if (!usb_init (hexminerb, dev, found))
+    {
+      usb_uninit (hexminerb);
+      return NULL;
+    }
+  hexminerb->device_data = calloc (sizeof (struct hexminerb_info), 1);
+  if (unlikely (!(hexminerb->device_data)))
+    {
+      hexminerb->device_data = NULL;
+      usb_uninit (hexminerb);
+      return NULL;
+    }
+  if (opt_hexminerb_options != NULL)
+  	configured = (sscanf(opt_hexminerb_options, "%d:%d", &asic_count, &frequency) == 2);	
+  if (opt_hexminerb_core_voltage < HEXB_MIN_COREMV
+      || opt_hexminerb_core_voltage > HEXB_MAX_COREMV)
+    {
+      applog (LOG_ERR, "Invalid hexminerb-voltage %d must be %dmV - %dmV",
+              opt_hexminerb_core_voltage, HEXB_MIN_COREMV, HEXB_MAX_COREMV);
+      free (hexminerb->device_data);
+      hexminerb->device_data = NULL;
+      usb_uninit (hexminerb);
+      return NULL;
+    }
+  
+  info = hexminerb->device_data;
+  info->hexworks = calloc (sizeof (struct work *), HEXMINERB_ARRAY_SIZE);
+  if (unlikely (!(info->hexworks)))
+    {
+      free (hexminerb->device_data);
+      hexminerb->device_data = NULL;
+      usb_uninit (hexminerb);
+      return NULL;
+    }
+  info->wr = (struct workb_result *) malloc (sizeof (struct workb_result));
+  info->array_nonce_cache = calloc (16, sizeof (struct chip_resultsb));
+  info->readbuf = calloc (HEXB_HASH_BUF_SIZE, sizeof (unsigned char));
+  info->hash_read_pos = 0;
+  info->hash_write_pos = 0;
+  info->shut_read = false;
+  info->shut_write = false;
+  info->shut_reset = false;
+  info->wr->status = HEXB_STAT_IDLE;
+  info->miner_count = HEXB_DEFAULT_MINER_NUM;
+  info->asic_count = HEXB_DEFAULT_ASIC_NUM;
+  info->frequency = HEXB_DEFAULT_FREQUENCY;
+  info->pic_voltage_readings = HEXB_DEFAULT_CORE_VOLTAGE;
+  info->core_voltage = opt_hexminerb_core_voltage;
+  info->work_block_local = -1;
+  info->work_pool_update = -1;
+  info->reset_work = true;
+  info->jobs_to_send = 4;
+  info->roll = 0;
+  info->ht = calloc (sizeof (struct hexminerb_task), 1);
+  info->work = NULL;
+  info->write_pos = 0;
+  if (configured)
+    {
+      info->asic_count = asic_count;
+      info->frequency = frequency;
+    }
+  gettimeofday (&info->last_wr, NULL);
+  info->wr->lastnonceid = 0;
+  info->wsem_ustiming = (int64_t) (0x100000000ll / (16 * 3000 * 1.4));
+  hexminerb_init_task (info->ht, info);
+  while (i < HEXMINERB_ARRAY_SIZE)
+    {
+      info->hexworks[i] = calloc (1, sizeof (struct work));
+      info->hexworks[i]->pool = NULL;
+      i++;
+  } if (!add_cgpu (hexminerb))
+    {
+      free (info->hexworks);
+      free (hexminerb->device_data);
+      hexminerb->device_data = NULL;
+      hexminerb = usb_free_cgpu (hexminerb);
+      usb_uninit (hexminerb);
+      return NULL;
+    }
+  return hexminerb;
+}
+
+static void
+hexminerb_detect (bool __maybe_unused hotplug)
+{
+  usb_detect (&hexminerb_drv, hexminerb_detect_one);
+}
+
+static void
+do_hexminerb_close (struct thr_info *thr)
+{
+  struct cgpu_info *hexminerb = thr->cgpu;
+  struct hexminerb_info *info = hexminerb->device_data;
+  int i = 0;
+  while (i < HEXMINERB_ARRAY_SIZE)
+    {
+      free_work (info->hexworks[i]);
+      i++;
+    }
+  free (info->hexworks);
+  free (info->readbuf);
+  free (info->array_nonce_cache);
+  free (info->wr);
+  free (info->ht);
+  if (info->work)
+    free_work (info->work);
+}
+
+static void
+hexminerb_shutdown (struct thr_info *thr)
+{
+  struct cgpu_info *hexminerb = thr->cgpu;
+  do_hexminerb_close (thr);
+  usb_nodev (hexminerb);
+}
+
+static bool
+hexminerb_thread_init (struct thr_info *thr)
+{
+  struct cgpu_info *hexminerb = thr->cgpu;
+  struct hexminerb_info *info = hexminerb->device_data;
+  info->thr = thr;
+  return true;
+}
+
+static void
+get_hexminerb_statline_before (char *buf, size_t bufsiz,
+                               struct cgpu_info *hexminerb)
+{
+  if (!hexminerb->device_data)
+    return;
+  struct hexminerb_info *info = hexminerb->device_data;
+  tailsprintf (buf, bufsiz, "%3d %4d/%4dmV", info->frequency,
+               info->core_voltage, info->pic_voltage_readings);
+}
+
+extern void suffix_string (uint64_t val, char *buf, size_t bufsiz,
+                           int sigdigits);
+
+static struct api_data *
+hexminerb_api_stats (struct cgpu_info *cgpu)
+{
+  struct api_data *root = NULL;
+  struct timeval now;
+  struct hexminerb_info *info = cgpu->device_data;
+  char displayed_hashes[16], displayed_rolling[16];
+  double dev_runtime, hwp;
+  uint64_t dh64, dr64;
+  int i;
+  if (!info)
+    return NULL;
+  hwp =
+    (cgpu->hw_errors +
+     cgpu->diff1) ? (double) (cgpu->hw_errors) / (double) (cgpu->hw_errors +
+                                                           cgpu->diff1) : 0;
+  if (cgpu->dev_start_tv.tv_sec == 0)
+    dev_runtime = total_secs;
+  else
+    {
+      cgtime (&now);
+      dev_runtime = tdiff (&now, &(cgpu->dev_start_tv));
+    }
+  if (dev_runtime < 1.0)
+    dev_runtime = 1.0;
+  dh64 = (double) cgpu->total_mhashes / dev_runtime * 1000000ull;
+  dr64 = (double) cgpu->rolling * 1000000ull;
+  suffix_string (dh64, displayed_hashes, sizeof (displayed_hashes), 4);
+  suffix_string (dr64, displayed_rolling, sizeof (displayed_rolling), 4);
+  root = api_add_string (root, "MHS 5s", displayed_rolling, true);
+  root = api_add_string (root, "MHS av", displayed_hashes, true);
+  root = api_add_int (root, "Hardware Errors", &(cgpu->hw_errors), true);
+  root = api_add_percent (root, "Hardware Errors%", &hwp, true);
+  root = api_add_int (root, "USB Read Errors", &(info->usb_r_errors), true);
+  root = api_add_int (root, "USB Write Errors", &(info->usb_w_errors), true);
+  root =
+    api_add_int (root, "USB Reset Count", &(info->usb_reset_count), true);
+  root =
+    api_add_time (root, "Last Share Time", &(cgpu->last_share_pool_time),
+                  true);
+  root = api_add_int (root, "Chip Count", &(info->asic_count), true);
+  root = api_add_int (root, "Frequency", &(info->frequency), true);
+  root = api_add_int (root, "Core Voltage", &(info->core_voltage), true);
+  root =
+    api_add_int (root, "PIC Voltage Readings", &(info->pic_voltage_readings),
+                 true);
+  for (i = 0; i < info->asic_count; i++)
+    {
+      char mcw[24];
+      sprintf (mcw, "Chip%d Nonces", i + 1);
+      root = api_add_int (root, mcw, &(info->matching_work[i]), true);
+      sprintf (mcw, "Chip%d Dupes", i + 1);
+      root = api_add_int (root, mcw, &(info->dupe[i]), true);
+    }
+  return root;
+}
+
+struct device_drv hexminerb_drv = {
+  .drv_id = DRIVER_hexminerb,
+  .dname = "hexminerb",
+  .name = "HEXb",
+  .thread_init = hexminerb_thread_init,
+  .drv_detect = hexminerb_detect,
+  .hash_work = hash_driver_work,
+  .scanwork = hexminerb_scanhash,
+  .get_api_stats = hexminerb_api_stats,
+  .get_statline_before = get_hexminerb_statline_before,
+  .thread_shutdown = hexminerb_shutdown,
+};
--- cg_o/driver-hexminerb.h	1970-01-01 02:00:00.000000000 +0200
+++ cgminer_hex/driver-hexminerb.h	2014-09-22 19:28:38.671387123 +0300
@@ -0,0 +1,133 @@
+/*$T indentinput.h GC 1.140 10/16/13 10:20:01 */
+#ifndef HEXB_H
+#define HEXB_H
+#ifdef USE_HEXMINERB
+#include "util.h"
+
+/* hexminerb_task/work_reply status Definitions: */
+#define HEXB_STAT_IDLE 0        /* Idle or data already Sent to the buffer */
+#define HEXB_STAT_NEW_WORK 6    /* Request for write in the buffer */
+#define HEXB_STAT_WAITING 2     /* Wait For Buffer Empty Position */
+#define HEXB_STAT_CLR_BUFF 3    /* Force Buffer Empty */
+#define HEXB_STAT_STOP_REQ 4    /* Stop Request */
+#define HEXB_STAT_NEW_WORK_CLEAR_OLD 5  /* Clear Buffers and after that fill the first buffer */
+#define HEXB_STAT_UNUSED 7
+
+/* libhexb_eatHashData/BUF_reply status Definitions: */
+#define HEXB_BUF_DATA 0
+#define HEXB_BUF_ERR 1
+#define HEXB_BUF_SKIP 2
+
+ /*MISC*/
+#define HEXMINERB_ARRAY_PIC_SIZE 64
+#define HEXMINERB_ARRAY_SIZE HEXMINERB_ARRAY_PIC_SIZE * 4
+#define HEXMINERB_ARRAY_SIZE_REAL HEXMINERB_ARRAY_SIZE - 2
+#define HEXB_NONCE_CASH_SIZE 16
+#define HEXB_USB_R_SIZE 64
+#define HEXB_USB_WR_SIZE 64
+#define HEXB_HASH_BUF_SIZE 768
+#define HEXB_HASH_BUF_SIZE_OK HEXB_HASH_BUF_SIZE - 4
+#define HEXB_USB_R_BAD_ID 32
+#define HEXB_USB_WR_TIME_OUT 500
+#define HEXMINERB_BULK_READ_TIMEOUT 1000
+#define HEXB_MINER_THREADS 1
+#define HEXB_DEFAULT_MINER_NUM 0x01
+#define HEXB_DEFAULT_ASIC_NUM 0x10
+#define HEXB_MIN_FREQUENCY 0    //Bits / 10
+#define HEXB_MAX_FREQUENCY 610  //Bits / 10
+#define HEXB_DEFAULT_FREQUENCY 540      //Bits / 10 - That is Max which works 40 GHs for 16 chips
+#define HEXB_DEFAULT_CORE_VOLTAGE 840   /* in millivolts */
+#define HEXB_MIN_COREMV 700     /* in millivolts */
+#define HEXB_MAX_COREMV 1101    /* in millivolts */
+
+struct chip_resultsb
+{
+  uint8_t nonce_cache_write_pos;
+  uint32_t nonces[HEXB_NONCE_CASH_SIZE];
+};
+struct workb_result
+{
+  uint8_t startbyte;
+  uint8_t datalength;
+  uint8_t command;
+  uint16_t address;
+  uint32_t lastnonce;
+  uint8_t lastnonceid;
+  uint8_t status;
+  uint16_t lastvoltage;
+  uint8_t lastchippos;
+  uint8_t prevnonceid;
+  uint8_t csum;
+} __attribute__ ((packed, aligned (4)));
+struct hexminerb_task
+{
+  uint8_t startbyte;
+  uint8_t datalength;
+  uint8_t command;
+  uint16_t address;
+  uint32_t merkle[3];
+  uint32_t a1;
+  uint32_t a0;
+  uint32_t e2;
+  uint32_t e1;
+  uint32_t e0;
+  uint8_t midstate[32];
+  uint32_t a2;
+  uint32_t startnonce;
+  uint8_t id;
+  uint8_t status;
+  uint16_t hashclock;
+  uint16_t chipcount;
+  uint16_t refvoltage;
+  uint16_t reftemperature;
+  uint16_t reffanrpm;
+  uint8_t csum;
+  uint8_t pad[2];
+} __attribute__ ((packed, aligned (4)));
+struct hexminerb_info
+{
+  struct timeval last_wr;
+  int jobs_to_send;
+  int64_t wsem_ustiming;
+  bool reset_work;
+  int roll;
+  int usb_bad_reads;
+  struct work *work;
+  unsigned int work_block_local;
+  unsigned int work_pool_update;
+  int write_pos;
+  struct hexminerb_task *ht;
+  int miner_count;
+  int asic_count;
+  int core_voltage;
+  int frequency;
+  int usb_r_errors;
+  int usb_w_errors;
+  int usb_reset_count;
+  bool shut_read;
+  bool shut_write;
+  bool shut_reset;
+  int pic_voltage_readings;
+  int hash_read_pos;
+  int hash_write_pos;
+  int dupe[HEXB_DEFAULT_ASIC_NUM];
+  int matching_work[HEXB_DEFAULT_ASIC_NUM];
+  unsigned char *readbuf;
+  struct workb_result *wr;
+  struct chip_resultsb *array_nonce_cache;
+  struct thr_info *thr;
+  struct work **hexworks;
+};
+
+#define HEXB_WORKANSWER_ADR 0x3000
+#define HEXB_WORKQUEUE_ADR 0x4008
+#define HEXB_PTCON_ADR 0x0C00
+#define HEXB_START_STOP_ADR 0x646E
+#define HEXMINERB_TASK_SIZE (sizeof(struct hexminerb_task) - 2)
+#define HEXB_MAX_WORK_SIZE (sizeof(struct workb_result))
+#define HEXB_BASE_WORK_SIZE 6
+extern int opt_hexminerb_core_voltage;
+extern struct hexminerb_info **hexminerb_info;
+
+#endif /* USE_HEXMINERB */
+#endif /* HEXB_H */
--- cg_o/libhexb.c	1970-01-01 02:00:00.000000000 +0200
+++ cgminer_hex/libhexb.c	2014-09-22 19:28:38.671387123 +0300
@@ -0,0 +1,291 @@
+/*$T indentinput.c GC 1.140 10/16/13 10:20:34 */
+const uint32_t SHA_M[64] = { 0x428a2f98, 0x71374491, 0xb5c0fbcf };
+
+#define Ch(x, y, z) ((x & (y ^ z)) ^ z)
+#define Maj(x, y, z) ((x & (y | z)) | (y & z))
+#define ROTR(x, n) ((x >> n) | (x << (32 - n)))
+#define S0(x) (ROTR(x, 2) ^ ROTR(x, 13) ^ ROTR(x, 22))
+#define S1(x) (ROTR(x, 6) ^ ROTR(x, 11) ^ ROTR(x, 25))
+#define BT_OFFSETS_B 6
+//static const uint32_t bf_offsetsu[] = {-0x800000, 0, 0xffc00000, 0xff800000, 0x02800000, 0x02C00000, 0x00400000};
+const uint32_t bf_offsetsb[] =
+  { -0x800000, 0, -0x400000, 0x2800000, 0x2C00000, 0x400000 };
+
+static void
+BITFURY_MS3compute (struct work *work, struct hexminerb_task *ht)
+{
+  uint32_t state[8];
+  uint32_t data[3];
+  memcpy (&state, work->midstate, 32);
+  memcpy (&data, work->data + 64, 12);
+  uint32_t a, b, c, d, e, f, g, h, ne, na;
+  int i;
+#if defined(__BIG_ENDIAN__) || defined(MIPSEB)
+  for (i = 0; i < 8; i++)
+    state[i] = htole32 (state[i]);
+  for (i = 0; i < 3; i++)
+    data[i] = htole32 (data[i]);
+
+#endif
+  a = state[0];
+  b = state[1];
+  c = state[2];
+  d = state[3];
+  e = state[4];
+  f = state[5];
+  g = state[6];
+  h = state[7];
+  for (i = 0; i < 3; i++)
+    {
+      ne = data[i] + SHA_M[i] + h + Ch (e, f, g) + S1 (e) + d;
+      na =
+        data[i] + SHA_M[i] + h + Ch (e, f, g) + S1 (e) + S0 (a) + Maj (a, b,
+                                                                       c);
+      d = c;
+      c = b;
+      b = a;
+      a = na;
+      h = g;
+      g = f;
+      f = e;
+      e = ne;
+    }
+#if defined(__BIG_ENDIAN__) || defined(MIPSEB)
+  a = htole32 (a);
+  b = htole32 (b);
+  c = htole32 (c);
+  d = htole32 (d);
+  e = htole32 (e);
+  f = htole32 (f);
+  g = htole32 (g);
+  h = htole32 (h);
+#endif
+  memcpy (&ht->a1, &h, 4);
+  memcpy (&ht->a0, &g, 4);
+  memcpy (&ht->e2, &f, 4);
+  memcpy (&ht->e1, &e, 4);
+  memcpy (&ht->e0, &d, 4);
+  memcpy (&ht->a2, &c, 4);
+  memcpy (&ht->startnonce, &b, 4);
+  memcpy (&ht->reftemperature, &a, 4);
+}
+
+static int64_t
+timediff (const struct timeval *a, const struct timeval *b)
+{
+  struct timeval diff;
+  timersub (a, b, &diff);
+  return diff.tv_sec * 1000000 + diff.tv_usec;
+}
+
+static bool
+libhexb_cachenonce (struct chip_resultsb *nonce_cache, uint32_t nonce)
+{
+  int i = 0;
+  while (i < HEXB_NONCE_CASH_SIZE && nonce_cache->nonces[i] != nonce)
+    i++;
+  if (i < HEXB_NONCE_CASH_SIZE)
+    return false;
+  if (nonce_cache->nonce_cache_write_pos == HEXB_NONCE_CASH_SIZE)
+    nonce_cache->nonce_cache_write_pos = 0;
+  nonce_cache->nonces[nonce_cache->nonce_cache_write_pos++] = nonce;
+  return true;
+}
+
+static void
+libhexb_csum (unsigned char *startptr, unsigned char *endptr,
+              unsigned char *resptr)
+{
+  unsigned char *b = startptr;
+  uint8_t sum = 0;
+  while (b < endptr)
+    sum += *b++;
+  memcpy (resptr, &sum, 1);
+}
+
+static bool
+libhexb_usb_dead (struct cgpu_info *hexminerb)
+{
+  struct cg_usb_device *usbdev;
+  struct hexminerb_info *info = hexminerb->device_data;
+  if (!info)
+    return true;
+  usbdev = hexminerb->usbdev;
+  bool ret = (usbdev == NULL || usbdev->handle == NULL || hexminerb->shutdown
+              || info->shut_read || info->shut_write || info->shut_reset
+              || hexminerb->usbinfo.nodev || hexminerb->deven != DEV_ENABLED);
+  return ret;
+}
+
+static int
+libhexb_sendHashData (struct cgpu_info *hexminerb, unsigned char *sendbuf,
+                      size_t buf_len)
+{
+  struct hexminerb_info *info = hexminerb->device_data;
+  struct cg_usb_device *usbdev;
+  int wrote = 0, written = 0;
+  int err = LIBUSB_SUCCESS;
+  usbdev = hexminerb->usbdev;
+  if (libhexb_usb_dead (hexminerb))
+    goto out;
+  while (written < buf_len && err == LIBUSB_SUCCESS)
+    {
+      err =
+        libusb_bulk_transfer (usbdev->handle, 0x02, sendbuf + written,
+                              MIN (HEXB_USB_WR_SIZE, buf_len - written),
+                              &wrote, HEXB_USB_WR_TIME_OUT);
+      if (err == LIBUSB_SUCCESS)
+        written += wrote;
+    }
+out:
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+    info->shut_write = true;
+  return written;
+}
+
+static void
+libhexb_reset (struct cgpu_info *hexminerb)
+{
+  struct hexminerb_info *info = hexminerb->device_data;
+  struct cg_usb_device *usbdev;
+  int err = LIBUSB_SUCCESS;
+  usbdev = hexminerb->usbdev;
+  if (libhexb_usb_dead (hexminerb))
+    goto out;
+  err = libusb_reset_device (usbdev->handle);
+out:
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+    info->shut_reset = true;
+  info->usb_reset_count++;
+}
+
+static int
+libhexb_readHashData (struct cgpu_info *hexminerb, unsigned char *hash,
+                      int *hash_write_pos, int timeout)
+{
+  struct hexminerb_info *info = hexminerb->device_data;
+  struct cg_usb_device *usbdev;
+  int read = 0;
+  int err = LIBUSB_SUCCESS;
+  usbdev = hexminerb->usbdev;
+  if (libhexb_usb_dead (hexminerb))
+    goto out;
+  err =
+    libusb_bulk_transfer (usbdev->handle, 0x82, hash + *hash_write_pos,
+                          HEXB_USB_R_SIZE, &read, timeout);
+  if (err == LIBUSB_SUCCESS)
+    *hash_write_pos += MIN (read, HEXB_USB_R_SIZE);
+out:
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+    info->shut_read = true;
+  return err;
+}
+
+static uint32_t
+decnonce (uint32_t in)
+{
+  uint32_t out;
+  /* First part load */
+  out = (in & 0xFF) << 24;
+  in >>= 8;
+  /* Byte reversal */
+  in = (((in & 0xaaaaaaaa) >> 1) | ((in & 0x55555555) << 1));
+  in = (((in & 0xcccccccc) >> 2) | ((in & 0x33333333) << 2));
+  in = (((in & 0xf0f0f0f0) >> 4) | ((in & 0x0f0f0f0f) << 4));
+  out |= (in >> 2) & 0x3FFFFF;
+  /* Extraction */
+  if (in & 1)
+    out |= (1 << 23);
+  if (in & 2)
+    out |= (1 << 22);
+  out -= 0x800004;
+  return out;
+}
+
+static int
+bitfury_checkresults (struct thr_info *thr, struct work *work, uint32_t nonce)
+{
+  int i;
+  for (i = 0; i < BT_OFFSETS_B; i++)
+    {
+      if (test_nonce (work, nonce + bf_offsetsb[i]))
+        {
+          submit_tested_work_fast_clone (thr, work, true);
+          return 1;
+        }
+    }
+  return 0;
+}
+
+static int
+hexminerb_predecode_nonce (struct cgpu_info *hexminerb, struct thr_info *thr,
+                           uint32_t nonce, uint8_t work_id)
+{
+  struct hexminerb_info *info = hexminerb->device_data;
+  if (info->hexworks[work_id]->pool == NULL)
+    return 0;
+  return bitfury_checkresults (thr, info->hexworks[work_id], nonce);
+}
+
+static void
+libhexb_getvoltage (uint16_t wr_bukvoltage, int *info_pic_voltage_readings)
+{
+  float voltagehuman;
+  voltagehuman =
+    (float) ((float) wr_bukvoltage * (float) 1000 * (float) 3.3 /
+             ((1 << 12) - 1));
+  *info_pic_voltage_readings = (int) voltagehuman;
+}
+
+static void
+libhexb_setvoltage (int info_voltage, uint16_t * refvoltage)
+{
+  uint16_t voltageadc;
+  voltageadc =
+    (uint16_t) ((float) info_voltage / (float) 1000 / (float) 3.3 *
+                ((1 << 12) - 1));
+  *refvoltage = htole16 (voltageadc);
+}
+
+static int
+libhexb_eatHashData (struct workb_result *wr, unsigned char *hash,
+                     int *hash_read_pos, int *hash_write_pos)
+{
+  uint8_t psum;
+  int wrpos;
+  unsigned char *csum_pos;
+  bool ok;
+  int places = 0;
+eat:
+  while (*hash_read_pos < *hash_write_pos && hash[*hash_read_pos] != 0x53)
+    *hash_read_pos += 1;
+  places = *hash_write_pos - *hash_read_pos;
+  if (places < 8)
+    return HEXB_BUF_SKIP;
+  memcpy ((char *) &wr->startbyte, &hash[*hash_read_pos],
+          HEXB_BASE_WORK_SIZE - 1);
+  wr->address = htole16 (wr->address);
+  ok = (wr->command == 0x52)
+    && ((wr->address == HEXB_WORKANSWER_ADR && wr->datalength == 0x05));
+  if (!ok)
+    {
+      *hash_read_pos += 1;
+      goto eat;
+    }
+  if (places < HEXB_BASE_WORK_SIZE + wr->datalength * 2)
+    return HEXB_BUF_SKIP;
+  csum_pos =
+    hash + *hash_read_pos + HEXB_BASE_WORK_SIZE + wr->datalength * 2 - 1;
+  libhexb_csum (hash + *hash_read_pos, csum_pos, &psum);
+  if (psum != *csum_pos)
+    {
+      *hash_read_pos += 1;
+      return HEXB_BUF_ERR;
+    }
+  wrpos = (wr->address - HEXB_WORKANSWER_ADR) + HEXB_BASE_WORK_SIZE - 1;
+  memcpy ((char *) &wr->startbyte + wrpos,
+          &hash[*hash_read_pos + HEXB_BASE_WORK_SIZE - 1],
+          wr->datalength * 2);
+  *hash_read_pos += HEXB_BASE_WORK_SIZE + wr->datalength * 2;
+  return HEXB_BUF_DATA;
+}
--- cg_o/Makefile.am	2014-09-22 14:22:33.000835508 +0300
+++ cgminer_hex/Makefile.am	2014-09-22 19:28:38.671387123 +0300
@@ -55,9 +55,9 @@
 cgminer_SOURCES += usbutils.c usbutils.h
 endif
 
-if WANT_LIBBITFURY
-cgminer_SOURCES += libbitfury.c libbitfury.h mcp2210.c mcp2210.h
-endif
+#if WANT_LIBBITFURY
+#cgminer_SOURCES += libbitfury.c libbitfury.h mcp2210.c mcp2210.h
+#endif
 
 if WANT_CRC16
 cgminer_SOURCES += crc16.c crc.h
@@ -150,6 +150,42 @@
 cgminer_SOURCES += driver-bitmain.c driver-bitmain.h
 endif
 
+if HAS_HEXMINERA
+cgminer_SOURCES += driver-hexminera.c driver-hexminera.h
+endif
+
+if HAS_HEXMINERB
+cgminer_SOURCES += driver-hexminerb.c driver-hexminerb.h
+endif
+
+if HAS_HEXMINERC
+cgminer_SOURCES += driver-hexminerc.c driver-hexminerc.h
+endif
+
+if HAS_HEXMINER8
+cgminer_SOURCES += driver-hexminer8.c driver-hexminer8.h
+endif
+
+if HAS_HEXMINERM
+cgminer_SOURCES += driver-hexminerm.c driver-hexminerm.h
+endif
+
+if HAS_HEXMINERR
+cgminer_SOURCES += driver-hexminerr.c driver-hexminerr.h
+endif
+
+if HAS_HEXMINERBE200
+cgminer_SOURCES += driver-hexminerbe200.c driver-hexminerbe200.h
+endif
+
+if HAS_HEXMINER3
+cgminer_SOURCES += driver-hexminer3.c driver-hexminer3.h
+endif
+
+if HAS_HEXMINERU
+cgminer_SOURCES += driver-hexmineru.c driver-hexmineru.h
+endif
+
 if HAS_MODMINER
 cgminer_SOURCES += driver-modminer.c
 bitstreamsdir = $(bindir)/bitstreams
--- cg_o/miner.h	2014-09-22 14:22:33.048838208 +0300
+++ cgminer_hex/miner.h	2014-09-22 19:28:38.671387123 +0300
@@ -229,6 +229,15 @@
 	DRIVER_ADD_COMMAND(modminer)
 
 #define ASIC_PARSE_COMMANDS(DRIVER_ADD_COMMAND) \
+	DRIVER_ADD_COMMAND(hexminera) \
+	DRIVER_ADD_COMMAND(hexminerb) \
+	DRIVER_ADD_COMMAND(hexminerc) \
+	DRIVER_ADD_COMMAND(hexminer8) \
+	DRIVER_ADD_COMMAND(hexminerm) \
+	DRIVER_ADD_COMMAND(hexminerr) \
+	DRIVER_ADD_COMMAND(hexminerbe200) \
+	DRIVER_ADD_COMMAND(hexminer3) \
+	DRIVER_ADD_COMMAND(hexmineru) \
 	DRIVER_ADD_COMMAND(ants1) \
 	DRIVER_ADD_COMMAND(ants2) \
 	DRIVER_ADD_COMMAND(avalon) \
@@ -280,6 +289,20 @@
 	POOL_LOADBALANCE,
 	POOL_BALANCE,
 };
+#if defined(USE_HEXMINERA) || defined(USE_HEXMINERB) || defined(USE_HEXMINERC) || defined(USE_HEXMINERU) || defined(USE_HEXMINER8) || defined(USE_HEXMINERM) || defined(USE_HEXMINERR) || defined(USE_HEXMINERBE200) || defined(USE_HEXMINER3)
+
+enum default_hex_miner {
+	D_HEXA,
+	D_HEXB,
+	D_HEXC,
+	D_HEX8,
+	D_HEX3,
+	D_HEXM,
+	D_HEXR,
+	D_HEXBE200,
+};
+extern enum default_hex_miner default_hex_miner;
+#endif
 
 #define TOP_STRATEGY (POOL_BALANCE)
 
@@ -432,6 +455,12 @@
 	struct cg_usb_info usbinfo;
 	bool blacklisted;
 #endif
+#ifdef USE_HEXMINERU
+	// http://ww1.microchip.com/downloads/en/DeviceDoc/22288A.pdf pg 34
+	uint8_t cfg_spi[0x11];
+	// http://ww1.microchip.com/downloads/en/DeviceDoc/22288A.pdf pg 40
+	uint8_t cfg_gpio[0xf];
+#endif
 #if defined(USE_AVALON) || defined(USE_AVALON2)
 	struct work **works;
 	int work_array;
@@ -702,7 +731,9 @@
  * So, e.g. use it to track down a deadlock - after a reproducable deadlock occurs
  * ... Of course if the API code itself deadlocks, it wont help :)
  */
+//Always off production 
 #define LOCK_TRACKING 0
+//Always off production
 
 #if LOCK_TRACKING
 enum cglock_typ {
@@ -960,6 +991,7 @@
 #define API_MCAST_ADDR "224.0.0.75"
 
 extern bool opt_work_update;
+extern unsigned int work_pool_update;
 extern bool opt_protocol;
 extern bool have_longpoll;
 extern char *opt_kernel_path;
@@ -1039,6 +1071,31 @@
 extern int opt_minion_spiusec;
 extern char *opt_minion_temp;
 #endif
+
+#ifdef USE_HEXMINERA
+extern char *opt_hexminera_options;
+#endif
+#ifdef USE_HEXMINERB
+extern char *opt_hexminerb_options;
+#endif
+#ifdef USE_HEXMINERC
+extern char *opt_hexminerc_options;
+#endif
+#ifdef USE_HEXMINER8
+extern char *opt_hexminer8_options;
+#endif
+#ifdef USE_HEXMINERM
+extern char *opt_hexminerm_options;
+#endif
+#ifdef USE_HEXMINERR
+extern char *opt_hexminerr_options;
+#endif
+#ifdef USE_HEXMINERBE200
+extern char *opt_hexminerbe200_options;
+#endif
+#ifdef USE_HEXMINER3
+extern char *opt_hexminer3_options;
+#endif
 #ifdef USE_USBUTILS
 extern char *opt_usb_select;
 extern int opt_usbdump;
@@ -1393,6 +1450,10 @@
 	struct timeval	tv_work_start;
 	struct timeval	tv_work_found;
 	char		getwork_mode;
+	
+#if defined(USE_HEXMINERA) || defined(USE_HEXMINERB) || defined(USE_HEXMINERC) || defined(USE_HEXMINERU) || defined(USE_HEXMINER8) || defined(USE_HEXMINERM) || defined(USE_HEXMINERR) || defined(USE_HEXMINERBE200) || defined(USE_HEXMINER3)
+	bool ping;
+#endif
 };
 
 #ifdef USE_MODMINER
@@ -1440,6 +1501,9 @@
 extern bool test_nonce(struct work *work, uint32_t nonce);
 extern bool test_nonce_diff(struct work *work, uint32_t nonce, double diff);
 extern bool submit_tested_work(struct thr_info *thr, struct work *work);
+#if defined(USE_HEXMINERA) || defined(USE_HEXMINERB) || defined(USE_HEXMINERC) || defined(USE_HEXMINERU)  || defined(USE_HEXMINER8) || defined(USE_HEXMINERM) || defined(USE_HEXMINERR) || defined(USE_HEXMINERBE200) || defined(USE_HEXMINER3)
+extern bool submit_tested_work_no_clone(struct thr_info *thr, struct work *work, bool diff1);
+#endif
 extern bool submit_nonce(struct thr_info *thr, struct work *work, uint32_t nonce);
 extern bool submit_noffset_nonce(struct thr_info *thr, struct work *work, uint32_t nonce,
 			  int noffset);
--- cg_o/usbutils.c	2014-09-22 14:22:33.052838431 +0300
+++ cgminer_hex/usbutils.c	2014-09-22 19:28:38.675387491 +0300
@@ -286,6 +286,91 @@
 };
 #endif
 
+#ifdef USE_HEXMINERA
+static struct usb_epinfo hexa_epinfos[] = {
+	{ LIBUSB_TRANSFER_TYPE_BULK,	64,	EPI(2), 0, 0 },
+	{ LIBUSB_TRANSFER_TYPE_BULK,	64,	EPO(2), 0, 0 }
+};
+static struct usb_intinfo hexa_ints[] = {
+	USB_EPS(1, hexa_epinfos)
+};
+#endif
+#ifdef USE_HEXMINERB
+static struct usb_epinfo hexb_epinfos[] = {
+	{ LIBUSB_TRANSFER_TYPE_BULK,	64,	EPI(2), 0, 0 },
+	{ LIBUSB_TRANSFER_TYPE_BULK,	64,	EPO(2), 0, 0 }
+};
+static struct usb_intinfo hexb_ints[] = {
+	USB_EPS(1, hexb_epinfos)
+};
+#endif
+#ifdef USE_HEXMINER8
+static struct usb_epinfo hex8_epinfos[] = {
+	{ LIBUSB_TRANSFER_TYPE_BULK,	64,	EPI(2), 0, 0 },
+	{ LIBUSB_TRANSFER_TYPE_BULK,	64,	EPO(2), 0, 0 }
+};
+static struct usb_intinfo hex8_ints[] = {
+	USB_EPS(1, hex8_epinfos)
+};
+#endif
+
+#ifdef USE_HEXMINERM
+static struct usb_epinfo hexm_epinfos[] = {
+	{ LIBUSB_TRANSFER_TYPE_BULK,	64,	EPI(2), 0, 0 },
+	{ LIBUSB_TRANSFER_TYPE_BULK,	64,	EPO(2), 0, 0 }
+};
+static struct usb_intinfo hexm_ints[] = {
+	USB_EPS(1, hexm_epinfos)
+};
+#endif
+
+#ifdef USE_HEXMINERR
+static struct usb_epinfo hexr_epinfos[] = {
+	{ LIBUSB_TRANSFER_TYPE_BULK,	64,	EPI(2), 0, 0 },
+	{ LIBUSB_TRANSFER_TYPE_BULK,	64,	EPO(2), 0, 0 }
+};
+static struct usb_intinfo hexr_ints[] = {
+	USB_EPS(1, hexr_epinfos)
+};
+#endif
+
+#ifdef USE_HEXMINERBE200
+static struct usb_epinfo hexbe200_epinfos[] = {
+	{ LIBUSB_TRANSFER_TYPE_BULK,	64,	EPI(2), 0, 0 },
+	{ LIBUSB_TRANSFER_TYPE_BULK,	64,	EPO(2), 0, 0 }
+};
+static struct usb_intinfo hexbe200_ints[] = {
+	USB_EPS(1, hexbe200_epinfos)
+};
+#endif
+
+#ifdef USE_HEXMINER3
+static struct usb_epinfo hex3_epinfos[] = {
+	{ LIBUSB_TRANSFER_TYPE_BULK,	64,	EPI(2), 0, 0 },
+	{ LIBUSB_TRANSFER_TYPE_BULK,	64,	EPO(2), 0, 0 }
+};
+static struct usb_intinfo hex3_ints[] = {
+	USB_EPS(1, hex3_epinfos)
+};
+#endif
+#ifdef USE_HEXMINERC
+static struct usb_epinfo hexc_epinfos[] = {
+	{ LIBUSB_TRANSFER_TYPE_BULK,	64,	EPI(2), 0, 0 },
+	{ LIBUSB_TRANSFER_TYPE_BULK,	64,	EPO(2), 0, 0 }
+};
+static struct usb_intinfo hexc_ints[] = {
+	USB_EPS(1, hexc_epinfos)
+};
+#endif
+#ifdef USE_HEXMINERU
+static struct usb_epinfo hexu_epinfos[] = {
+	{ LIBUSB_TRANSFER_TYPE_INTERRUPT,	64,	EPI(1), 0, 0 },
+	{ LIBUSB_TRANSFER_TYPE_INTERRUPT,	64,	EPO(1), 0, 0 }
+};
+static struct usb_intinfo hexu_ints[] = {
+	USB_EPS(0, hexu_epinfos)
+};
+#endif
 #ifdef USE_ICARUS
 static struct usb_epinfo ica_epinfos[] = {
 	{ LIBUSB_TRANSFER_TYPE_BULK,	64,	EPI(3), 0, 0 },
@@ -535,6 +620,7 @@
 		.latency = LATENCY_UNUSED,
 		INTINFO(mmq_ints) },
 #endif
+
 #ifdef USE_AVALON
 	{
 		.drv = DRIVER_avalon,
@@ -631,6 +717,136 @@
 		.latency = 10,
 		INTINFO(kli_ints) },
 #endif
+#ifdef USE_HEXMINERB //04d8:000a or //04d8:000b
+	{
+		.drv = DRIVER_hexminerb,
+		.name = "HEXb",
+		.ident = IDENT_HEXB,
+		.idVendor = 0x04D8,
+		.idProduct = 0x000B,
+		.iProduct = "HEX16B-Bitfury ASIC Miner",
+		.config = 1,
+		.timeout = 100,
+		.latency = LATENCY_UNUSED,
+		 INTINFO(hexb_ints) },
+	{	 
+		.drv = DRIVER_hexminerb,
+		.name = "HEXb",
+		.ident = IDENT_HEXB,
+		.idVendor = 0x04D8,
+		.idProduct = 0x000A,
+		.iProduct = "HEX16B-Bitfury ASIC Miner",
+		.config = 1,
+		.timeout = 100,
+		.latency = LATENCY_UNUSED,
+		 INTINFO(hexb_ints) },
+#endif
+#ifdef USE_HEXMINER8 //04d8:000a 
+	{	 
+		.drv = DRIVER_hexminer8,
+		.name = "HEX8",
+		.ident = IDENT_HEX8,
+		.idVendor = 0x04D8,
+		.idProduct = 0x000A,
+		.iProduct = "HEX8A1-CoinCraft ASIC Miner",
+		.config = 1,
+		.timeout = 100,
+		.latency = LATENCY_UNUSED,
+		 INTINFO(hex8_ints) },
+#endif
+#ifdef USE_HEXMINERM //04d8:002a 
+	{	 
+		.drv = DRIVER_hexminerm,
+		.name = "HEXM",
+		.ident = IDENT_HEXM,
+		.idVendor = 0x04D8,
+		.idProduct = 0x0010,
+		.iProduct = NULL,
+		.config = 1,
+		.timeout = 100,
+		.latency = LATENCY_UNUSED,
+		 INTINFO(hexm_ints) },
+#endif
+#ifdef USE_HEXMINERR //04d8:002a 
+	{	 
+		.drv = DRIVER_hexminerr,
+		.name = "HEXR",
+		.ident = IDENT_HEXR,
+		.idVendor = 0x04D8,
+		.idProduct = 0x0014,
+		.iProduct = NULL,
+		.config = 1,
+		.timeout = 100,
+		.latency = LATENCY_UNUSED,
+		 INTINFO(hexr_ints) },
+#endif
+#ifdef USE_HEXMINERBE200 //04d8:002a 
+	{	 
+		.drv = DRIVER_hexminerbe200,
+		.name = "HEXE",
+		.ident = IDENT_HEXBE200,
+		.idVendor = 0x04D8,
+		.idProduct = 0x0013,
+		//.idProduct = 0x002A,
+		//.iProduct = "HEX8A1-CoinCraft ASIC Miner",
+		.iProduct = NULL,
+		.config = 1,
+		.timeout = 100,
+		.latency = LATENCY_UNUSED,
+		 INTINFO(hexbe200_ints) },
+#endif
+
+#ifdef USE_HEXMINER3 //04d8:000a 
+	{	 
+		.drv = DRIVER_hexminer3,
+		.name = "HEX3",
+		.ident = IDENT_HEX3,
+		.idVendor = 0x04D8,
+		.idProduct = 0x000A,
+		.iProduct = "HEX3A3-Avalon3 ASIC Miner",
+		.config = 1,
+		.timeout = 100,
+		.latency = LATENCY_UNUSED,
+		 INTINFO(hex3_ints) },
+#endif
+#ifdef USE_HEXMINERC //04d8:000a
+	{
+		.drv = DRIVER_hexminerc,
+		.name = "HEXc",
+		.ident = IDENT_HEXC,
+		.idVendor = 0x04D8,
+		.idProduct = 0x000A,
+		.iProduct = "HEX16C-Avalon2 ASIC Miner",
+		.config = 1,
+		.timeout = 100,
+		.latency = LATENCY_UNUSED,
+		 INTINFO(hexc_ints) },
+#endif
+#ifdef USE_HEXMINERU //04d8:000a
+	{
+		.drv = DRIVER_hexmineru,
+		.name = "HEXu",
+		.ident = IDENT_HEXU,
+		.idVendor = 0x04D8,
+		.idProduct = 0x00DE,
+		.config = 1,
+		.timeout = 100,
+		.latency = LATENCY_UNUSED,
+		 INTINFO(hexu_ints) },
+#endif
+#ifdef USE_HEXMINERA //04d8:000a
+	{
+		.drv = DRIVER_hexminera,
+		.name = "HEXa",
+		.ident = IDENT_HEXA,
+		.idVendor = 0x04D8,
+		.idProduct = 0x000A,
+		.iProduct = "HEX16A-Avalon1 ASIC Miner",
+		.config = 1,
+		.timeout = 100,
+		.latency = LATENCY_UNUSED,
+		 INTINFO(hexa_ints) },
+#endif 
 #ifdef USE_ICARUS
 	{
 		.drv = DRIVER_icarus,
@@ -1057,7 +1273,6 @@
 {
 	char tmp[512];
 	int err;
-
 	err = libusb_set_configuration(handle, cd);
 	if (err) {
 		snprintf(tmp, sizeof(tmp), EOL "  ** dev %d: Failed to set config descriptor to %d, err %d",
@@ -1142,6 +1357,7 @@
 	append(buf, tmp, off, len);
 
 	err = libusb_open(dev, &handle);
+	
 	if (err) {
 		snprintf(tmp, sizeof(tmp), EOL "  ** dev %d: Failed to open, err %d", (int)(*count), err);
 		append(buf, tmp, off, len);
@@ -1777,7 +1993,7 @@
 						 THISIF(cgpu->usbdev->found, ifinfo));
 		}
 #ifdef LINUX
-		libusb_attach_kernel_driver(cgpu->usbdev->handle, THISIF(cgpu->usbdev->found, ifinfo));
+		//libusb_attach_kernel_driver(cgpu->usbdev->handle, THISIF(cgpu->usbdev->found, ifinfo));
 #endif
 		cg_wlock(&cgusb_fd_lock);
 		libusb_close(cgpu->usbdev->handle);
@@ -1924,7 +2140,6 @@
 
 	if (unlikely(!cgpu))
 		quit(1, "Failed to calloc cgpu for %s in usb_alloc_cgpu", drv->dname);
-
 	cgpu->drv = drv;
 	cgpu->deven = DEV_ENABLED;
 	cgpu->threads = threads;
@@ -1958,13 +2173,13 @@
 	struct libusb_config_descriptor *config = NULL;
 	const struct libusb_interface_descriptor *idesc;
 	const struct libusb_endpoint_descriptor *epdesc;
-	unsigned char strbuf[STRBUFLEN+1];
+	//unsigned char strbuf[STRBUFLEN+1];
 	char devpath[32];
 	char devstr[STRBUFLEN+1];
 	int err, ifinfo, epinfo, alt, epnum, pstate;
 	int bad = USB_INIT_FAIL;
 	int cfg, claimed = 0;
-
+  
 	DEVWLOCK(cgpu, pstate);
 
 	cgpu->usbinfo.bus_number = libusb_get_bus_number(dev);
@@ -1999,13 +2214,7 @@
 	if (unlikely(!cgusb->descriptor))
 		quit(1, "USB failed to calloc _usb_init cgusb descriptor");
 
-	err = libusb_get_device_descriptor(dev, cgusb->descriptor);
-	if (err) {
-		applog(LOG_DEBUG,
-			"USB init failed to get descriptor, err %d %s",
-			err, devstr);
-		goto dame;
-	}
+
 
 	cg_wlock(&cgusb_fd_lock);
 	err = libusb_open(dev, &(cgusb->handle));
@@ -2035,6 +2244,14 @@
 		}
 		goto dame;
 	}
+	
+	err = libusb_get_device_descriptor(dev, cgusb->descriptor);
+	if (err) {
+		applog(LOG_ERR,
+			"USB init failed to get descriptor, err %d %s",
+			err, devstr);
+		goto nokernel;
+	}
 
 #ifdef LINUX
 	for (ifinfo = 0; ifinfo < found->intinfo_count; ifinfo++) {
@@ -2057,7 +2274,8 @@
 	}
 #endif
 
-	if (found->iManufacturer) {
+	if (found->iManufacturer)
+	 {
 		unsigned char man[STRBUFLEN+1];
 
 		err = libusb_get_string_descriptor_ascii(cgusb->handle,
@@ -2079,17 +2297,45 @@
 	}
 
 	if (found->iProduct) {
-		unsigned char prod[STRBUFLEN+1];
-
-		err = libusb_get_string_descriptor_ascii(cgusb->handle,
+		unsigned char prod[STRBUFLEN+1] = {0};
+   err = -9;
+		if(cgusb->descriptor->iProduct) 
+				err = libusb_get_string_descriptor_ascii(cgusb->handle,
 							 cgusb->descriptor->iProduct,
-							 prod, STRBUFLEN);
+							 (unsigned char *)prod, 127);
 		if (err < 0) {
+		
+			#if defined(USE_HEXMINERA) || defined(USE_HEXMINERB) || defined(USE_HEXMINERC) || defined(USE_HEXMINER8) || defined(USE_HEXMINER3) || defined(USE_HEXMINERM) || defined(USE_HEXMINERR) || defined(USE_HEXMINERBE200)
+			#if defined(USE_HEXMINERA)
+			if(found->ident == IDENT_HEXA && default_hex_miner == D_HEXA)
+				snprintf((char *)prod, sizeof(prod), "HEX16A-Avalon1 ASIC Miner");
+			#endif
+			#if defined(USE_HEXMINERB)
+			if(found->ident == IDENT_HEXB && default_hex_miner == D_HEXB)
+				snprintf((char *)prod, sizeof(prod), "HEX16B-Bitfury ASIC Miner");
+			#endif
+		  #if defined(USE_HEXMINERC)
+			if(found->ident == IDENT_HEXC && default_hex_miner == D_HEXC)
+				snprintf((char *)prod, sizeof(prod), "HEX16C-Avalon2 ASIC Miner");
+			#endif
+      #if defined(USE_HEXMINER8)
+			if(found->ident == IDENT_HEX8 && default_hex_miner == D_HEX8)
+				snprintf((char *)prod, sizeof(prod), "HEX8A1-CoinCraft ASIC Miner");
+			#endif
+			#if defined(USE_HEXMINER3)
+			if(found->ident == IDENT_HEX3 && default_hex_miner == D_HEX3)
+				snprintf((char *)prod, sizeof(prod), "HEX3A3-Avalon3 ASIC Miner");
+			#endif
+			#else
+			
 			applog(LOG_DEBUG,
 				"USB init, failed to get iProduct, err %d %s",
 				err, devstr);
 			goto cldame;
+			#endif
+			
 		}
+	
 		if (strcmp((char *)prod, found->iProduct)) {
 			applog(LOG_DEBUG, "USB init, iProduct mismatch %s",
 			       devstr);
@@ -2097,6 +2343,9 @@
 			bad = USB_INIT_IGNORE;
 			goto cldame;
 		}
+		cgusb->prod_string = strdup((char *)prod);
+	} else {
+		cgusb->prod_string = (char *)BLANK;
 	}
 
 	cfg = -1;
@@ -2184,12 +2433,12 @@
 		else {
 			switch(err) {
 				case LIBUSB_ERROR_BUSY:
-					applog(LOG_WARNING,
+					applog(LOG_ERR,
 						"USB init, claim ifinfo %d interface %d in use %s",
 						ifinfo, THISIF(found, ifinfo), devstr);
 					break;
 				default:
-					applog(LOG_DEBUG,
+					applog(LOG_ERR,
 						"USB init, claim ifinfo %d interface %d failed,"
 						" err %d %s",
 						ifinfo, THISIF(found, ifinfo), err, devstr);
@@ -2203,7 +2452,7 @@
 	if (err)
 		cfg = -1;
 	if (cfg != found->config) {
-		applog(LOG_WARNING,
+		applog(LOG_ERR,
 			"USB init, incorrect config (%d!=%d) after claim of %s",
 			cfg, found->config, devstr);
 		goto reldame;
@@ -2218,25 +2467,8 @@
 // TODO: allow this with the right version of the libusb include and running library
 //	cgusb->speed = libusb_get_device_speed(dev);
 
-	err = libusb_get_string_descriptor_ascii(cgusb->handle,
-				cgusb->descriptor->iProduct, strbuf, STRBUFLEN);
-	if (err > 0)
-		cgusb->prod_string = strdup((char *)strbuf);
-	else
-		cgusb->prod_string = (char *)BLANK;
-
-	err = libusb_get_string_descriptor_ascii(cgusb->handle,
-				cgusb->descriptor->iManufacturer, strbuf, STRBUFLEN);
-	if (err > 0)
-		cgusb->manuf_string = strdup((char *)strbuf);
-	else
 		cgusb->manuf_string = (char *)BLANK;
 
-	err = libusb_get_string_descriptor_ascii(cgusb->handle,
-				cgusb->descriptor->iSerialNumber, strbuf, STRBUFLEN);
-	if (err > 0)
-		cgusb->serial_string = strdup((char *)strbuf);
-	else
 		cgusb->serial_string = (char *)BLANK;
 
 // TODO: ?
@@ -2281,11 +2513,13 @@
 	cgusb->handle = NULL;
 	cg_wunlock(&cgusb_fd_lock);
 
-dame:
 
 	if (config)
 		libusb_free_config_descriptor(config);
 
+dame:
+
+
 	cgusb = free_cgusb(cgusb);
 
 out_unlock:
@@ -2453,7 +2687,7 @@
 				drv->dname, drv_count[drv->drv_id].limit);
 			break;
 		}
-
+    
 		found = usb_check(drv, list[i]);
 		if (found != NULL) {
 			bool new_dev = false;
@@ -3581,6 +3815,15 @@
 	for (i = 0; i < total_devices; i++) {
 		cgpu = devices[i];
 		switch (cgpu->drv->drv_id) {
+			case DRIVER_hexminera:
+			case DRIVER_hexminerb:
+			case DRIVER_hexminerc:
+			case DRIVER_hexmineru:
+			case DRIVER_hexminer8:
+			case DRIVER_hexminerm:
+			case DRIVER_hexminerr:
+			case DRIVER_hexminerbe200:
+			case DRIVER_hexminer3:
 			case DRIVER_bflsc:
 			case DRIVER_bitforce:
 			case DRIVER_bitfury:
--- cg_o/usbutils.h	2014-09-22 14:22:33.052838431 +0300
+++ cgminer_hex/usbutils.h	2014-09-22 19:28:38.675387491 +0300
@@ -137,6 +137,15 @@
 	IDENT_AMU,
 	IDENT_ANT,
 	IDENT_ANU,
+	IDENT_HEXA,
+	IDENT_HEXB,
+	IDENT_HEXC,
+	IDENT_HEXU,
+	IDENT_HEX8,
+	IDENT_HEXM,
+	IDENT_HEXR,
+	IDENT_HEXBE200,
+	IDENT_HEX3,
 	IDENT_AS2,
 	IDENT_AVA,
 	IDENT_AV2,
@@ -577,5 +586,5 @@
 
 #define usb_transfer_read(cgpu, typ, req, val, idx, buf, bufsiz, read, cmd) \
 	_usb_transfer_read(cgpu, typ, req, val, idx, buf, bufsiz, read, DEVTIMEOUT, cmd)
-
+	
 #endif
--- cg_o/util.c	2014-09-22 14:22:33.052838431 +0300
+++ cgminer_hex/util.c	2014-09-22 19:28:38.675387491 +0300
@@ -1904,8 +1904,11 @@
 	/* A notify message is the closest stratum gets to a getwork */
 	pool->getwork_requested++;
 	total_getworks++;
-	if (pool == current_pool())
+	if (pool == current_pool()) {
 		opt_work_update = true;
+		clear_pool_work(pool);
+		work_pool_update++;
+	}
 out:
 	return ret;
 }
@@ -1925,7 +1928,8 @@
 
 	if (old_diff != diff) {
 		int idiff = diff;
-
+    clear_pool_work(pool);
+    work_pool_update++;
 		if ((double)idiff == diff)
 			applog(LOG_NOTICE, "Pool %d difficulty changed to %d",
 			       pool->pool_no, idiff);
--- cg_o/api.c	2014-09-22 14:22:33.004835734 +0300
+++ cgminer_hex/api.c	2014-09-22 19:28:38.671387123 +0300
@@ -25,8 +25,8 @@
 #include "miner.h"
 #include "util.h"
 #include "klist.h"
-
-#if defined(USE_BFLSC) || defined(USE_AVALON) || defined(USE_AVALON2) || \
+#if defined(USE_HEXMINERA) || defined(USE_HEXMINERB) || defined(USE_HEXMINERC) || defined(USE_HEXMINERU) || \
+	defined(USE_HEXMINER8) || defined(USE_HEXMINERM) || defined(USE_HEXMINERR) || defined(USE_HEXMINERBE200) || defined(USE_HEXMINER3) || defined(USE_BFLSC) || defined(USE_AVALON) || defined(USE_AVALON2) || \
 	defined(USE_HASHFAST) || defined(USE_BITFURY) || defined(USE_KLONDIKE) || \
 	defined(USE_KNC) || defined(USE_BAB) || defined(USE_DRILLBIT) || \
 	defined(USE_MINION) || defined(USE_COINTERRA) || defined(USE_BITMINE_A1) || \
@@ -40,7 +40,7 @@
 #endif
 
 // BUFSIZ varies on Windows and Linux
-#define TMPBUFSIZ	8192
+#define TMPBUFSIZ	8192 * 8
 
 // Number of requests to queue - normally would be small
 // However lots of PGA's may mean more
@@ -188,6 +188,33 @@
 #ifdef USE_BITMINE_A1
 			"BA1 "
 #endif
+#ifdef USE_HEXMINERA
+			"HEXa "
+#endif
+#ifdef USE_HEXMINERB
+			"HEXb "
+#endif
+#ifdef USE_HEXMINERC
+			"HEXc "
+#endif
+#ifdef USE_HEXMINERU
+			"HEXu "
+#endif
+#ifdef USE_HEXMINER8
+			"HEX8 "
+#endif
+#ifdef USE_HEXMINERM
+			"HEXM "
+#endif
+#ifdef USE_HEXMINERR
+			"HEXR "
+#endif
+#ifdef USE_HEXMINERBE200
+			"HEXE "
+#endif
+#ifdef USE_HEXMINER3
+			"HEX3 "
+#endif
 #ifdef USE_ICARUS
 			"ICA "
 #endif
@@ -1523,12 +1550,14 @@
 
 #if LOCK_TRACKING
 
+FILE * pFile;
+
 #define LOCK_FMT_FFL " - called from %s %s():%d"
 
-#define LOCKMSG(fmt, ...)	fprintf(stderr, "APILOCK: " fmt "\n", ##__VA_ARGS__)
-#define LOCKMSGMORE(fmt, ...)	fprintf(stderr, "          " fmt "\n", ##__VA_ARGS__)
-#define LOCKMSGFFL(fmt, ...) fprintf(stderr, "APILOCK: " fmt LOCK_FMT_FFL "\n", ##__VA_ARGS__, file, func, linenum)
-#define LOCKMSGFLUSH() fflush(stderr)
+#define LOCKMSG(fmt, ...)	fprintf(pFile, "APILOCK: " fmt "\n", ##__VA_ARGS__)
+#define LOCKMSGMORE(fmt, ...)	fprintf(pFile, "          " fmt "\n", ##__VA_ARGS__)
+#define LOCKMSGFFL(fmt, ...) fprintf(pFile, "APILOCK: " fmt LOCK_FMT_FFL "\n", ##__VA_ARGS__, file, func, linenum)
+#define LOCKMSGFLUSH() fflush(pFile)
 
 typedef struct lockstat {
 	uint64_t lock_id;
@@ -1886,6 +1915,7 @@
 
 void show_locks()
 {
+	pFile = fopen ("/tmp/cglocks","w");
 	LOCKLIST *list;
 
 	locklock();
@@ -1905,6 +1935,8 @@
 	LOCKMSGFLUSH();
 
 	lockunlock();
+	fclose (pFile);
+
 }
 #endif
 
@@ -2687,6 +2719,8 @@
 	}
 
 	pool = pools[id];
+	if (pool->enabled == POOL_DISABLED)
+		enabled_pools++;
 	pool->enabled = POOL_ENABLED;
 	cg_runlock(&control_lock);
 	switch_pools(pool);
@@ -2804,7 +2838,7 @@
 		message(io_data, MSG_ALRENAP, id, NULL, isjson);
 		return;
 	}
-
+  enabled_pools++;
 	pool->enabled = POOL_ENABLED;
 	if (pool->prio < current_pool()->prio)
 		switch_pools(pool);
@@ -2953,7 +2987,8 @@
 		message(io_data, MSG_DISLASTP, id, NULL, isjson);
 		return;
 	}
-
+	enabled_pools--;
+  if (pool->enabled == POOL_ENABLED) enabled_pools--;
 	pool->enabled = POOL_DISABLED;
 	if (pool == current_pool())
 		switch_pools(NULL);
@@ -3197,14 +3232,38 @@
 {
 	struct api_data *root = NULL;
 
+  #if defined(USE_HEXMINERA) || defined(USE_HEXMINERB) || defined(USE_HEXMINERC) || defined(USE_HEXMINERU) || defined(USE_HEXMINERM) || defined(USE_HEXMINERR) || defined(USE_HEXMINERBE200) || defined(USE_HEXMINER8) || defined(USE_HEXMINER3)
+	char *enabled;
+	char *status;
+  char *is_hex = NULL;
+  
+  is_hex = strstr(id, "HEX");
+  #endif
 	root = api_add_int(root, "STATS", &i, false);
 	root = api_add_string(root, "ID", id, false);
+	#if defined(USE_HEXMINERA) || defined(USE_HEXMINERB) || defined(USE_HEXMINERC) || defined(USE_HEXMINERU) || defined(USE_HEXMINERM) || defined(USE_HEXMINERR) || defined(USE_HEXMINERBE200) || defined(USE_HEXMINER8) || defined(USE_HEXMINER3)
+	if(is_hex && cgpu) {
+		if (cgpu->deven != DEV_DISABLED)
+				enabled = (char *)YES;
+			else
+				enabled = (char *)NO;
+		 
+		  status = (char *)status2str(cgpu->status);
+			root = api_add_string(root, "Enabled", enabled, false);
+			root = api_add_string(root, "Status", status, false);
+	}
+	#endif
 	root = api_add_elapsed(root, "Elapsed", &(total_secs), false);
+	#if defined(USE_HEXMINERA) || defined(USE_HEXMINERB) || defined(USE_HEXMINERC) || defined(USE_HEXMINERU) || defined(USE_HEXMINERM) || defined(USE_HEXMINERR) || defined(USE_HEXMINERBE200) || defined(USE_HEXMINER8) || defined(USE_HEXMINER3)
+	if(is_hex == NULL) {
+	#endif
 	root = api_add_uint32(root, "Calls", &(stats->getwork_calls), false);
 	root = api_add_timeval(root, "Wait", &(stats->getwork_wait), false);
 	root = api_add_timeval(root, "Max", &(stats->getwork_wait_max), false);
 	root = api_add_timeval(root, "Min", &(stats->getwork_wait_min), false);
-
+  #if defined(USE_HEXMINERA) || defined(USE_HEXMINERB) || defined(USE_HEXMINERC) || defined(USE_HEXMINERU) || defined(USE_HEXMINERM) || defined(USE_HEXMINERR) || defined(USE_HEXMINERBE200) || defined(USE_HEXMINER8) || defined(USE_HEXMINER3)
+	} 
+	#endif
 	if (pool_stats) {
 		root = api_add_uint32(root, "Pool Calls", &(pool_stats->getwork_calls), false);
 		root = api_add_uint32(root, "Pool Attempts", &(pool_stats->getwork_attempts), false);
@@ -3234,6 +3293,10 @@
 
 	if (cgpu) {
 #ifdef USE_USBUTILS
+	#if defined(USE_HEXMINERA) || defined(USE_HEXMINERB) || defined(USE_HEXMINERC) || defined(USE_HEXMINERU) || defined(USE_HEXMINERM) || defined(USE_HEXMINERR) || defined(USE_HEXMINERBE200) || defined(USE_HEXMINER8) || defined(USE_HEXMINER3)
+	if(is_hex == NULL) {
+	#endif
+	
 		char details[256];
 
 		if (cgpu->usbinfo.pipe_count)
@@ -3287,6 +3350,10 @@
 		}
 
 		root = api_add_string(root, "USB tmo", details, true);
+ #if defined(USE_HEXMINERA) || defined(USE_HEXMINERB) || defined(USE_HEXMINERC) || defined(USE_HEXMINERU) || defined(USE_HEXMINERM) || defined(USE_HEXMINERR) || defined(USE_HEXMINERBE200) || defined(USE_HEXMINER8) || defined(USE_HEXMINER3)
+	}
+ #endif
+	
 #endif
 	}
 
@@ -5004,7 +5071,11 @@
 										break;
 									}
 								}
+	#if LOCK_TRACKING
+	if (ISPRIVGROUP(group) || strstr(COMMANDS(group), cmdbuf) || 1)
+	#else
 								if (ISPRIVGROUP(group) || strstr(COMMANDS(group), cmdbuf))
+	#endif
 									(cmds[i].func)(io_data, c, param, isjson, group);
 								else {
 									message(io_data, MSG_ACCDENY, 0, cmds[i].name, isjson);
--- cg_o/driver-hexminera.c	1970-01-01 02:00:00.000000000 +0200
+++ cgminer_hex/driver-hexminera.c	2014-09-22 19:28:38.671387123 +0300
@@ -0,0 +1,474 @@
+/*$T indentinput.c GC 1.140 10/16/13 10:19:47 */
+#include "config.h"
+#include <limits.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <ctype.h>
+#include <dirent.h>
+#include <unistd.h>
+#ifndef WIN32
+#include <sys/select.h>
+#include <termios.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#ifndef O_CLOEXEC
+#define O_CLOEXEC0
+#endif
+#else
+#include "compat.h"
+#include <windows.h>
+#include <io.h>
+#endif
+#include "elist.h"
+#include "miner.h"
+#include "usbutils.h"
+#include "driver-hexminera.h"
+#include "util.h"
+
+extern unsigned int work_block;
+extern unsigned int work_pool_update;
+extern struct work *copy_work_noffset_fast_no_id (struct work *base_work,
+                                                  int noffset);
+struct device_drv hexminera_drv;
+int opt_hexminera_core_voltage = HEXA_DEFAULT_CORE_VOLTAGE;
+
+#include "libhexa.c"
+
+static int
+hexminera_send_task (struct hexminera_task *ht, struct cgpu_info *hexminera)
+{
+  int ret = 0;
+  size_t nr_len = HEXMINERA_TASK_SIZE;
+  struct hexminera_info *info;
+  info = hexminera->device_data;
+  libhexa_csum (&ht->startbyte, &ht->csum, &ht->csum);
+  ret = libhexa_sendHashData (hexminera, &ht->startbyte, nr_len);
+  if (ret != nr_len)
+    {
+      libhexa_reset (hexminera);
+      info->usb_w_errors++;
+      return -1;
+    }
+  return ret;
+}
+
+static inline void
+hexminera_create_task (bool reset_work, struct hexminera_task *ht,
+                       struct work *work)
+{
+  if (reset_work)
+    ht->status = HEXA_STAT_NEW_WORK_CLEAR_OLD;
+  else
+    ht->status = HEXA_STAT_NEW_WORK;
+  memcpy (ht->midstate, work->midstate, 32);
+  memcpy (ht->merkle, work->data + 64, 12);
+  ht->id = (uint8_t) work->subid;
+  libhexa_calc_hexminer (work, ht);
+}
+
+static inline void
+hexminera_init_task (struct hexminera_task *ht, struct hexminera_info *info)
+{
+  ht->startbyte = 0x53;
+  ht->datalength = (uint8_t) ((HEXMINERA_TASK_SIZE - 6) / 2);
+  ht->command = 0x57;
+  ht->address = htole16 (HEXA_WORKQUEUE_ADR);
+  libhexa_generateclk (info->frequency, HEXA_DEFAULT_XCLKIN_CLOCK,
+                       (uint32_t *) & ht->clockcfg[0]);
+  libhexa_setvoltage (info->core_voltage, &ht->refvoltage);
+  ht->chipcount = htole16 (info->asic_count);
+  ht->hashclock = htole16 ((uint16_t) info->frequency);
+  ht->startnonce = 0x00000000;
+}
+
+extern bool stale_work (struct work *work, bool share);
+
+static void
+do_write (struct thr_info *thr)
+{
+  struct cgpu_info *hexminera = thr->cgpu;
+  struct hexminera_info *info = hexminera->device_data;
+  int send_jobs, ret;
+  int jobs_to_send = info->jobs_to_send;
+  send_jobs = 0;
+  while (!libhexa_usb_dead (hexminera) && (send_jobs < jobs_to_send))
+    {
+    again:
+      if (!info->work)
+        {
+          info->roll = 0;
+          info->work = get_work (thr, thr->id);
+          info->work->ping = 1;
+        }
+      if (stale_work (info->work, false))
+        {
+          free_work (info->work);
+          info->work = NULL;
+          if (info->work_block_local != work_block || info->work_pool_update != work_pool_update)
+            {
+              info->reset_work = true;
+              send_jobs = 0;
+              jobs_to_send = 2;
+              info->work_block_local = work_block;
+              info->work_pool_update = work_pool_update;
+            }
+          goto again;
+        }
+      if (info->write_pos >= HEXMINERA_ARRAY_SIZE_REAL || info->reset_work)
+        info->write_pos = 0;
+      info->work->subid = info->write_pos;
+      free_work (info->hexworks[info->write_pos]);
+      info->hexworks[info->write_pos] =
+        copy_work_noffset_fast_no_id (info->work, info->roll++);
+      hexminera_create_task (info->reset_work, info->ht,
+                             info->hexworks[info->write_pos]);
+      if (info->work->drv_rolllimit)
+        info->work->drv_rolllimit--;
+      else
+        {
+          free_work (info->work);
+          info->work = NULL;
+        }
+      ret = hexminera_send_task (info->ht, hexminera);
+      info->write_pos++;
+      send_jobs++;
+      if (ret == HEXMINERA_TASK_SIZE && info->reset_work)
+        {
+          info->reset_work = false;
+          gettimeofday (&info->last_wr, NULL);
+        }
+    }
+}
+
+static struct cgpu_info *
+hexminera_detect_one (libusb_device * dev, struct usb_find_devices *found)
+{
+  int asic_count, frequency;
+  struct hexminera_info *info;
+  struct cgpu_info *hexminera;
+  bool configured = false;
+  int i = 0;
+  hexminera = usb_alloc_cgpu (&hexminera_drv, HEXA_MINER_THREADS);
+  if (!usb_init (hexminera, dev, found))
+    {
+      usb_uninit (hexminera);
+      return NULL;
+    }
+  hexminera->device_data = calloc (sizeof (struct hexminera_info), 1);
+  if (unlikely (!(hexminera->device_data)))
+    {
+      hexminera->device_data = NULL;
+      usb_uninit (hexminera);
+      return NULL;
+    }
+  if (opt_hexminera_options != NULL)
+		configured = (sscanf(opt_hexminera_options, "%d:%d", &asic_count, &frequency) == 2);
+  if (opt_hexminera_core_voltage < HEXA_MIN_COREMV
+      || opt_hexminera_core_voltage > HEXA_MAX_COREMV)
+    {
+      applog (LOG_ERR, "Invalid hexminera-voltage %d must be %dmV - %dmV",
+              opt_hexminera_core_voltage, HEXA_MIN_COREMV, HEXA_MAX_COREMV);
+      free (hexminera->device_data);
+      hexminera->device_data = NULL;
+      usb_uninit (hexminera);
+      return NULL;
+    }
+  
+  info = hexminera->device_data;
+  info->hexworks = calloc (sizeof (struct work *), HEXMINERA_ARRAY_SIZE);
+  if (unlikely (!(info->hexworks)))
+    {
+      free (hexminera->device_data);
+      hexminera->device_data = NULL;
+      usb_uninit (hexminera);
+      return NULL;
+    }
+  info->wr = (struct worka_result *) malloc (sizeof (struct worka_result));
+  info->array_nonce_cache = calloc (16, sizeof (struct chip_resultsa));
+  info->readbuf = calloc (HEXA_HASH_BUF_SIZE, sizeof (unsigned char));
+  info->write_pos = 0;
+  info->hash_read_pos = 0;
+  info->hash_write_pos = 0;
+  info->shut_read = false;
+  info->shut_write = false;
+  info->shut_reset = false;
+  info->work = NULL;
+  info->work_block_local = -1;
+  info->work_pool_update = -1;
+  info->reset_work = true;
+  info->jobs_to_send = 2;
+  info->miner_count = HEXA_DEFAULT_MINER_NUM;
+  info->asic_count = HEXA_DEFAULT_ASIC_NUM;
+  info->frequency = HEXA_DEFAULT_FREQUENCY;
+  info->pic_voltage_readings = HEXA_DEFAULT_CORE_VOLTAGE;
+  info->core_voltage = opt_hexminera_core_voltage;
+  if (configured)
+    {
+      info->asic_count = asic_count;
+      info->frequency = frequency;
+    }
+  info->ht = calloc (sizeof (struct hexminera_task), 1);
+  hexminera_init_task (info->ht, info);
+  gettimeofday (&info->last_wr, NULL);
+  info->wr->lastnonceid = 0;
+  info->wsem_ustiming =
+    (int64_t) (0x100000000ll / (16 * info->frequency * 0.97));
+  while (i < HEXMINERA_ARRAY_SIZE)
+    {
+      info->hexworks[i] = calloc (1, sizeof (struct work));
+      info->hexworks[i]->pool = NULL;
+      i++;
+    } libhexa_generatenrange_new ((unsigned char *) &info->nonces_range,
+                                  info->asic_count);
+  if (!add_cgpu (hexminera))
+    {
+      free (info->hexworks);
+      free (hexminera->device_data);
+      hexminera->device_data = NULL;
+      hexminera = usb_free_cgpu (hexminera);
+      usb_uninit (hexminera);
+      return NULL;
+    }
+  return hexminera;
+}
+
+static void
+hexminera_detect (bool __maybe_unused hotplug)
+{
+  usb_detect (&hexminera_drv, hexminera_detect_one);
+}
+
+static void
+do_hexminera_close (struct thr_info *thr)
+{
+  struct cgpu_info *hexminera = thr->cgpu;
+  struct hexminera_info *info = hexminera->device_data;
+  int i = 0;
+  while (i < HEXMINERA_ARRAY_SIZE)
+    {
+      free_work (info->hexworks[i]);
+      i++;
+    }
+  free (info->hexworks);
+  free (info->readbuf);
+  free (info->array_nonce_cache);
+  free (info->wr);
+  if (info->work)
+    free_work (info->work);
+  free (info->ht);
+}
+
+static void
+hexminera_shutdown (struct thr_info *thr)
+{
+  struct cgpu_info *hexminera = thr->cgpu;
+  do_hexminera_close (thr);
+  usb_nodev (hexminera);
+}
+
+static int64_t
+hexminera_scanhash (struct thr_info *thr)
+{
+  struct cgpu_info *hexminera = thr->cgpu;
+  struct hexminera_info *info = hexminera->device_data;
+  struct timeval now;
+  struct timeval diff;
+  int ret_r, notdupe, found, i, lastchippos = 0, rminder = 0;
+  int64_t tdif, hash_count = 0;
+  uint32_t nonce;
+  if (info->work_block_local != work_block || info->work_pool_update != work_pool_update)
+    {
+      info->reset_work = true;
+      info->jobs_to_send = 4;
+      info->work_block_local = work_block;
+      info->work_pool_update = work_pool_update;
+      if (info->work)
+        {
+          free_work (info->work);
+          info->work = NULL;
+        }
+      gettimeofday (&info->last_wr, NULL);
+      do_write (thr);
+      goto done_wr;
+    }
+  gettimeofday (&now, NULL);
+  tdif = timediff (&now, &info->last_wr);
+  info->jobs_to_send = (int) (tdif / info->wsem_ustiming);
+  rminder = (int) (tdif % info->wsem_ustiming);
+  if (info->jobs_to_send > 0)
+    {
+      gettimeofday (&info->last_wr, NULL);
+      now.tv_sec = 0;
+      now.tv_usec = rminder;
+      timersub (&info->last_wr, &now, &diff);
+      memcpy (&info->last_wr, &diff, sizeof (struct timeval));
+      if (info->jobs_to_send > 4)
+        info->jobs_to_send = 2;
+      do_write (thr);
+    }
+done_wr:
+  if (libhexa_usb_dead (hexminera))
+    {
+      hexminera->shutdown = true;
+      return -1;
+    }
+  if (info->hash_write_pos + HEXA_USB_R_SIZE > HEXA_HASH_BUF_SIZE_OK)
+    {
+      info->hash_write_pos = info->hash_write_pos - info->hash_read_pos;
+      memcpy (info->readbuf, info->readbuf + info->hash_read_pos,
+              info->hash_write_pos);
+      info->hash_read_pos = 0;
+    }
+  if (info->hash_write_pos - info->hash_read_pos > 7)
+    {
+    again:
+    	if (info->work_block_local != work_block || info->work_pool_update != work_pool_update)
+    		goto new_block;
+      ret_r =
+        libhexa_eatHashData (info->wr, info->readbuf, &info->hash_read_pos,
+                             &info->hash_write_pos);
+      if (ret_r > HEXA_BUF_DATA)
+        goto out;
+      if (info->wr->lastnonceid > HEXMINERA_ARRAY_SIZE_REAL)
+        info->wr->lastnonceid = 0;
+      nonce = htole32 (info->wr->lastnonce);
+      i = 0;
+      while (i < info->asic_count)
+        {
+          if (nonce < info->nonces_range[++i])
+            {
+              lastchippos = --i;
+              break;
+            }
+        }
+      if (i == info->asic_count)
+        lastchippos = info->asic_count - 1;
+      notdupe =
+        libhexa_cachenonce (&info->array_nonce_cache[lastchippos], nonce);
+      if (lastchippos > 0)
+        notdupe &= libhexa_cachenonce (&info->array_nonce_cache[0], nonce);
+      if (notdupe)
+        {
+          found =
+            hexminera_predecode_nonce (hexminera, thr, nonce,
+                                       info->wr->lastnonceid);
+          if (found > 0)
+            {
+              if (hash_count == 0)
+                libhexa_getvoltage (htole16 (info->wr->lastvoltage),
+                                    &info->pic_voltage_readings);
+              hash_count += found;
+              info->matching_work[lastchippos]++;
+            }
+          else
+            inc_hw_errors (thr);
+        }
+      else
+        info->dupe[lastchippos]++;
+    out:
+      if (ret_r == HEXA_BUF_ERR)
+        info->usb_r_errors++;
+      if (ret_r != HEXA_BUF_SKIP)
+        goto again;
+    }
+    if (info->work_block_local != work_block || info->work_pool_update != work_pool_update)
+    		goto new_block;
+  ret_r =
+    libhexa_readHashData (hexminera, info->readbuf, &info->hash_write_pos,
+                          HEXMINERA_BULK_READ_TIMEOUT);
+  cgsleep_us (100);
+  new_block:
+  hash_count = (int64_t) (0xffffffffull * hash_count);
+  if (libhexa_usb_dead (hexminera))
+    {
+      hexminera->shutdown = true;
+      return -1;
+    }
+  
+  return hash_count;
+}
+
+static void
+get_hexminera_statline_before (char *buf, size_t bufsiz,
+                               struct cgpu_info *hexminera)
+{
+  if (!hexminera->device_data)
+    return;
+  struct hexminera_info *info = hexminera->device_data;
+  tailsprintf (buf, bufsiz, "%3d %4d/%4dmV", info->frequency,
+               info->core_voltage, info->pic_voltage_readings);
+}
+
+extern void suffix_string (uint64_t val, char *buf, size_t bufsiz,
+                           int sigdigits);
+
+static struct api_data *
+hexminera_api_stats (struct cgpu_info *cgpu)
+{
+  struct api_data *root = NULL;
+  struct timeval now;
+  struct hexminera_info *info = cgpu->device_data;
+  char displayed_hashes[16], displayed_rolling[16];
+  double dev_runtime, hwp;
+  uint64_t dh64, dr64;
+  int i;
+  if (!info)
+    return NULL;
+  hwp =
+    (cgpu->hw_errors +
+     cgpu->diff1) ? (double) (cgpu->hw_errors) / (double) (cgpu->hw_errors +
+                                                           cgpu->diff1) : 0;
+  if (cgpu->dev_start_tv.tv_sec == 0)
+    dev_runtime = total_secs;
+  else
+    {
+      cgtime (&now);
+      dev_runtime = tdiff (&now, &(cgpu->dev_start_tv));
+    }
+  if (dev_runtime < 1.0)
+    dev_runtime = 1.0;
+  dh64 = (double) cgpu->total_mhashes / dev_runtime * 1000000ull;
+  dr64 = (double) cgpu->rolling * 1000000ull;
+  suffix_string (dh64, displayed_hashes, sizeof (displayed_hashes), 4);
+  suffix_string (dr64, displayed_rolling, sizeof (displayed_rolling), 4);
+  root = api_add_string (root, "MHS 5s", displayed_rolling, true);
+  root = api_add_string (root, "MHS av", displayed_hashes, true);
+  root = api_add_int (root, "Hardware Errors", &(cgpu->hw_errors), true);
+  root = api_add_percent (root, "Hardware Errors%", &hwp, true);
+  root = api_add_int (root, "USB Read Errors", &(info->usb_r_errors), true);
+  root = api_add_int (root, "USB Write Errors", &(info->usb_w_errors), true);
+  root =
+    api_add_int (root, "USB Reset Count", &(info->usb_reset_count), true);
+  root =
+    api_add_time (root, "Last Share Time", &(cgpu->last_share_pool_time),
+                  true);
+  root = api_add_int (root, "Chip Count", &(info->asic_count), true);
+  root = api_add_int (root, "Frequency", &(info->frequency), true);
+  root = api_add_int (root, "Core Voltage", &(info->core_voltage), true);
+  root =
+    api_add_int (root, "PIC Voltage Readings", &(info->pic_voltage_readings),
+                 true);
+  for (i = 0; i < info->asic_count; i++)
+    {
+      char mcw[24];
+      sprintf (mcw, "Chip%d Nonces", i + 1);
+      root = api_add_int (root, mcw, &(info->matching_work[i]), true);
+      sprintf (mcw, "Chip%d Dupes", i + 1);
+      root = api_add_int (root, mcw, &(info->dupe[i]), true);
+    }
+  return root;
+}
+
+struct device_drv hexminera_drv = {
+  .drv_id = DRIVER_hexminera,
+  .dname = "hexminera",
+  .name = "HEXa",
+  .drv_detect = hexminera_detect,
+  .hash_work = hash_driver_work,
+  .scanwork = hexminera_scanhash,
+  .get_api_stats = hexminera_api_stats,
+  .get_statline_before = get_hexminera_statline_before,
+  .thread_shutdown = hexminera_shutdown,
+};
--- cg_o/driver-hexminera.h	1970-01-01 02:00:00.000000000 +0200
+++ cgminer_hex/driver-hexminera.h	2014-09-22 19:28:38.671387123 +0300
@@ -0,0 +1,138 @@
+/*$T indentinput.h GC 1.140 10/16/13 10:20:01 */
+#ifndef HEXA_H
+#define HEXA_H
+#ifdef USE_HEXMINERA
+#include "util.h"
+
+/* hexminera_task/work_reply status Definitions: */
+#define HEXA_STAT_NEW_WORK 1    /* Request for write in the buffer */
+#define HEXA_STAT_NEW_WORK_CLEAR_OLD 5  /* Clear Buffers and after that fill the first buffer */
+
+/* BUF_reply status Definitions: */
+#define HEXA_BUF_DATA 0
+#define HEXA_BUF_ERR 1
+#define HEXA_BUF_SKIP 2
+
+/* MISC */
+#define HEXA_DEFAULT_XCLKIN_CLOCK 32    /* In MHz */
+#define HEXA_CLOCK_LOW_CFG 0x00030017
+#define HEXA_CLOCK_HIGH_CFG (0x0000002e << 3)   /* = 0x00000170 */
+#define HEXMINERA_ARRAY_PIC_SIZE 64
+#define HEXMINERA_ARRAY_SIZE HEXMINERA_ARRAY_PIC_SIZE * 4
+#define HEXMINERA_ARRAY_SIZE_REAL HEXMINERA_ARRAY_SIZE - 2
+#define HEXA_NONCE_CASH_SIZE 32
+#define HEXA_USB_R_SIZE 1
+#define MAX_REPL_PACKET 0x0f
+#define HEXA_USB_WR_SIZE 60
+#define HEXA_HASH_BUF_SIZE 500
+#define HEXA_HASH_BUF_SIZE_OK HEXA_HASH_BUF_SIZE - 4
+#define HEXA_USB_WR_TIME_OUT 100
+#define HEXMINERA_BULK_READ_TIMEOUT 10
+#define HEXA_MAX_START_DELAY_MS 1000
+#define HEXA_MINER_THREADS 1
+#define HEXA_DEFAULT_MINER_NUM 0x01
+#define HEXA_DEFAULT_ASIC_NUM 0x10
+#define HEXA_MIN_FREQUENCY 100
+#define HEXA_MAX_FREQUENCY 11650
+#define HEXA_DEFAULT_FREQUENCY 282
+#define HEXA_DEFAULT_CORE_VOLTAGE 1200  /* in millivolts */
+#define HEXA_MIN_COREMV 1000    /* in millivolts */
+#define HEXA_MAX_COREMV 1630    /* in millivolts */
+struct chip_resultsa
+{
+  uint8_t nonce_cache_write_pos;
+  uint32_t nonces[HEXA_NONCE_CASH_SIZE];
+};
+struct worka_result
+{
+  uint8_t startbyte;
+  uint8_t datalength;
+  uint8_t command;
+  uint16_t address;
+  uint32_t lastnonce;
+  uint8_t lastnonceid;
+  uint8_t status;
+  uint16_t lastvoltage;
+  uint16_t lasttemperature;
+  uint16_t lastfanrpm;
+  uint32_t serial;
+  uint16_t openloadduty;
+  uint16_t workingduty;
+  uint16_t lastworkingduty;
+  uint16_t clockforce;
+  /* Times Avalons Crashed */ uint8_t pad[3];
+} __attribute__ ((packed, aligned (4)));
+struct hexminera_info
+{
+  struct timeval last_wr;
+  int jobs_to_send;
+  int64_t wsem_ustiming;
+  bool shut_read;
+  bool shut_write;
+  bool shut_reset;
+  bool reset_work;
+  int roll;
+  int miner_count;
+  int asic_count;
+  int core_voltage;
+  int frequency;
+  int hash_read_pos;
+  int hash_write_pos;
+  int usb_r_errors;
+  int usb_w_errors;
+  int usb_reset_count;
+  int pic_voltage_readings;
+  int write_pos;
+  int dupe[HEXA_DEFAULT_ASIC_NUM];
+  int matching_work[HEXA_DEFAULT_ASIC_NUM];
+  unsigned int work_block_local;
+  unsigned int work_pool_update;
+  unsigned char *readbuf;
+  uint32_t nonces_range[HEXA_DEFAULT_ASIC_NUM];
+  struct worka_result *wr;
+  struct work **hexworks;
+  struct work *work;
+  struct hexminera_task *ht;
+  struct chip_resultsa *array_nonce_cache;
+};
+struct hexminera_task
+{
+  uint8_t startbyte;
+  uint8_t datalength;
+  uint8_t command;
+  uint16_t address;
+  uint32_t clockcfg[2];
+  uint32_t merkle[3];
+  uint32_t a1;
+  uint32_t a0;
+  uint32_t e2;
+  uint32_t e1;
+  uint32_t e0;
+  uint8_t midstate[32];
+  uint32_t a2;
+  uint32_t startnonce;
+  uint8_t id;
+  uint8_t status;
+  uint16_t hashclock;
+  uint16_t chipcount;
+  uint16_t refvoltage;
+  uint16_t reftemperature;
+  uint16_t reffanrpm;
+  uint8_t csum;
+  uint8_t pad[2];
+} __attribute__ ((packed, aligned (4)));
+
+#define HEXA_WORKANSWER_ADR 0x3000
+#define HEXA_WORKQUEUE_ADR 0x4000
+#define HEXA_PTCON_ADR 0x0C00
+#define HEXA_START_STOP_ADR 0x646E
+#define HEXMINERA_TASK_SIZE (sizeof(struct hexminera_task)-2)
+#define HEXA_MAX_WORK_SIZE (sizeof(struct worka_result) - 3)
+#define HEXA_BASE_WORK_SIZE 6
+#define HEXA_WORKANSWER_STAT_ADR HEXA_BASE_WORK_SIZE + 4
+
+extern int opt_hexminera_core_voltage;
+extern struct hexminera_info **hexminera_info;
+
+#endif /* USE_HEXMINERA */
+#endif /* HEXA_H */
--- cg_o/libhexa.c	1970-01-01 02:00:00.000000000 +0200
+++ cgminer_hex/libhexa.c	2014-09-22 19:28:38.671387123 +0300
@@ -0,0 +1,278 @@
+/*$T indentinput.c GC 1.140 10/16/13 10:20:34 */
+
+#define rotate(x, y)((x << y) | (x >> (sizeof(x) * 8 - y)))
+#define rotr(x, y)((x >> y) | (x << (sizeof(x) * 8 - y)))
+#define R(a, b, c, d, e, f, g, h, w, k) \
+h = h + \
+(rotate(e, 26) ^ rotate(e, 21) ^ rotate(e, 7)) + \
+(g ^ (e & (f ^ g))) + \
+k + \
+w; \
+d = d + h; \
+h = h + (rotate(a, 30) ^ rotate(a, 19) ^ rotate(a, 10)) + ((a & b) | (c & (a | b)))
+const uint32_t SHA256_K[3] = { 0x428a2f98, 0x71374491, 0xb5c0fbcf };
+
+static bool
+libhexa_cachenonce (struct chip_resultsa *nonce_cache, uint32_t nonce)
+{
+  int i = 0;
+  while (i < HEXA_NONCE_CASH_SIZE && nonce_cache->nonces[i] != nonce)
+    i++;
+  if (i < HEXA_NONCE_CASH_SIZE)
+    return false;
+  if (nonce_cache->nonce_cache_write_pos == HEXA_NONCE_CASH_SIZE)
+    nonce_cache->nonce_cache_write_pos = 0;
+  nonce_cache->nonces[nonce_cache->nonce_cache_write_pos++] = nonce;
+  return true;
+}
+
+static void
+libhexa_generatenrange_new (unsigned char *buf, int asic_num)
+{
+  uint32_t nonceAdd;
+  int noncePos;
+  int64_t nonceCalc = 0x100000000ll;
+  nonceCalc /= asic_num;
+  nonceAdd = (uint32_t) nonceCalc;
+  uint32_t chip_noce;
+  for (noncePos = 0; noncePos < asic_num; noncePos++)
+    {
+      chip_noce = noncePos * nonceAdd;
+      memcpy (buf + noncePos * 4, &chip_noce, 4);
+    }
+}
+
+static void
+libhexa_calc_hexminer (struct work *work, struct hexminera_task *ht)
+{
+  uint32_t a0a1a2e0e1e2[6];
+  uint32_t A, B, C, D, E, F, G, H;
+  uint32_t state[8];
+  uint32_t data[3];
+  memcpy (&state, work->midstate, 32);
+  memcpy (&data, work->data + 64, 12);
+#if defined(__BIG_ENDIAN__) || defined(MIPSEB)
+  int i;
+  for (i = 0; i < 8; i++)
+    state[i] = htole32 (state[i]);
+  for (i = 0; i < 3; i++)
+    data[i] = htole32 (data[i]);
+#endif
+  A = state[0];
+  B = state[1];
+  C = state[2];
+  D = state[3];
+  E = state[4];
+  F = state[5];
+  G = state[6];
+  H = state[7];
+  R (A, B, C, D, E, F, G, H, data[0], SHA256_K[0]);
+  a0a1a2e0e1e2[0] = htole32 (H);
+  a0a1a2e0e1e2[3] = htole32 (D);
+  R (H, A, B, C, D, E, F, G, data[1], SHA256_K[1]);
+  a0a1a2e0e1e2[1] = htole32 (G);
+  a0a1a2e0e1e2[4] = htole32 (C);
+  R (G, H, A, B, C, D, E, F, data[2], SHA256_K[2]);
+  a0a1a2e0e1e2[2] = htole32 (F);
+  a0a1a2e0e1e2[5] = htole32 (B);
+  memcpy (&ht->a0, &a0a1a2e0e1e2[0], 4);
+  memcpy (&ht->a1, &a0a1a2e0e1e2[1], 4);
+  memcpy (&ht->a2, &a0a1a2e0e1e2[2], 4);
+  memcpy (&ht->e0, &a0a1a2e0e1e2[3], 4);
+  memcpy (&ht->e1, &a0a1a2e0e1e2[4], 4);
+  memcpy (&ht->e2, &a0a1a2e0e1e2[5], 4);
+}
+
+static void
+libhexa_generateclk (uint16_t HashClock, uint16_t XCLKIN, uint32_t * res)
+{
+  uint32_t configL = 0;
+  uint32_t configH = 0;
+  int RValue = XCLKIN;
+  int NValue = (HashClock * 2 * RValue / XCLKIN);
+  configL =
+    ((uint32_t) RValue << 29) | ((uint32_t) NValue << 18) |
+    HEXA_CLOCK_LOW_CFG;
+  configH = ((uint32_t) RValue >> 3) | HEXA_CLOCK_HIGH_CFG;
+  res[0] = htole32 (configL);
+  res[1] = htole32 (configH);
+}
+
+static void
+libhexa_csum (unsigned char *startptr, unsigned char *endptr,
+              unsigned char *resptr)
+{
+  unsigned char *b = startptr;
+  uint8_t sum = 0;
+  while (b < endptr)
+    sum += *b++;
+  memcpy (resptr, &sum, 1);
+}
+
+static bool
+libhexa_usb_dead (struct cgpu_info *hexminera)
+{
+  struct cg_usb_device *usbdev;
+  struct hexminera_info *info = hexminera->device_data;
+  if (!info)
+    return true;
+  usbdev = hexminera->usbdev;
+  bool ret = (usbdev == NULL || usbdev->handle == NULL || hexminera->shutdown
+              || info->shut_read || info->shut_write || info->shut_reset
+              || hexminera->usbinfo.nodev || hexminera->deven != DEV_ENABLED);
+  return ret;
+}
+
+static int64_t
+timediff (const struct timeval *a, const struct timeval *b)
+{
+  struct timeval diff;
+  timersub (a, b, &diff);
+  return diff.tv_sec * 1000000 + diff.tv_usec;
+}
+
+static int
+libhexa_sendHashData (struct cgpu_info *hexminera, unsigned char *sendbuf,
+                      size_t buf_len)
+{
+  struct hexminera_info *info = hexminera->device_data;
+  struct cg_usb_device *usbdev;
+  int wrote = 0, written = 0;
+  int err = LIBUSB_SUCCESS;
+  usbdev = hexminera->usbdev;
+  if (libhexa_usb_dead (hexminera))
+    goto out;
+  while (written < buf_len && err == LIBUSB_SUCCESS)
+    {
+      err =
+        libusb_bulk_transfer (usbdev->handle, 0x02, sendbuf + written,
+                              MIN (HEXA_USB_WR_SIZE, buf_len - written),
+                              &wrote, HEXA_USB_WR_TIME_OUT);
+      if (err == LIBUSB_SUCCESS)
+        written += wrote;
+    }
+out:
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+    info->shut_write = true;
+  return written;
+}
+
+static void
+libhexa_reset (struct cgpu_info *hexminera)
+{
+  struct hexminera_info *info = hexminera->device_data;
+  struct cg_usb_device *usbdev;
+  int err = LIBUSB_SUCCESS;
+  usbdev = hexminera->usbdev;
+  if (libhexa_usb_dead (hexminera))
+    goto out;
+  err = libusb_reset_device (usbdev->handle);
+out:
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+    info->shut_reset = true;
+  info->usb_reset_count++;
+}
+
+static int
+libhexa_readHashData (struct cgpu_info *hexminera, unsigned char *hash,
+                      int *hash_write_pos, int timeout)
+{
+  struct hexminera_info *info = hexminera->device_data;
+  struct cg_usb_device *usbdev;
+  int read = 0;
+  int err = LIBUSB_SUCCESS;
+  usbdev = hexminera->usbdev;
+  if (libhexa_usb_dead (hexminera))
+    goto out;
+  err =
+    libusb_bulk_transfer (usbdev->handle, 0x82, hash + *hash_write_pos,
+                          HEXA_USB_R_SIZE, &read, timeout);
+  if (err == LIBUSB_SUCCESS)
+    *hash_write_pos += MIN (read, HEXA_USB_R_SIZE);
+out:
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+    info->shut_read = true;
+  return err;
+}
+
+extern bool submit_tested_work_fast_clone (struct thr_info *thr,
+                                           struct work *work, bool diff1);
+
+static int
+hexminera_predecode_nonce (struct cgpu_info *hexminera, struct thr_info *thr,
+                           uint32_t nonce, uint8_t work_id)
+{
+  struct hexminera_info *info = hexminera->device_data;
+  if (info->hexworks[work_id]->pool == NULL)
+    return 0;
+  if (test_nonce (info->hexworks[work_id], nonce))
+    {
+      submit_tested_work_fast_clone (thr, info->hexworks[work_id], true);
+      return 1;
+    }
+  return 0;
+}
+
+static void
+libhexa_getvoltage (uint16_t wr_bukvoltage, int *info_pic_voltage_readings)
+{
+  float voltagehuman;
+  voltagehuman =
+    (float) ((float) wr_bukvoltage * (float) 1000 * (float) 3.3 /
+             ((1 << 12) - 1));
+  *info_pic_voltage_readings = (int) voltagehuman;
+}
+
+static void
+libhexa_setvoltage (int info_voltage, uint16_t * refvoltage)
+{
+  uint16_t voltageadc;
+  voltageadc =
+    (uint16_t) ((float) info_voltage / (float) 1000 / (float) 3.3 *
+                ((1 << 12) - 1));
+  *refvoltage = htole16 (voltageadc);
+}
+
+static int
+libhexa_eatHashData (struct worka_result *wr, unsigned char *hash,
+                     int *hash_read_pos, int *hash_write_pos)
+{
+  uint8_t psum;
+  int wrpos;
+  unsigned char *csum_pos;
+  bool ok;
+  int places = 0;
+eat:
+  while (*hash_read_pos < *hash_write_pos && hash[*hash_read_pos] != 0x53)
+    *hash_read_pos += 1;
+  places = *hash_write_pos - *hash_read_pos;
+  if (places < 8)
+    return HEXA_BUF_SKIP;
+  memcpy ((char *) &wr->startbyte, &hash[*hash_read_pos],
+          HEXA_BASE_WORK_SIZE - 1);
+  wr->address = htole16 (wr->address);
+  ok = (wr->command == 0x52)
+    && ((wr->address == HEXA_WORKANSWER_ADR && wr->datalength == 0x06)
+        || (wr->address == HEXA_WORKANSWER_ADR && wr->datalength == 0x0C));
+  if (!ok)
+    {
+      *hash_read_pos += 1;
+      goto eat;
+    }
+  if (places < HEXA_BASE_WORK_SIZE + wr->datalength * 2)
+    return HEXA_BUF_SKIP;
+  csum_pos =
+    hash + *hash_read_pos + HEXA_BASE_WORK_SIZE + wr->datalength * 2 - 1;
+  libhexa_csum (hash + *hash_read_pos, csum_pos, &psum);
+  if (psum != *csum_pos)
+    {
+      *hash_read_pos += 1;
+      return HEXA_BUF_ERR;
+    }
+  wrpos = (wr->address - HEXA_WORKANSWER_ADR) + HEXA_BASE_WORK_SIZE - 1;
+  memcpy ((char *) &wr->startbyte + wrpos,
+          &hash[*hash_read_pos + HEXA_BASE_WORK_SIZE - 1],
+          wr->datalength * 2);
+  *hash_read_pos += HEXA_BASE_WORK_SIZE + wr->datalength * 2;
+  return HEXA_BUF_DATA;
+}
--- cg_o/hubpower.c	1970-01-01 02:00:00.000000000 +0200
+++ cgminer_hex/hubpower.c	2014-09-22 19:28:38.671387123 +0300
@@ -0,0 +1,280 @@
+/* hubpower -- control the power settings for a USB hub
+ *
+ * To build: gcc -o hubpower hubpower.c
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+//#include <strings.h>
+#include <string.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <sys/ioctl.h>
+
+#include <asm/byteorder.h>
+#include <linux/usbdevice_fs.h>
+#include <linux/usb/ch9.h>
+
+#define USB_HUB_TIMEOUT     5000    /* milliseconds */
+#define USB_PORT_FEAT_POWER 8
+
+#define USB_DT_HUB      (USB_TYPE_CLASS | 0x09)
+#define USB_DT_HUB_SIZE     7
+
+struct usb_hub_descriptor {
+    __u8  bDescLength;
+    __u8  bDescriptorType;
+    __u8  bNbrPorts;
+    __le16 wHubCharacteristics;
+    __u8  bPwrOn2PwrGood;
+    __u8  bHubContrCurrent;
+} __attribute__ ((packed));
+
+struct usb_port_status {
+    __le16 wPortStatus;
+    __le16 wPortChange;
+} __attribute__ ((packed));
+
+#define USB_PORT_STAT_CONNECTION    0x0001
+#define USB_PORT_STAT_ENABLE        0x0002
+#define USB_PORT_STAT_SUSPEND       0x0004
+#define USB_PORT_STAT_OVERCURRENT   0x0008
+#define USB_PORT_STAT_RESET     0x0010
+#define USB_PORT_STAT_L1        0x0020
+/* bits 6 to 7 are reserved */
+#define USB_PORT_STAT_POWER     0x0100
+#define USB_PORT_STAT_LOW_SPEED     0x0200
+#define USB_PORT_STAT_HIGH_SPEED        0x0400
+#define USB_PORT_STAT_TEST              0x0800
+#define USB_PORT_STAT_INDICATOR         0x1000
+#define USB_PORT_STAT_POWER_3       0x0200  /* USB 3.0 */
+
+
+int fd;     /* Hub device file */
+int usb_level;
+
+
+void usage(void)
+{
+    fprintf(stderr, "Usage:"
+        "\thubpower busnum:devnum power {portnum (on|off)} ...\n"
+        "\thubpower busnum:devnum status\n"
+        "\thubpower busnum:devnum bind\n"
+        );
+    exit(1);
+}
+
+void port_status(int portnum)
+{
+    struct usbdevfs_ctrltransfer ctrl;
+    struct usb_port_status pstat;
+    int rc;
+
+    ctrl.bRequestType = USB_DIR_IN | USB_TYPE_CLASS |
+            USB_RECIP_OTHER;
+    ctrl.bRequest = USB_REQ_GET_STATUS;
+    ctrl.wValue = 0;
+    ctrl.wIndex = portnum;
+    ctrl.wLength = sizeof(pstat);
+    ctrl.timeout = USB_HUB_TIMEOUT;
+    ctrl.data = &pstat;
+    rc = ioctl(fd, USBDEVFS_CONTROL, &ctrl);
+    if (rc == -1) {
+        fprintf(stderr, "Error in ioctl "
+            "(get port %d status): %s\n",
+            portnum, strerror(errno));
+        return;
+    }
+
+    printf("Port %2d status: %04x ", portnum, pstat.wPortStatus);
+
+    if (usb_level <= 2) {
+        if (pstat.wPortStatus & USB_PORT_STAT_INDICATOR)
+            printf(" Indicator");
+        if (pstat.wPortStatus & USB_PORT_STAT_TEST)
+            printf(" Test-Mode");
+        if (pstat.wPortStatus & USB_PORT_STAT_HIGH_SPEED)
+            printf(" High-Speed");
+        if (pstat.wPortStatus & USB_PORT_STAT_LOW_SPEED)
+            printf(" Low-Speed");
+        if (pstat.wPortStatus & USB_PORT_STAT_POWER)
+            printf(" Power-On");
+        else
+            printf(" Power-Off");
+    } else if (usb_level == 3) {
+        if (pstat.wPortStatus & USB_PORT_STAT_POWER_3)
+            printf(" Power-On");
+        else
+            printf(" Power-Off");
+    }
+
+    if (pstat.wPortStatus & USB_PORT_STAT_RESET)
+        printf(" Resetting");
+    if (pstat.wPortStatus & USB_PORT_STAT_OVERCURRENT)
+        printf(" Overcurrent");
+    if (pstat.wPortStatus & USB_PORT_STAT_SUSPEND)
+        printf(" Suspended");
+    if (pstat.wPortStatus & USB_PORT_STAT_ENABLE)
+        printf(" Enabled");
+    if (pstat.wPortStatus & USB_PORT_STAT_CONNECTION)
+        printf(" Connected");
+
+    printf("\n");
+}
+
+int main(int argc, char **argv)
+{
+    int busnum, devnum, numports;
+    enum {DO_POWER, DO_STATUS, DO_BIND} action;
+    char fname1[40], fname2[40];
+    int rc;
+    int portnum;
+    struct usb_device_descriptor dev_descr;
+    struct usb_hub_descriptor hub_descr;
+    struct usbdevfs_ctrltransfer ctrl;
+    struct usbdevfs_ioctl usb_ioctl;
+    int bus_endian;
+
+    if (argc < 3)
+        usage();
+    if (sscanf(argv[1], "%d:%d", &busnum, &devnum) != 2 ||
+            busnum <= 0 || busnum > 255 ||
+            devnum <= 0 || devnum > 255)
+        usage();
+
+    if (strcmp(argv[2], "power") == 0) {
+        action = DO_POWER;
+        if ((argc - 3) % 2 != 0)
+            usage();
+    } else if (strcmp(argv[2], "status") == 0) {
+        action = DO_STATUS;
+        if (argc != 3)
+            usage();
+    } else if (strcmp(argv[2], "bind") == 0) {
+        action = DO_BIND;
+        if (argc != 3)
+            usage();
+    } else {
+        usage();
+    }
+
+    sprintf(fname1, "/dev/bus/usb/%03d/%03d", busnum, devnum);
+    sprintf(fname2, "/proc/bus/usb/%03d/%03d", busnum, devnum);
+
+    bus_endian = 1;
+    fd = open(fname1, O_RDWR);
+    if (fd < 0) {
+        int err1 = errno;
+
+        bus_endian = 0;
+        fd = open(fname2, O_RDWR);
+        if (fd < 0) {
+            fprintf(stderr, "Unable to open device file %s: %s\n",
+                    fname1, strerror(err1));
+            fprintf(stderr, "Unable to open device file %s: %s\n",
+                    fname2, strerror(errno));
+            return 1;
+        }
+    }
+
+    rc = read(fd, &dev_descr, USB_DT_DEVICE_SIZE);
+    if (rc != USB_DT_DEVICE_SIZE) {
+        perror("Error reading device descriptor");
+        return 1;
+    }
+    if (dev_descr.bDeviceClass != USB_CLASS_HUB) {
+        fprintf(stderr, "Device %d:%d is not a hub\n",
+                busnum, devnum);
+        return 1;
+    }
+    if (bus_endian) {
+        dev_descr.bcdUSB = __le16_to_cpu(dev_descr.bcdUSB);
+    }
+    usb_level = dev_descr.bcdUSB >> 8;
+
+    ctrl.bRequestType = USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_DEVICE;
+    ctrl.bRequest = USB_REQ_GET_DESCRIPTOR;
+    ctrl.wValue = USB_DT_HUB << 8;
+    ctrl.wIndex = 0;
+    ctrl.wLength = USB_DT_HUB_SIZE;
+    ctrl.timeout = USB_HUB_TIMEOUT;
+    ctrl.data = &hub_descr;
+    rc = ioctl(fd, USBDEVFS_CONTROL, &ctrl);
+    if (rc == -1) {
+        perror("Error in ioctl (read hub descriptor)");
+        return 1;
+    }
+    numports = hub_descr.bNbrPorts;
+
+    if (action == DO_STATUS) {
+        for (portnum = 1; portnum <= numports; ++portnum)
+            port_status(portnum);
+        return 0;
+    }
+
+    if (action == DO_BIND) {
+        usb_ioctl.ifno = 0;
+        usb_ioctl.ioctl_code = USBDEVFS_CONNECT;
+        usb_ioctl.data = NULL;
+        rc = ioctl(fd, USBDEVFS_IOCTL, &usb_ioctl);
+        if (rc == -1) {
+            perror("Error in ioctl (USBDEVFS_CONNECT)");
+            return 1;
+        }
+        printf("Bind-driver request sent to the kernel\n");
+        return 0;
+    }
+
+    if (action == DO_POWER) {
+        int i;
+
+        usb_ioctl.ifno = 0;
+        usb_ioctl.ioctl_code = USBDEVFS_DISCONNECT;
+        usb_ioctl.data = NULL;
+        rc = ioctl(fd, USBDEVFS_IOCTL, &usb_ioctl);
+        if (rc == -1 && errno != ENODATA) {
+            perror("Error in ioctl (USBDEVFS_DISCONNECT)");
+            return 1;
+        }
+
+        for (i = 3; i < argc; i += 2) {
+            portnum = atoi(argv[i]);
+            if (portnum < 1 || portnum > numports) {
+                fprintf(stderr, "Invalid port number: %d\n",
+                        portnum);
+                continue;
+            }
+
+            if (strcmp(argv[i+1], "on") == 0)
+                ctrl.bRequest = USB_REQ_SET_FEATURE;
+            else if (strcmp(argv[i+1], "off") == 0)
+                ctrl.bRequest = USB_REQ_CLEAR_FEATURE;
+            else {
+                fprintf(stderr, "Invalid port power level: %s\n)",
+                        argv[i+1]);
+                continue;
+            }
+
+            ctrl.bRequestType = USB_DIR_OUT | USB_TYPE_CLASS |
+                    USB_RECIP_OTHER;
+            ctrl.wValue = USB_PORT_FEAT_POWER;
+            ctrl.wIndex = portnum;
+            ctrl.wLength = 0;
+            ctrl.timeout = USB_HUB_TIMEOUT;
+            ctrl.data = NULL;
+            rc = ioctl(fd, USBDEVFS_CONTROL, &ctrl);
+            if (rc == -1) {
+                fprintf(stderr, "Error in ioctl "
+                    "(set/clear port %d feature): %s\n",
+                    portnum, strerror(errno));
+                continue;
+            }
+
+            port_status(portnum);
+        }
+    }
+    return 0;
+}
+
+
--- cg_o/driver-hexminerc.c	1970-01-01 02:00:00.000000000 +0200
+++ cgminer_hex/driver-hexminerc.c	2014-09-22 19:28:38.671387123 +0300
@@ -0,0 +1,565 @@
+/*$T indentinput.c GC 1.140 10/16/13 10:19:47 */
+#include "config.h"
+#include <limits.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <ctype.h>
+#include <dirent.h>
+#include <unistd.h>
+#ifndef WIN32
+#include <sys/select.h>
+#include <termios.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#ifndef O_CLOEXEC
+#define O_CLOEXEC 0
+#endif
+#else
+#include "compat.h"
+#include <windows.h>
+#include <io.h>
+#endif
+#include "elist.h"
+#include "miner.h"
+#include "usbutils.h"
+#include "driver-hexminerc.h"
+#include "util.h"
+extern unsigned int work_block;
+extern unsigned int work_pool_update;
+extern struct work *copy_work_noffset_fast_no_id (struct work *base_work,
+                                                  int noffset);
+extern bool stale_work (struct work *work, bool share);
+struct device_drv hexminerc_drv;
+int opt_hexminerc_core_voltage = HEXC_DEFAULT_CORE_VOLTAGE;
+
+#include "libhexc.c"
+extern bool no_work;
+
+static int
+hexminerc_send_task (struct hexminerc_task *ht, struct cgpu_info *hexminerc)
+{
+  int ret = 0;
+  size_t nr_len = HEXMINERC_TASK_SIZE;
+  struct hexminerc_info *info;
+  info = hexminerc->device_data;
+  libhexc_csum (&ht->startbyte, &ht->csum, &ht->csum);
+  ret = libhexc_sendHashData (hexminerc, &ht->startbyte, nr_len);
+  if (ret != nr_len)
+    {
+      libhexc_reset (hexminerc);
+      info->usb_w_errors++;
+      return -1;
+    }
+  return ret;
+}
+
+static inline void
+hexminerc_create_task (bool reset_work, struct hexminerc_task *ht,
+                       struct work *work)
+{
+  if (reset_work)
+    ht->status = HEXC_STAT_NEW_WORK_CLEAR_OLD;
+  else
+    ht->status = HEXC_STAT_NEW_WORK;
+  memcpy (ht->midstate, work->midstate, 32);
+  memcpy (ht->merkle, work->data + 64, 12);
+  ht->id = (uint8_t) work->subid;
+  libhexc_calc_hexminer (work, ht);
+}
+
+static inline void
+hexminerc_init_task (struct hexminerc_task *ht, struct hexminerc_info *info)
+{
+  ht->startbyte = 0x53;
+  ht->datalength = (uint8_t) ((HEXMINERC_TASK_SIZE - 6) / 2);
+  ht->command = 0x57;
+  ht->address = htole16 (HEXC_WORKQUEUE_ADR);
+  libhexc_generateclk (info->frequency, HEXC_DEFAULT_XCLKIN_CLOCK,
+                       (uint32_t *) & ht->clockcfg[0]);
+  libhexc_setvoltage (info->core_voltage, &ht->refvoltage);
+  ht->chipcount = htole16 (info->asic_count);
+  ht->hashclock = htole16 ((uint16_t) info->frequency);
+  ht->startnonce = 0x00000000;
+  ht->status = HEXC_STAT_NEW_WORK_CLEAR_OLD;
+}
+
+static bool
+need_reset (struct cgpu_info *hexminerc)
+{
+  if (no_work)
+    return false;
+  struct hexminerc_info *info = hexminerc->device_data;
+  time_t now = time (NULL);
+  bool ret = false;
+  int i = 0;
+  int secs = 90;
+  while (i < info->asic_count)
+    {
+      if (!info->chip_is_dead[i]
+          && (info->chip_con_resets[i] < 5 && info->matching_work[i])
+          && ((info->last_chip_valid_work[i] + secs) < now))
+        {
+          ret = true;
+          info->chip_con_resets[i]++;
+          info->last_chip_valid_work[i] = now;
+          if (info->chip_con_resets[i] == 5)
+            info->chip_is_dead[i] = true;
+          break;
+        }
+      info->chip_con_resets[i] = 0;
+      i++;
+    }
+  return ret;
+}
+
+static struct cgpu_info *
+hexminerc_detect_one (libusb_device * dev, struct usb_find_devices *found)
+{
+  int asic_count, frequency;
+  struct hexminerc_info *info;
+  struct cgpu_info *hexminerc;
+  bool configured = false;
+  int i = 0;
+  hexminerc = usb_alloc_cgpu (&hexminerc_drv, HEXC_MINER_THREADS);
+  if (!usb_init (hexminerc, dev, found))
+    {
+      usb_uninit (hexminerc);
+      return NULL;
+    }
+  hexminerc->device_data = calloc (sizeof (struct hexminerc_info), 1);
+  if (unlikely (!(hexminerc->device_data)))
+    {
+      hexminerc->device_data = NULL;
+      usb_uninit (hexminerc);
+      return NULL;
+    }
+ 	if (opt_hexminerc_options != NULL)
+  	configured = (sscanf(opt_hexminerc_options, "%d:%d", &asic_count, &frequency) == 2);	
+  if (opt_hexminerc_core_voltage < HEXC_MIN_COREMV
+      || opt_hexminerc_core_voltage > HEXC_MAX_COREMV)
+    {
+      applog (LOG_ERR, "Invalid hexminerc-voltage %d must be %dmV - %dmV",
+              opt_hexminerc_core_voltage, HEXC_MIN_COREMV, HEXC_MAX_COREMV);
+      free (hexminerc->device_data);
+      hexminerc->device_data = NULL;
+      usb_uninit (hexminerc);
+      return NULL;
+    }
+  info = hexminerc->device_data;
+  info->hexworks = calloc (sizeof (struct work *), HEXMINERC_ARRAY_SIZE);
+  if (unlikely (!(info->hexworks)))
+    {
+      free (hexminerc->device_data);
+      hexminerc->device_data = NULL;
+      usb_uninit (hexminerc);
+      return NULL;
+    }
+  info->wr = (struct workc_result *) malloc (sizeof (struct workc_result));
+  info->array_nonce_cache = calloc (16, sizeof (struct chip_resultsc));
+  info->readbuf = calloc (HEXC_HASH_BUF_SIZE, sizeof (unsigned char));
+  info->hash_read_pos = 0;
+  info->hash_write_pos = 0;
+  info->shut_read = false;
+  info->shut_write = false;
+  info->shut_reset = false;
+  info->wr->status = HEXC_STAT_IDLE;
+  info->miner_count = HEXC_DEFAULT_MINER_NUM;
+  info->asic_count = HEXC_DEFAULT_ASIC_NUM;
+  info->frequency = HEXC_DEFAULT_FREQUENCY;
+  info->pic_voltage_readings = HEXC_DEFAULT_CORE_VOLTAGE;
+  info->core_voltage = opt_hexminerc_core_voltage;
+  info->work_block_local = -1;
+info->work_pool_update = -1;
+  info->reset_work = true;
+  info->jobs_to_send = 8;
+  info->roll = 0;
+  info->ht = calloc (sizeof (struct hexminerc_task), 1);
+  info->work = NULL;
+  info->write_pos = 0;
+  if (configured)
+    {
+      info->asic_count = asic_count;
+      info->frequency = frequency;
+    }
+  gettimeofday (&info->last_wr, NULL);
+  info->wr->lastnonceid = 0;
+  info->wsem_ustiming = (int64_t) (0x100000000ll / (16 * info->frequency));
+  while (i < HEXMINERC_ARRAY_SIZE)
+    {
+      info->hexworks[i] = calloc (1, sizeof (struct work));
+      info->hexworks[i]->pool = NULL;
+      i++;
+    } i = 0;
+  info->power_checked = time (NULL);
+  while (i < HEXC_DEFAULT_ASIC_NUM)
+    info->chip_is_dead[i++] = false;
+  libhexc_generatenrange_new ((unsigned char *) &info->nonces_range,
+                              info->asic_count);
+  if (!add_cgpu (hexminerc))
+    {
+      free (info->hexworks);
+      free (hexminerc->device_data);
+      hexminerc->device_data = NULL;
+      hexminerc = usb_free_cgpu (hexminerc);
+      usb_uninit (hexminerc);
+      return NULL;
+    }
+  return hexminerc;
+}
+
+static void
+hexminerc_detect (bool __maybe_unused hotplug)
+{
+  usb_detect (&hexminerc_drv, hexminerc_detect_one);
+}
+
+static void
+do_hexminerc_close (struct thr_info *thr)
+{
+  struct cgpu_info *hexminerc = thr->cgpu;
+  struct hexminerc_info *info = hexminerc->device_data;
+  int i = 0;
+  while (i < HEXMINERC_ARRAY_SIZE)
+    {
+      free_work (info->hexworks[i]);
+      i++;
+    }
+  free (info->hexworks);
+  free (info->readbuf);
+  free (info->array_nonce_cache);
+  free (info->wr);
+  free (info->ht);
+  if (info->work)
+    free_work (info->work);
+}
+
+static void
+hexminerc_shutdown (struct thr_info *thr)
+{
+  struct cgpu_info *hexminerc = thr->cgpu;
+  do_hexminerc_close (thr);
+  usb_nodev (hexminerc);
+}
+
+static bool
+hexminerc_thread_init (struct thr_info *thr)
+{
+  struct cgpu_info *hexminerc = thr->cgpu;
+  struct hexminerc_info *info = hexminerc->device_data;
+  info->thr = thr;
+  cgsleep_ms (100);
+  hexminerc_init_task (info->ht, info);
+  hexminerc_send_task (info->ht, hexminerc);
+  cgsleep_ms (300);
+  return true;
+}
+
+static void
+do_write_hexc (struct thr_info *thr)
+{
+  struct cgpu_info *hexminerc = thr->cgpu;
+  struct hexminerc_info *info = hexminerc->device_data;
+  struct work *tmpwork = NULL;
+  bool power;
+  int send_jobs, ret;
+  int jobs_to_send = info->jobs_to_send;
+  send_jobs = 0;
+  if (time (NULL) - info->power_checked > 30)
+    {
+      info->power_checked = time (NULL);
+      power = need_reset (hexminerc);
+      if (power)
+        {
+          info->b_reset_count++;
+          libhexc_set_word (hexminerc, HEXC_WORKQUEUE_ADR + 80, 0x0004);
+          cgsleep_ms (100);
+          hexminerc_init_task (info->ht, info);
+          hexminerc_send_task (info->ht, hexminerc);
+          cgsleep_ms (300);
+          gettimeofday (&info->last_wr, NULL);
+          info->reset_work = true;
+          jobs_to_send = 8;
+        }
+    }
+  while (!libhexc_usb_dead (hexminerc) && (send_jobs < jobs_to_send))
+    {
+    again:
+      if (!info->work)
+        {
+          info->roll = 0;
+          info->work = get_work (thr, thr->id);
+          info->work->ping = 1;
+        }
+      if (stale_work (info->work, false))
+        {
+          free_work (info->work);
+          info->work = NULL;
+          if (info->work_block_local != work_block || info->work_pool_update != work_pool_update)
+            {
+              info->reset_work = true;
+              send_jobs = 0;
+              jobs_to_send = 8;
+              info->work_block_local = work_block;
+              info->work_pool_update = work_pool_update;
+            }
+          goto again;
+        }
+      if (info->write_pos >= HEXMINERC_ARRAY_SIZE_REAL || info->reset_work)
+        info->write_pos = 0;
+      info->work->subid = info->write_pos;
+      tmpwork = copy_work_noffset_fast_no_id (info->work, info->roll++);
+      hexminerc_create_task (info->reset_work, info->ht, tmpwork);
+      free_work (info->hexworks[info->write_pos]);
+      info->hexworks[info->write_pos] = tmpwork;
+      if (info->work->drv_rolllimit)
+        info->work->drv_rolllimit--;
+      else
+        {
+          free_work (info->work);
+          info->work = NULL;
+        }
+      ret = hexminerc_send_task (info->ht, hexminerc);
+      info->write_pos++;
+      send_jobs++;
+      if (ret == HEXMINERC_TASK_SIZE && info->reset_work)
+        {
+          info->reset_work = false;
+          gettimeofday (&info->last_wr, NULL);
+        }
+    }
+}
+
+static int
+free_buff_space (int cur, int last)
+{
+  int ret = cur - last;
+  if (ret > 0)
+    return ret;
+  ret += 254;
+  return ret;
+}
+
+static int64_t
+hexminerc_scanhash (struct thr_info *thr)
+{
+  struct cgpu_info *hexminerc = thr->cgpu;
+  struct hexminerc_info *info = hexminerc->device_data;
+  uint32_t nonce;
+  int notdupe, found, i, lastchippos = 0;
+  int ret_r = 0;
+  int64_t hash_count = 0;
+  int64_t tdif;
+  int rminder = 0;
+  struct timeval now;
+  struct timeval diff;
+  int free_sp = free_buff_space (info->write_pos, info->wr->lastnonceid);
+  if (info->work_block_local != work_block || info->work_pool_update != work_pool_update)
+    {
+      info->reset_work = true;
+      info->jobs_to_send = 8;
+      info->work_block_local = work_block;
+      info->work_pool_update = work_pool_update;
+      if (info->work)
+        {
+          free_work (info->work);
+          info->work = NULL;
+        }
+      gettimeofday (&info->last_wr, NULL);
+      do_write_hexc (thr);
+      goto done_wr;
+    }
+  gettimeofday (&now, NULL);
+  tdif = timediff (&now, &info->last_wr);
+  info->jobs_to_send = (int) (tdif / info->wsem_ustiming);
+  rminder = (int) (tdif % info->wsem_ustiming);
+  if (info->jobs_to_send > 0 || free_sp < 16)
+    {
+      gettimeofday (&info->last_wr, NULL);
+      if (free_sp > 16)
+        goto done_wr;
+      now.tv_sec = 0;
+      now.tv_usec = rminder;
+      timersub (&info->last_wr, &now, &diff);
+      memcpy (&info->last_wr, &diff, sizeof (struct timeval));
+      if (free_sp < 16)
+        info->jobs_to_send++;
+      if (info->jobs_to_send > 8)
+        info->jobs_to_send = 8;
+      do_write_hexc (thr);
+    }
+done_wr:
+  if (libhexc_usb_dead (hexminerc))
+    {
+      hexminerc->shutdown = true;
+      return -1;
+    }
+  if (info->hash_write_pos + HEXC_USB_R_SIZE > HEXC_HASH_BUF_SIZE_OK)
+    {
+      info->hash_write_pos = info->hash_write_pos - info->hash_read_pos;
+      memcpy (info->readbuf, info->readbuf + info->hash_read_pos,
+              info->hash_write_pos);
+      info->hash_read_pos = 0;
+    }
+  if (info->hash_write_pos - info->hash_read_pos > 7)
+    {
+    again:
+      if (info->work_block_local != work_block || info->work_pool_update != work_pool_update)
+    		goto new_block;
+      ret_r =
+        libhexc_eatHashData (info->wr, info->readbuf, &info->hash_read_pos,
+                             &info->hash_write_pos);
+      if (ret_r > HEXC_BUF_DATA)
+        goto out;
+      if (info->wr->lastnonceid > HEXMINERC_ARRAY_SIZE_REAL)
+        info->wr->lastnonceid = 0;
+      nonce = htole32 (info->wr->lastnonce);
+      i = 0;
+      while (i < info->asic_count)
+        {
+          if (nonce < info->nonces_range[++i])
+            {
+              lastchippos = --i;
+              break;
+            }
+        }
+      if (i == info->asic_count)
+        lastchippos = info->asic_count - 1;
+      notdupe =
+        libhexc_cachenonce (&info->array_nonce_cache[lastchippos], nonce);
+      if (lastchippos > 0)
+        notdupe &= libhexc_cachenonce (&info->array_nonce_cache[0], nonce);
+      if (notdupe)
+        {
+          found =
+            hexminerc_predecode_nonce (hexminerc, thr, nonce,
+                                       info->wr->lastnonceid);
+          if (found > 0)
+            {
+              info->matching_work[lastchippos]++;
+              info->last_chip_valid_work[(uint8_t) lastchippos] = time (NULL);
+              if (hash_count == 0)
+                libhexc_getvoltage (htole16 (info->wr->lastvoltage),
+                                    &info->pic_voltage_readings);
+              hash_count += found;
+            }
+          else
+            inc_hw_errors (thr);
+        }
+      else
+        info->dupe[lastchippos]++;
+    out:
+      if (ret_r == HEXC_BUF_ERR)
+        info->usb_r_errors++;
+      if (ret_r != HEXC_BUF_SKIP)
+        goto again;
+    }
+  if (info->work_block_local != work_block || info->work_pool_update != work_pool_update)
+    		goto new_block;
+  ret_r =
+    libhexc_readHashData (hexminerc, info->readbuf, &info->hash_write_pos,
+                          HEXMINERC_BULK_READ_TIMEOUT);
+  if (ret_r != LIBUSB_SUCCESS)
+    info->usb_bad_reads++;
+  else
+    info->usb_bad_reads = 0;
+  if (info->usb_bad_reads > 20)
+    libhexc_reset (hexminerc);
+  new_block:
+  hash_count = (int64_t) (0xffffffffull * hash_count);
+  if (libhexc_usb_dead (hexminerc))
+    {
+      hexminerc->shutdown = true;
+      return -1;
+    }
+  return hash_count;
+}
+
+static void
+get_hexminerc_statline_before (char *buf, size_t bufsiz,
+                               struct cgpu_info *hexminerc)
+{
+  if (!hexminerc->device_data)
+    return;
+  struct hexminerc_info *info = hexminerc->device_data;
+  tailsprintf (buf, bufsiz, "%3d %4d/%4dmV", info->frequency,
+               info->core_voltage, info->pic_voltage_readings);
+}
+
+extern void suffix_string (uint64_t val, char *buf, size_t bufsiz,
+                           int sigdigits);
+
+static struct api_data *
+hexminerc_api_stats (struct cgpu_info *cgpu)
+{
+  struct api_data *root = NULL;
+  struct timeval now;
+  struct hexminerc_info *info = cgpu->device_data;
+  char displayed_hashes[16], displayed_rolling[16];
+  double dev_runtime, hwp;
+  uint64_t dh64, dr64;
+  int i;
+  if (!info)
+    return NULL;
+  hwp =
+    (cgpu->hw_errors +
+     cgpu->diff1) ? (double) (cgpu->hw_errors) / (double) (cgpu->hw_errors +
+                                                           cgpu->diff1) : 0;
+  if (cgpu->dev_start_tv.tv_sec == 0)
+    dev_runtime = total_secs;
+  else
+    {
+      cgtime (&now);
+      dev_runtime = tdiff (&now, &(cgpu->dev_start_tv));
+    }
+  if (dev_runtime < 1.0)
+    dev_runtime = 1.0;
+  dh64 = (double) cgpu->total_mhashes / dev_runtime * 1000000ull;
+  dr64 = (double) cgpu->rolling * 1000000ull;
+  suffix_string (dh64, displayed_hashes, sizeof (displayed_hashes), 4);
+  suffix_string (dr64, displayed_rolling, sizeof (displayed_rolling), 4);
+  root = api_add_string (root, "MHS 5s", displayed_rolling, true);
+  root = api_add_string (root, "MHS av", displayed_hashes, true);
+  root = api_add_int (root, "Hardware Errors", &(cgpu->hw_errors), true);
+  root = api_add_percent (root, "Hardware Errors%", &hwp, true);
+  root = api_add_int (root, "USB Read Errors", &(info->usb_r_errors), true);
+  root = api_add_int (root, "USB Write Errors", &(info->usb_w_errors), true);
+  root =
+    api_add_int (root, "USB Reset Count", &(info->usb_reset_count), true);
+  root =
+    api_add_int (root, "Miner Reset Count", &(info->b_reset_count), true);
+  root =
+    api_add_time (root, "Last Share Time", &(cgpu->last_share_pool_time),
+                  true);
+  root = api_add_int (root, "Chip Count", &(info->asic_count), true);
+  root = api_add_int (root, "Frequency", &(info->frequency), true);
+  root = api_add_int (root, "Core Voltage", &(info->core_voltage), true);
+  root =
+    api_add_int (root, "PIC Voltage Readings", &(info->pic_voltage_readings),
+                 true);
+  for (i = 0; i < info->asic_count; i++)
+    {
+      /*~ */
+      char mcw[24];
+      /*~ */
+      sprintf (mcw, "Chip%d Nonces", i + 1);
+      root = api_add_int (root, mcw, &(info->matching_work[i]), true);
+      sprintf (mcw, "Chip%d Dupes", i + 1);
+      root = api_add_int (root, mcw, &(info->dupe[i]), true);
+    }
+  return root;
+}
+
+struct device_drv hexminerc_drv = {
+  .drv_id = DRIVER_hexminerc,
+  .dname = "hexminerc",
+  .name = "HEXc",
+  .thread_init = hexminerc_thread_init,
+  .drv_detect = hexminerc_detect,
+  .hash_work = hash_driver_work,
+  .scanwork = hexminerc_scanhash,
+  .get_api_stats = hexminerc_api_stats,
+  .get_statline_before = get_hexminerc_statline_before,
+  .thread_shutdown = hexminerc_shutdown,
+};
--- cg_o/driver-hexminerc.h	1970-01-01 02:00:00.000000000 +0200
+++ cgminer_hex/driver-hexminerc.h	2014-09-22 19:28:38.671387123 +0300
@@ -0,0 +1,144 @@
+/*$T indentinput.h GC 1.140 10/16/13 10:20:01 */
+#ifndef HEXC_H
+#define HEXC_H
+#ifdef USE_HEXMINERC
+#include "util.h"
+#define HEXC_USB_WR_TIME_OUT 500
+#define HEXMINERC_BULK_READ_TIMEOUT 1000
+#define HEXC_USB_R_SIZE 64
+
+/* hexminerc_task/work_reply status Definitions: */
+#define HEXC_STAT_IDLE 0        /* Idle or data already Sent to the buffer */
+#define HEXC_STAT_NEW_WORK 1    /* Request for write in the buffer */
+#define HEXC_STAT_WAITING 2     /* Wait For Buffer Empty Position */
+#define HEXC_STAT_CLR_BUFF 3    /* Force Buffer Empty */
+#define HEXC_STAT_STOP_REQ 4    /* Stop Request */
+#define HEXC_STAT_NEW_WORK_CLEAR_OLD 5  /* Clear Buffers and after that fill the first buffer */
+#define HEXC_STAT_UNUSED 6
+
+/* libhexc_eatHashData/BUF_reply status Definitions: */
+#define HEXC_BUF_DATA 0
+#define HEXC_BUF_ERR 1
+#define HEXC_BUF_SKIP 2
+
+/*MISC*/
+#define HEXC_DEFAULT_XCLKIN_CLOCK 32    /* In MHz */
+#define HEXC_CLOCK_LOW_CFG 0x00030017
+#define HEXC_CLOCK_HIGH_CFG (0x0000002e << 3)   /* = 0x00000170 */
+#define HEXMINERC_ARRAY_PIC_SIZE 64
+#define HEXMINERC_ARRAY_SIZE HEXMINERC_ARRAY_PIC_SIZE * 4
+#define HEXMINERC_ARRAY_SIZE_REAL HEXMINERC_ARRAY_SIZE - 2
+#define HEXC_NONCE_CASH_SIZE 6
+#define HEXMINERC_WORK_FACTOR 0.9
+#define HEXC_USB_WR_SIZE 64
+#define HEXC_HASH_BUF_SIZE 512
+#define HEXC_HASH_BUF_SIZE_OK HEXC_HASH_BUF_SIZE - 4
+#define HEXC_MINER_THREADS 1
+#define HEXC_DEFAULT_MINER_NUM 0x01
+#define HEXC_DEFAULT_ASIC_NUM 0x10
+#define HEXC_MIN_FREQUENCY 100
+#define HEXC_MAX_FREQUENCY 2500
+#define HEXC_DEFAULT_FREQUENCY 1500
+#define HEXC_DEFAULT_CORE_VOLTAGE 1100  /* in millivolts */
+#define HEXC_MIN_COREMV 100 /* in millivolts */ /* Do not touch it!!! 1.6V is above the chip specs already */
+#define HEXC_MAX_COREMV 1630    /* in millivolts */
+
+struct chip_resultsc
+{
+  uint8_t nonce_cache_write_pos;
+  uint32_t nonces[HEXC_NONCE_CASH_SIZE];
+};
+struct workc_result
+{
+  uint8_t startbyte;
+  uint8_t datalength;
+  uint8_t command;
+  uint16_t address;
+  uint32_t lastnonce;
+  uint8_t lastnonceid;
+  uint8_t status;
+  uint16_t lastvoltage;
+  uint16_t lasttemperature;
+  uint16_t lastfanrpm;
+  uint8_t csum;
+  uint8_t pad[2];
+} __attribute__ ((packed, aligned (4)));
+struct hexminerc_task
+{
+  uint8_t startbyte;
+  uint8_t datalength;
+  uint8_t command;
+  uint16_t address;
+  uint32_t clockcfg[2];
+  uint32_t merkle[3];
+  uint32_t a1;
+  uint32_t a0;
+  uint32_t e2;
+  uint32_t e1;
+  uint32_t e0;
+  uint8_t midstate[32];
+  uint32_t a2;
+  uint32_t startnonce;
+  uint8_t id;
+  uint8_t status;
+  uint16_t hashclock;
+  uint16_t chipcount;
+  uint16_t refvoltage;
+  uint16_t reftemperature;
+  uint16_t reffanrpm;
+  uint8_t csum;
+  uint8_t pad[2];
+} __attribute__ ((packed, aligned (4)));
+struct hexminerc_info
+{
+  struct timeval last_wr;
+  int jobs_to_send;
+  int64_t wsem_ustiming;
+  bool reset_work;
+  int usb_bad_reads;
+  int write_pos;
+  int roll;
+  int miner_count;
+  int asic_count;
+  int core_voltage;
+  int frequency;
+  int hash_read_pos;
+  int hash_write_pos;
+  int usb_r_errors;
+  int usb_w_errors;
+  int usb_reset_count;
+  int b_reset_count;
+  int pic_voltage_readings;
+  bool shut_read;
+  bool shut_write;
+  bool shut_reset;
+  int dupe[HEXC_DEFAULT_ASIC_NUM];
+  int matching_work[HEXC_DEFAULT_ASIC_NUM];
+  int chip_con_resets[16];
+  bool chip_is_dead[16];
+  time_t last_chip_valid_work[HEXC_DEFAULT_ASIC_NUM];
+  time_t power_checked;
+  unsigned char *readbuf;
+  struct workc_result *wr;
+  struct chip_resultsc *array_nonce_cache;
+  uint32_t nonces_range[HEXC_DEFAULT_ASIC_NUM];
+  struct thr_info *thr;
+  struct work **hexworks;
+  struct hexminerc_task *ht;
+  struct work *work;
+  unsigned int work_block_local;
+  unsigned int work_pool_update;
+};
+
+#define HEXC_WORKANSWER_ADR 0x3000
+#define HEXC_WORKQUEUE_ADR 0x4000
+#define HEXC_PTCON_ADR 0x0C00
+#define HEXC_START_STOP_ADR 0x646E
+#define HEXMINERC_TASK_SIZE (sizeof(struct hexminerc_task)-2)
+#define HEXC_MAX_WORK_SIZE (sizeof(struct workc_result) - 2)
+#define HEXC_BASE_WORK_SIZE 6
+extern int opt_hexminerc_core_voltage;
+extern struct hexminerc_info **hexminerc_info;
+
+#endif /* USE_HEXMINERC */
+#endif /* HEXC_H */
--- cg_o/libhexc.c	1970-01-01 02:00:00.000000000 +0200
+++ cgminer_hex/libhexc.c	2014-09-22 19:28:38.671387123 +0300
@@ -0,0 +1,295 @@
+/*$T indentinput.c GC 1.140 10/16/13 10:20:34 */
+#define rotate(x, y)	((x << y) | (x >> (sizeof(x) * 8 - y)))
+#define rotr(x, y)		((x >> y) | (x << (sizeof(x) * 8 - y)))
+#define R(a, b, c, d, e, f, g, h, w, k) \
+		h = h + \
+		(rotate(e, 26) ^ rotate(e, 21) ^ rotate(e, 7)) + \
+		(g ^ (e & (f ^ g))) + \
+		k + \
+		w; \
+	d = d + h; \
+	h = h + (rotate(a, 30) ^ rotate(a, 19) ^ rotate(a, 10)) + ((a & b) | (c & (a | b)))
+const uint32_t SHA256_KC[3] = { 0x428a2f98, 0x71374491, 0xb5c0fbcf };
+
+static int64_t
+timediff (const struct timeval *a, const struct timeval *b)
+{
+  struct timeval diff;
+  timersub (a, b, &diff);
+  return diff.tv_sec * 1000000 + diff.tv_usec;
+}
+
+static bool
+libhexc_cachenonce (struct chip_resultsc *nonce_cache, uint32_t nonce)
+{
+  int i = 0;
+  while (i < HEXC_NONCE_CASH_SIZE && nonce_cache->nonces[i] != nonce)
+    i++;
+  if (i < HEXC_NONCE_CASH_SIZE)
+    return false;
+  if (nonce_cache->nonce_cache_write_pos == HEXC_NONCE_CASH_SIZE)
+    nonce_cache->nonce_cache_write_pos = 0;
+  nonce_cache->nonces[nonce_cache->nonce_cache_write_pos++] = nonce;
+  return true;
+}
+
+static void
+libhexc_generatenrange_new (unsigned char *buf, int asic_num)
+{
+  uint32_t nonceAdd;
+  int noncePos;
+  int64_t nonceCalc = 0x100000000ll;
+  nonceCalc /= asic_num;
+  nonceAdd = (uint32_t) nonceCalc;
+  uint32_t chip_noce;
+  for (noncePos = 0; noncePos < asic_num; noncePos++)
+    {                           /* * chip_noce = htole32(noncePos * nonceAdd);
+                                 */
+      chip_noce = noncePos * nonceAdd;
+      memcpy (buf + noncePos * 4, &chip_noce, 4);
+    }
+}
+
+static void
+libhexc_calc_hexminer (struct work *work, struct hexminerc_task *ht)
+{
+  uint32_t a0a1a2e0e1e2[6];
+  uint32_t A, B, C, D, E, F, G, H;
+  uint32_t state[8];
+  uint32_t data[3];
+  memcpy (&state, work->midstate, 32);
+  memcpy (&data, work->data + 64, 12);
+
+#if defined(__BIG_ENDIAN__) || defined(MIPSEB)
+int i;
+  for (i = 0; i < 8; i++)
+    state[i] = htole32 (state[i]);
+  for (i = 0; i < 3; i++)
+    data[i] = htole32 (data[i]);
+
+#endif
+ A = state[0]; 
+  B = state[1];
+  C = state[2];
+  D = state[3];
+  E = state[4];
+  F = state[5];
+  G = state[6];
+  H = state[7];
+  R (A, B, C, D, E, F, G, H, data[0], SHA256_KC[0]);
+  a0a1a2e0e1e2[0] = htole32 (H);
+  a0a1a2e0e1e2[3] = htole32 (D);
+  R (H, A, B, C, D, E, F, G, data[1], SHA256_KC[1]);
+  a0a1a2e0e1e2[1] = htole32 (G);
+  a0a1a2e0e1e2[4] = htole32 (C);
+  R (G, H, A, B, C, D, E, F, data[2], SHA256_KC[2]);
+  a0a1a2e0e1e2[2] = htole32 (F);
+  a0a1a2e0e1e2[5] = htole32 (B);
+  memcpy (&ht->a0, &a0a1a2e0e1e2[0], 4);
+  memcpy (&ht->a1, &a0a1a2e0e1e2[1], 4);
+  memcpy (&ht->a2, &a0a1a2e0e1e2[2], 4);
+  memcpy (&ht->e0, &a0a1a2e0e1e2[3], 4);
+  memcpy (&ht->e1, &a0a1a2e0e1e2[4], 4);
+  memcpy (&ht->e2, &a0a1a2e0e1e2[5], 4);
+}
+
+static void
+libhexc_generateclk (uint16_t HashClock, uint16_t XCLKIN, uint32_t * res)
+{
+  uint32_t configL = 0;
+  uint32_t configH = 0;
+  int RValue = XCLKIN;
+  int NValue = (HashClock * 2 * RValue / XCLKIN);
+  configL =
+    ((uint32_t) RValue << 29) | ((uint32_t) NValue << 18) |
+    HEXC_CLOCK_LOW_CFG;
+  configH = ((uint32_t) RValue >> 3) | HEXC_CLOCK_HIGH_CFG;
+  res[0] = htole32 (configL);
+  res[1] = htole32 (configH);
+}
+
+static void
+libhexc_csum (unsigned char *startptr, unsigned char *endptr,
+              unsigned char *resptr)
+{
+  unsigned char *b = startptr;
+  uint8_t sum = 0;
+  while (b < endptr)
+    sum += *b++;
+  memcpy (resptr, &sum, 1);
+}
+
+static bool
+libhexc_usb_dead (struct cgpu_info *hexminerc)
+{
+  struct cg_usb_device *usbdev;
+  struct hexminerc_info *info = hexminerc->device_data;
+  if (!info)
+    return true;
+  usbdev = hexminerc->usbdev;
+  bool ret = (usbdev == NULL || usbdev->handle == NULL || hexminerc->shutdown
+              || info->shut_read || info->shut_write || info->shut_reset
+              || hexminerc->usbinfo.nodev || hexminerc->deven != DEV_ENABLED);
+  return ret;
+}
+
+static int
+libhexc_sendHashData (struct cgpu_info *hexminerc, unsigned char *sendbuf,
+                      size_t buf_len)
+{
+  struct hexminerc_info *info = hexminerc->device_data;
+  struct cg_usb_device *usbdev;
+  int wrote = 0, written = 0;
+  int err = LIBUSB_SUCCESS;
+  usbdev = hexminerc->usbdev;
+  if (libhexc_usb_dead (hexminerc))
+    goto out;
+  while (written < buf_len && err == LIBUSB_SUCCESS)
+    {
+      err =
+        libusb_bulk_transfer (usbdev->handle, 0x02, sendbuf + written,
+                              MIN (HEXC_USB_WR_SIZE, buf_len - written),
+                              &wrote, HEXC_USB_WR_TIME_OUT);
+      if (err == LIBUSB_SUCCESS)
+        written += wrote;
+    }
+out:
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+    info->shut_write = true;
+  return written;
+}
+
+static void
+libhexc_reset (struct cgpu_info *hexminerc)
+{
+  struct hexminerc_info *info = hexminerc->device_data;
+  struct cg_usb_device *usbdev;
+  int err = LIBUSB_SUCCESS;
+  usbdev = hexminerc->usbdev;
+  if (libhexc_usb_dead (hexminerc))
+    goto out;
+  err = libusb_reset_device (usbdev->handle);
+out:
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+    info->shut_reset = true;
+  info->usb_reset_count++;
+}
+
+static int
+libhexc_readHashData (struct cgpu_info *hexminerc, unsigned char *hash,
+                      int *hash_write_pos, int timeout)
+{
+  struct hexminerc_info *info = hexminerc->device_data;
+  struct cg_usb_device *usbdev;
+  int read = 0;
+  int err = LIBUSB_SUCCESS;
+  usbdev = hexminerc->usbdev;
+  if (libhexc_usb_dead (hexminerc))
+    goto out;
+  err =
+    libusb_bulk_transfer (usbdev->handle, 0x82, hash + *hash_write_pos,
+                          HEXC_USB_R_SIZE, &read, timeout);
+  if (err == LIBUSB_SUCCESS)
+    *hash_write_pos += MIN (read, HEXC_USB_R_SIZE);
+out:
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+      info->shut_read = true;
+  return err;
+}
+
+extern bool submit_tested_work_fast_clone (struct thr_info *thr,
+                                           struct work *work, bool diff1);
+
+static int
+hexminerc_predecode_nonce (struct cgpu_info *hexminerc, struct thr_info *thr,
+                           uint32_t nonce, uint8_t work_id)
+{
+  struct hexminerc_info *info = hexminerc->device_data;
+  if (info->hexworks[work_id]->pool == NULL)
+      return 0;
+  if (test_nonce (info->hexworks[work_id], nonce))
+    {
+      submit_tested_work_fast_clone (thr, info->hexworks[work_id], true);
+      return 1;
+    }
+  return 0;
+}
+
+static void
+libhexc_getvoltage (uint16_t wr_bukvoltage, int *info_pic_voltage_readings)
+{
+  float voltagehuman;
+  voltagehuman =
+    (float) ((float) wr_bukvoltage * (float) 1000 * (float) 3.3 /
+             ((1 << 12) - 1));
+  *info_pic_voltage_readings = (int) voltagehuman;
+}
+
+static void
+libhexc_setvoltage (int info_voltage, uint16_t * refvoltage)
+{
+  uint16_t voltageadc;
+  voltageadc =
+    (uint16_t) ((float) info_voltage / (float) 1000 / (float) 3.3 *
+                ((1 << 12) - 1));
+  *refvoltage = htole16 (voltageadc);
+}
+
+static int
+libhexc_eatHashData (struct workc_result *wr, unsigned char *hash,
+                     int *hash_read_pos, int *hash_write_pos)
+{
+  uint8_t psum;
+  int wrpos;
+  unsigned char *csum_pos;
+  bool ok;
+  int places = 0;
+eat:
+  while (*hash_read_pos < *hash_write_pos && hash[*hash_read_pos] != 0x53)
+    *hash_read_pos += 1;
+  places = *hash_write_pos - *hash_read_pos;
+  if (places < 8)
+    return HEXC_BUF_SKIP;
+  memcpy ((char *) &wr->startbyte, &hash[*hash_read_pos],
+          HEXC_BASE_WORK_SIZE - 1);
+  wr->address = htole16 (wr->address);
+  ok = (wr->command == 0x52)
+    && ((wr->address == HEXC_WORKANSWER_ADR && wr->datalength == 0x06));
+  if (!ok)
+    {
+      *hash_read_pos += 1;
+      goto eat;
+    }
+  if (places < HEXC_BASE_WORK_SIZE + wr->datalength * 2)
+    return HEXC_BUF_SKIP;
+  csum_pos =
+    hash + *hash_read_pos + HEXC_BASE_WORK_SIZE + wr->datalength * 2 - 1;
+  libhexc_csum (hash + *hash_read_pos, csum_pos, &psum);
+  if (psum != *csum_pos)
+    {
+      *hash_read_pos += 1;
+      return HEXC_BUF_ERR;
+    }
+  wrpos = (wr->address - HEXC_WORKANSWER_ADR) + HEXC_BASE_WORK_SIZE - 1;
+  memcpy ((char *) &wr->startbyte + wrpos,
+          &hash[*hash_read_pos + HEXC_BASE_WORK_SIZE - 1],
+          wr->datalength * 2);
+  *hash_read_pos += HEXC_BASE_WORK_SIZE + wr->datalength * 2;
+  return HEXC_BUF_DATA;
+}
+
+static void
+libhexc_set_word (struct cgpu_info *hexminerc, uint16_t address,
+                  uint16_t word)
+{
+  unsigned char status[10];
+  uint16_t wr_adr = htole16 (address);
+  uint16_t ledata = htole16 (word);
+  status[0] = 0x53;
+  status[1] = 0x01;
+  status[2] = 0x57;
+  memcpy (status + 3, &wr_adr, 2);
+  memcpy (status + 5, &ledata, 2);
+  libhexc_csum (status, status + 7, status + 7);
+  libhexc_sendHashData (hexminerc, status, 8);
+}
--- cg_o/driver-hexmineru.c	1970-01-01 02:00:00.000000000 +0200
+++ cgminer_hex/driver-hexmineru.c	2014-09-22 19:28:38.671387123 +0300
@@ -0,0 +1,358 @@
+/*$T indentinput.c GC 1.140 10/16/13 10:19:47 */
+#include "config.h"
+#include <limits.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <ctype.h>
+#include <dirent.h>
+#include <unistd.h>
+#ifndef WIN32
+#include <sys/select.h>
+#include <termios.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#ifndef O_CLOEXEC
+#define O_CLOEXEC 0
+#endif
+#else
+#include "compat.h"
+#include <windows.h>
+#include <io.h>
+#endif
+#include "elist.h"
+#include "miner.h"
+#include "usbutils.h"
+#include "driver-hexmineru.h"
+#include "util.h"
+extern struct work *copy_work_noffset_fast_no_id (struct work *base_work,
+                                                  int noffset);
+extern bool stale_work (struct work *work, bool share);
+struct device_drv hexmineru_drv;
+int opt_hexmineru_core_freq = 54;
+#include "libhexu.c"
+#include "lib_mcp2210_hexu.c"
+extern unsigned int work_block;
+extern unsigned int work_pool_update;
+
+static inline void
+hexmineru_create_task (uint32_t * vec, struct hexmineru_task *ht,
+                       struct work *work)
+{
+  libhexu_work_to_bitfury_payload (ht, work);
+  libhexu_bitfury_payload_to_atrvec (vec, ht);
+}
+
+static struct cgpu_info *
+hexmineru_detect_one (libusb_device * dev, struct usb_find_devices *found)
+{
+  struct hexmineru_info *info;
+  struct cgpu_info *hexmineru;
+  unsigned char buf[1024];
+  unsigned char trash[1024];
+  uint64_t freq;
+  const uint8_t *osc6 = (unsigned char *) &freq;
+  int i = 0;
+  hexmineru = usb_alloc_cgpu (&hexmineru_drv, HEXU_MINER_THREADS);
+  if (!usb_init (hexmineru, dev, found))
+    {
+      usb_uninit (hexmineru);
+      return NULL;
+    }
+  hexmineru->device_data = calloc (sizeof (struct hexmineru_info), 1);
+  if (unlikely (!(hexmineru->device_data)))
+    {
+      hexmineru->device_data = NULL;
+      usb_uninit (hexmineru);
+      return NULL;
+    }
+  info = hexmineru->device_data;
+  info->hexworks = calloc (sizeof (struct work *), HEXMINERU_ARRAY_SIZE);
+  if (unlikely (!(info->hexworks)))
+    {
+      free (hexmineru->device_data);
+      hexmineru->device_data = NULL;
+      usb_uninit (hexmineru);
+      return NULL;
+    }
+  info->spipos = 0;
+  info->job_switch = true;
+  info->shut_read = false;
+  info->shut_write = false;
+  info->work = NULL;
+  info->c_job_id = 0;
+  info->l_job_id = 0;
+  info->work_block = -1;
+  info->work_pool_update = -1;
+  info->array_nonce_cache = calloc (1, sizeof (struct chip_resultsu));
+  info->buf_switch = 0xffffffff;
+  info->spipos = 0;
+  info->read_pos = 0;
+  info->frequency = (uint8_t) HEXU_DEFAULT_FREQUENCY;
+  if (opt_hexmineru_core_freq > HEXU_MIN_FREQUENCY
+      && opt_hexmineru_core_freq < HEXU_MAX_FREQUENCY)
+    {
+      info->frequency = (uint8_t) opt_hexmineru_core_freq;
+    }
+  if (!add_cgpu (hexmineru))
+    goto out;
+  if (!libhexu_mcp2210_get_configs (hexmineru))
+    goto out;
+  if (!hex_nanofury_checkport (hexmineru))
+    goto out;
+  freq = htole64 ((1ULL << info->frequency) - 1ULL);
+  libhexu_spi_emit_break (&info->spipos, (unsigned char *) buf);
+  libhexu_spi_emit_data (&info->spipos, (unsigned char *) buf, 0x6000, osc6,
+                         8);
+  libhexu_spi_send_conf (&info->spipos, (unsigned char *) buf);
+  libhexu_spi_send_init (&info->spipos, (unsigned char *) buf);
+  libhexu_nanofury_spi_reset (hexmineru);
+  if (!libhexu_nanofury_spi_txrx
+      (hexmineru, &info->spipos, (unsigned char *) buf,
+       (unsigned char *) trash, true))
+    goto out;
+  i = 0;
+  while (i < HEXMINERU_ARRAY_SIZE)
+    {
+      info->hexworks[i] = calloc (1, sizeof (struct work));
+      info->hexworks[i]->pool = NULL;
+      i++;
+    } info->spipos = 0;
+  libhexu_spi_emit_break (&info->spipos, (unsigned char *) info->wr_spi);
+  return hexmineru;
+out:
+  free (info->hexworks);
+  free (hexmineru->device_data);
+  hexmineru->device_data = NULL;
+  hexmineru = usb_free_cgpu (hexmineru);
+  usb_uninit (hexmineru);
+  return NULL;
+}
+
+static void
+hexmineru_detect (bool __maybe_unused hotplug)
+{
+  usb_detect (&hexmineru_drv, hexmineru_detect_one);
+}
+
+static void
+do_hexmineru_close (struct thr_info *thr)
+{
+  struct cgpu_info *hexmineru = thr->cgpu;
+  struct hexmineru_info *info = hexmineru->device_data;
+  int i = 0;
+  cgsem_destroy (&info->qsem);
+  while (i < HEXMINERU_ARRAY_SIZE)
+    {
+      free_work (info->hexworks[i]);
+      i++;
+    }
+  free (info->hexworks);
+  free (info->array_nonce_cache);
+}
+
+static void
+hexmineru_shutdown (struct thr_info *thr)
+{
+  struct cgpu_info *hexmineru = thr->cgpu;
+  do_hexmineru_close (thr);
+  usb_nodev (hexmineru);
+}
+
+static bool
+hexmineru_thread_init (struct thr_info *thr)
+{
+  struct cgpu_info *hexmineru = thr->cgpu;
+  struct hexmineru_info *info = hexmineru->device_data;
+  cgsem_init (&info->qsem);
+  return true;
+}
+
+static int64_t
+hexmineru_scanhash (struct thr_info *thr)
+{
+  struct cgpu_info *hexmineru = thr->cgpu;
+  struct hexmineru_info *info = hexmineru->device_data;
+  bool reset_work = false;
+  int64_t hash_count = 0;
+  if (libhexu_usb_dead (hexmineru))
+    {
+      return -1;
+      hexmineru->shutdown = true;
+    }
+  struct hexmineru_task ht;
+  uint32_t nonce;
+  int i, found, c_found;
+again:
+  if (!info->work)
+    {
+      info->roll = 0;
+      info->work = get_work (thr, thr->id);
+      info->work->ping = 1;
+      if (work_block != info->work_block || info->work_pool_update != work_pool_update)
+        {
+          reset_work = true;
+          info->work_block = work_block;
+          info->work_pool_update = work_pool_update;
+        }
+    }
+  if (stale_work (info->work, false))
+    {
+      free_work (info->work);
+      info->work = NULL;
+      goto again;
+    }
+  if (info->job_switch || reset_work)
+    {
+      info->spipos = 1;
+      info->l_job_id = info->c_job_id;
+      info->c_job_id = info->read_pos;
+      free_work (info->hexworks[info->read_pos]);
+      info->hexworks[info->read_pos] =
+        copy_work_noffset_fast_no_id (info->work, info->roll++);
+      hexmineru_create_task (&info->atrvecs[info->read_pos][0], &ht,
+                             info->hexworks[info->read_pos]);
+      memcpy (&info->atrvec[0], &info->atrvecs[info->read_pos][0], 76);
+      info->read_pos++;
+      if (info->read_pos >= HEXMINERU_ARRAY_SIZE_REAL)
+        info->read_pos = 0;
+      libhexu_spi_emit_data (&info->spipos, (unsigned char *) info->wr_spi,
+                             0x3000, &info->atrvec[0], 76);
+      if (info->work->drv_rolllimit)
+          info->work->drv_rolllimit--;
+      else
+        {
+          free_work (info->work);
+          info->work = NULL;
+        }
+    }
+  if (libhexu_nanofury_spi_txrx
+      (hexmineru, &info->spipos, (unsigned char *) info->wr_spi,
+       (unsigned char *) info->read_spi, false))
+    {
+      if (info->read_spi[17] == info->buf_switch)
+          info->job_switch = false;
+      else
+        {
+          info->job_switch = true;
+          info->buf_switch = info->read_spi[17];
+        }                       /*Skip first and last - only crap there */
+      found = 0;
+      for (i = 1; i < 17; i++)
+        {
+          if (libhexu_cachenonce
+              (&info->array_nonce_cache[0], info->read_spi[i]))
+            {
+#if defined(__BIG_ENDIAN__) || defined(MIPSEB)
+              nonce = libhexu_decnonce (htole32 (info->read_spi[i]));
+#else
+              nonce = libhexu_decnonce (info->read_spi[i]);
+#endif
+              c_found = 0;
+              c_found +=
+                hexmineru_predecode_nonce (hexmineru, thr, nonce,
+                                           info->c_job_id);
+              if (c_found == 0 && info->c_job_id != info->l_job_id)
+                c_found +=
+                  hexmineru_predecode_nonce (hexmineru, thr, nonce,
+                                             info->l_job_id);
+              found += c_found;
+            }
+          else
+              info->dupe[0]++;
+        }
+      if (found > 0)
+          hash_count += found;
+    }
+  else
+      info->shut_read = true;
+  info->spipos = 80;
+  hash_count = (int64_t) (0xffffffffull * hash_count);
+  if (libhexu_usb_dead (hexmineru))
+    {
+      hexmineru->shutdown = true;
+      return -1;
+    }
+  cgsem_mswait (&info->qsem, 40);
+  return hash_count;
+}
+
+static void
+get_hexmineru_statline_before (char *buf, size_t bufsiz,
+                               struct cgpu_info *hexmineru)
+{
+  if (!hexmineru->device_data)
+    return;
+  struct hexmineru_info *info = hexmineru->device_data;
+  tailsprintf (buf, bufsiz, "%3d %4d/%4dmV", info->frequency, 0, 0);
+}
+
+extern void suffix_string (uint64_t val, char *buf, size_t bufsiz,
+                             int sigdigits);
+                             
+static struct api_data *
+hexmineru_api_stats (struct cgpu_info *cgpu)
+{
+  struct api_data *root = NULL;
+  struct timeval now;
+  struct hexmineru_info *info = cgpu->device_data;
+  char displayed_hashes[16], displayed_rolling[16];
+  double dev_runtime, hwp;
+  uint64_t dh64, dr64;
+  if (!info)
+    return NULL;
+  hwp =
+    (cgpu->hw_errors +
+     cgpu->diff1) ? (double) (cgpu->hw_errors) / (double) (cgpu->hw_errors +
+                                                           cgpu->diff1) : 0;
+  if (cgpu->dev_start_tv.tv_sec == 0)
+    dev_runtime = total_secs;
+  else
+    {
+      cgtime (&now);
+      dev_runtime = tdiff (&now, &(cgpu->dev_start_tv));
+    }
+  if (dev_runtime < 1.0)
+    dev_runtime = 1.0;
+  dh64 = (double) cgpu->total_mhashes / dev_runtime * 1000000ull;
+  dr64 = (double) cgpu->rolling * 1000000ull;
+  suffix_string (dh64, displayed_hashes, sizeof (displayed_hashes), 4);
+  suffix_string (dr64, displayed_rolling, sizeof (displayed_rolling), 4);
+  root = api_add_string (root, "MHS 5s", displayed_rolling, true);
+  root = api_add_string (root, "MHS av", displayed_hashes, true);
+  root = api_add_int (root, "Hardware Errors", &(cgpu->hw_errors), true);
+  root = api_add_percent (root, "Hardware Errors%", &hwp, true);
+  root = api_add_int (root, "Reset Count", &(info->dev_reset_count), true);
+  root =
+    api_add_time (root, "Last Share Time", &(cgpu->last_share_pool_time),
+                  true);
+  root = api_add_uint8 (root, "Frequency", &(info->frequency), true);
+  char mcw[24];
+  sprintf (mcw, "Chip1 Dupes");
+  root = api_add_int (root, mcw, &(info->dupe[0]), true);
+  return root;
+}
+
+static void
+hexmineru_flush_work (struct cgpu_info *hexmineru)
+{
+  struct hexmineru_info *info = hexmineru->device_data;
+  if (libhexu_usb_dead (hexmineru))
+    return;
+  cgsem_post (&info->qsem);
+}
+
+struct device_drv hexmineru_drv = {
+  .drv_id = DRIVER_hexmineru,
+  .dname = "hexmineru",
+  .name = "HEXu",
+  .drv_detect = hexmineru_detect,
+  .thread_init = hexmineru_thread_init,
+  .hash_work = hash_driver_work,
+  .scanwork = hexmineru_scanhash,
+  .flush_work = hexmineru_flush_work,
+  .get_api_stats = hexmineru_api_stats,
+  .get_statline_before = get_hexmineru_statline_before,
+  .thread_shutdown = hexmineru_shutdown,
+};
--- cg_o/driver-hexmineru.h	1970-01-01 02:00:00.000000000 +0200
+++ cgminer_hex/driver-hexmineru.h	2014-09-22 19:28:38.671387123 +0300
@@ -0,0 +1,68 @@
+/*$T indentinput.h GC 1.140 10/16/13 10:20:01 */
+#ifndef HEXU_H
+#define HEXU_H
+#ifdef USE_HEXMINERU
+#include "util.h"
+enum mcp2210_gpio_value
+{ MGV_LOW, MGV_HIGH, MGV_ERROR, };
+#define NANOFURY_GP_PIN_LED 0
+#define NANOFURY_GP_PIN_SCK_OVR 5
+#define NANOFURY_GP_PIN_PWR_EN 6
+#define NANOFURY_MAX_BYTES_PER_SPI_TRANSFER 60  // due to MCP2210 limitation
+#define HEXMINERU_ARRAY_SIZE 9
+#define HEXMINERU_ARRAY_SIZE_REAL HEXMINERU_ARRAY_SIZE - 2
+#define HEXU_NONCE_CASH_SIZE 256
+#define HEXMINERU_PUSH_THRESH 2 /* At least 2 queued works available to be written to PIC */
+#define HEXMINERU_ARRAY_MAX_POP 1
+#define HEXU_USB_R_SIZE 64
+#define HEXU_USB_WR_SIZE 64
+#define HEXU_HASH_BUF_SIZE 1024
+#define HEXU_MINER_THREADS 1
+#define HEXU_MIN_FREQUENCY 0    //Bits
+#define HEXU_MAX_FREQUENCY 64   //Bits
+#define HEXU_DEFAULT_FREQUENCY 54       //Bits Stable which works 2.5 GHs for 1 chip
+#define HEXU_DEFAULT_CORE_VOLTAGE 0     /* in millivolts */
+struct chip_resultsu
+{
+  uint8_t nonce_cache_write_pos;
+  uint32_t nonces[HEXU_NONCE_CASH_SIZE];
+};
+struct hexmineru_info
+{
+  uint8_t frequency;
+  uint8_t ltsz;
+  int dev_reset_count;
+  int dupe[1];
+  int roll;
+  struct thr_info *thr;
+  struct work **hexworks;
+  unsigned char wr_spi[80];
+  uint32_t read_spi[256];
+  uint32_t atrvecs[HEXMINERU_ARRAY_SIZE][19];
+  struct chip_resultsu *array_nonce_cache;
+  uint32_t buf_switch;
+  size_t spipos;
+  uint32_t atrvec[19];
+  bool job_switch;
+  bool shut_read;
+  bool shut_write;
+  struct work *work;
+  unsigned int work_block;
+  unsigned int work_pool_update;
+  int c_job_id;
+  int l_job_id;
+  int read_pos;
+  cgsem_t qsem;
+};
+struct hexmineru_task
+{
+  unsigned char midstate[32];
+  unsigned int junk[8];
+  unsigned m7;
+  unsigned ntime;
+  unsigned nbits;
+} __attribute__ ((packed, aligned (4)));
+extern int opt_hexmineru_core_freq;
+#define HEXMINERU_TASK_SIZE (sizeof(struct hexmineru_task)) extern struct hexmineru_info **hexmineru_info;
+#endif /* USE_HEXMINERU */
+#endif /* HEXU_H */
--- cg_o/libhexu.c	1970-01-01 02:00:00.000000000 +0200
+++ cgminer_hex/libhexu.c	2014-09-22 19:28:38.671387123 +0300
@@ -0,0 +1,223 @@
+/*$T indentinput.c GC 1.140 10/16/13 10:20:34 */
+/*
+Special thanks to Luke Dashjr - Nanofory code was adopted from bfgminer - mcp2210.c
+*/
+#define FIRST_BASE 61
+#define SECOND_BASE 4
+static const int8_t bitfury_counters[16] =
+  { 64, 64, SECOND_BASE, SECOND_BASE + 4, SECOND_BASE + 2,
+  SECOND_BASE + 2 + 16, SECOND_BASE, SECOND_BASE + 1, (FIRST_BASE) % 65,
+  (FIRST_BASE + 1) % 65,
+  (FIRST_BASE + 3) % 65, (FIRST_BASE + 3 + 16) % 65, (FIRST_BASE + 4) % 65,
+  (FIRST_BASE + 4 + 4) % 65,
+  (FIRST_BASE + 3 + 3) % 65, (FIRST_BASE + 3 + 1 + 3) % 65
+};
+const uint32_t SHA_U[64] = {
+  0x428a2f98, 0x71374491, 0xb5c0fbcf
+};
+
+#define Ch(x, y, z) ((x & (y ^ z)) ^ z)
+#define Maj(x, y, z) ((x & (y | z)) | (y & z))
+#define ROTR(x, n) ((x >> n) | (x << (32 - n)))
+#define S0(x) (ROTR(x, 2) ^ ROTR(x, 13) ^ ROTR(x, 22))
+#define S1(x) (ROTR(x, 6) ^ ROTR(x, 11) ^ ROTR(x, 25))
+#define BT_OFFSETS_U 7
+static const uint32_t bf_offsetsu[] =
+  { -0x800000, 0, 0xffc00000, 0xff800000, 0x02800000, 0x02C00000,
+  0x00400000
+};
+
+static bool
+libhexu_usb_dead (struct cgpu_info *hexmineru)
+{
+  struct cg_usb_device *usbdev;
+  struct hexmineru_info *info = hexmineru->device_data;
+  if (!info)
+    return true;
+  usbdev = hexmineru->usbdev;
+  bool ret = (usbdev == NULL
+              || usbdev->handle == NULL
+              || hexmineru->shutdown
+              || info->shut_read || info->shut_write
+              || hexmineru->usbinfo.nodev || hexmineru->deven != DEV_ENABLED);
+  return ret;
+}
+
+static int
+libhexu_sendHashData (struct cgpu_info *hexmineru, unsigned char *sendbuf,
+                      size_t buf_len, int timeout)
+{
+  struct hexmineru_info *info = hexmineru->device_data;
+  struct cg_usb_device *usbdev;
+  int wrote = 0, written = 0;
+  int err = LIBUSB_SUCCESS;
+  usbdev = hexmineru->usbdev;
+  if (libhexu_usb_dead (hexmineru))
+    goto out;
+  while (written < buf_len && err == LIBUSB_SUCCESS)
+    {
+      err = libusb_interrupt_transfer
+        (usbdev->handle, 0x01, sendbuf + written,
+         MIN (HEXU_USB_WR_SIZE, buf_len - written), &wrote, timeout);
+      if (err == LIBUSB_SUCCESS)
+        written += wrote;
+    }
+out:
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+    info->shut_write = true;
+
+  return written;
+}
+
+static int
+libhexu_readHashData (struct cgpu_info *hexmineru, unsigned char *hash,
+                      int *hash_write_pos, int timeout)
+{
+  struct hexmineru_info *info = hexmineru->device_data;
+  struct cg_usb_device *usbdev;
+  int read = 0, ret = 0;
+  int err = LIBUSB_SUCCESS;
+  usbdev = hexmineru->usbdev;
+  if (libhexu_usb_dead (hexmineru))
+    goto out;
+  err =
+    libusb_interrupt_transfer (usbdev->handle, 0x81, hash + *hash_write_pos,
+                              HEXU_USB_R_SIZE, &read, timeout);
+  if (err == LIBUSB_SUCCESS)
+    {
+      ret = MIN (read, HEXU_USB_R_SIZE);
+      *hash_write_pos += ret;
+    }
+out:
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+    info->shut_read = true;
+  return ret;
+}
+
+static void
+libhexu_libbitfury_ms3_compute (unsigned *p)
+{
+  unsigned a, b, c, d, e, f, g, h, ne, na, i;
+#if defined(__BIG_ENDIAN__) || defined(MIPSEB)
+  for (i = 0; i < 8; i++)
+    p[i] = htole32 (p[i]);
+#endif
+  a = p[0];
+  b = p[1];
+  c = p[2];
+  d = p[3];
+  e = p[4];
+  f = p[5];
+  g = p[6];
+  h = p[7];
+  for (i = 0; i < 3; i++)
+    {
+#if defined(__BIG_ENDIAN__) || defined(MIPSEB)
+      p[i + 16] = htole32 (p[i + 16]);
+#endif
+      ne = p[i + 16] + SHA_U[i] + h + Ch (e, f, g) + S1 (e) + d;
+      na =
+        p[i + 16] + SHA_U[i] + h + Ch (e, f, g) + S1 (e) + S0 (a) + Maj (a, b,
+                                                                         c);
+      d = c;
+      c = b;
+      b = a;
+      a = na;
+      h = g;
+      g = f;
+      f = e;
+      e = ne;
+    }
+  p[15] = a;
+  p[14] = b;
+  p[13] = c;
+  p[12] = d;
+  p[11] = e;
+  p[10] = f;
+  p[9] = g;
+  p[8] = h;
+#if defined(__BIG_ENDIAN__) || defined(MIPSEB)
+  for (i = 0; i < 19; i++)
+    p[i] = htole32 (p[i]);
+#endif
+}
+
+static void
+libhexu_work_to_bitfury_payload (struct hexmineru_task *p, struct work *w)
+{
+  memcpy (&p->midstate[0], w->midstate, 32);
+  memcpy (&p->m7, w->data + 64, 12);
+}
+
+static void
+libhexu_bitfury_payload_to_atrvec (uint32_t * atrvec,
+                                   struct hexmineru_task *p)
+{
+/* Programming next value */
+  memcpy (atrvec, p, 76);
+  libhexu_libbitfury_ms3_compute (atrvec);
+}
+
+static bool
+libhexu_cachenonce (struct chip_resultsu *nonce_cache, uint32_t nonce)
+{
+  int i = 0;
+  while (i < HEXU_NONCE_CASH_SIZE && nonce_cache->nonces[i] != nonce)
+    i++;
+  if (i < HEXU_NONCE_CASH_SIZE)
+    return false;
+  if (nonce_cache->nonce_cache_write_pos == HEXU_NONCE_CASH_SIZE)
+    nonce_cache->nonce_cache_write_pos = 0;
+  nonce_cache->nonces[nonce_cache->nonce_cache_write_pos++] = nonce;
+  return true;
+}
+
+static uint32_t
+libhexu_decnonce (uint32_t in)
+{
+  uint32_t out;
+  /* First part load */
+  out = (in & 0xFF) << 24;
+  in >>= 8;
+  /* Byte reversal */
+  in = (((in & 0xaaaaaaaa) >> 1) | ((in & 0x55555555) << 1));
+  in = (((in & 0xcccccccc) >> 2) | ((in & 0x33333333) << 2));
+  in = (((in & 0xf0f0f0f0) >> 4) | ((in & 0x0f0f0f0f) << 4));
+  out |= (in >> 2) & 0x3FFFFF;
+  /* Extraction */
+  if (in & 1)
+    out |= (1 << 23);
+  if (in & 2)
+    out |= (1 << 22);
+  out -= 0x800004;
+  return out;
+}
+
+extern bool submit_tested_work_fast_clone (struct thr_info *thr,
+                                           struct work *work, bool diff1);
+
+static int
+libhexu_bitfury_checkresults (struct thr_info *thr, struct work *work,
+                              uint32_t nonce)
+{
+  int i;
+  for (i = 0; i < BT_OFFSETS_U; i++)
+    {
+      if (test_nonce (work, nonce + bf_offsetsu[i]))
+        {
+          submit_tested_work_fast_clone (thr, work, true);
+          return 1;
+        }
+    }
+  return 0;
+}
+
+static int
+hexmineru_predecode_nonce (struct cgpu_info *hexmineru, struct thr_info *thr,
+                           uint32_t nonce, int work_id)
+{
+  struct hexmineru_info *info = hexmineru->device_data;
+  if (info->hexworks[work_id]->pool == NULL)
+    return 0;
+  return libhexu_bitfury_checkresults (thr, info->hexworks[work_id], nonce);
+}
--- cg_o/driver-hexminer8.c	1970-01-01 02:00:00.000000000 +0200
+++ cgminer_hex/driver-hexminer8.c	2014-09-22 19:28:38.671387123 +0300
@@ -0,0 +1,658 @@
+/*$T indentinput.c GC 1.140 10/16/13 10:19:47 */
+#include "config.h"
+#include <limits.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <ctype.h>
+#include <dirent.h>
+#include <unistd.h>
+#ifndef WIN32
+#include <sys/select.h>
+#include <termios.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#ifndef O_CLOEXEC
+#define O_CLOEXEC 0
+#endif
+#else
+#include "compat.h"
+#include <windows.h>
+#include <io.h>
+#endif
+#include "elist.h"
+#include "miner.h"
+#include "usbutils.h"
+#include "driver-hexminer8.h"
+#include <math.h>
+#include "util.h"
+extern unsigned int work_block;
+extern unsigned int work_pool_update;
+extern struct work *copy_work_noffset_fast_no_id (struct work *base_work,
+                                                  int noffset);
+
+struct device_drv hexminer8_drv;
+extern bool no_work;
+int opt_hexminer8_chip_mask = 0xFF;
+int opt_hexminer8_set_config_diff_to_one = 1;
+int opt_hexminer8_core_voltage = HEX8_DEFAULT_CORE_VOLTAGE;
+
+#include "libhex8.c"
+
+static int
+hexminer8_send_task (struct hexminer8_task *ht, struct cgpu_info *hexminer8)
+{
+  int ret = 0;
+  size_t nr_len = HEXMINER8_TASK_SIZE;
+  struct hexminer8_info *info;
+  info = hexminer8->device_data;
+  libhex8_csum (&ht->startbyte, &ht->csum, &ht->csum);
+  ret = libhex8_sendHashData (hexminer8, &ht->startbyte, nr_len);
+  if (ret != nr_len&& info->usb_bad_reads > -1)
+    {
+      libhex8_reset (hexminer8);
+      info->usb_w_errors++;
+      return -1;
+    }
+  return ret;
+}
+
+static inline void
+hexminer8_create_task (bool reset_work, struct hexminer8_task *ht,
+                       struct work *work, bool diff1,
+                       uint32_t * asic_difficulty, double *cached_diff)
+{
+  if (reset_work)
+    ht->status = htole16 ((uint16_t) HEX8_STAT_NEW_WORK_CLEAR_OLD);
+  else
+    ht->status = htole16 ((uint16_t) HEX8_STAT_NEW_WORK);
+  memcpy (ht->midstate, work->midstate, 32);
+  memcpy (ht->merkle, work->data + 64, 12);
+  ht->id = htole16 ((uint16_t) work->subid);
+  if (work->ping || work->work_difficulty <= (double) 1)
+    {
+      ht->difficulty = htole32 (0xFFFF001D);
+      work->ping = 1;
+      return;
+    }
+  if (*cached_diff != work->work_difficulty)
+    {
+      *cached_diff = work->work_difficulty;
+
+#if defined(__BIG_ENDIAN__) || defined(MIPSEB)
+      *asic_difficulty = libhex8_get_target (work->work_difficulty);
+
+#else
+      *asic_difficulty = be32toh (libhex8_get_target (work->work_difficulty));
+
+#endif
+    }
+  ht->difficulty = *asic_difficulty;
+}
+
+static inline void
+hexminer8_init_task_c (struct hexminer8_config_task *htc,
+                       struct hexminer8_info *info)
+{
+  htc->startbyte = 0x53;
+  htc->datalength =
+    (uint8_t) ((sizeof (struct hexminer8_config_task) - 6) / 2);
+  htc->command = 0x57;
+  htc->address = htole16 (0x30C0);
+  htc->hashclock = htole16 ((uint16_t) info->frequency);
+  libhex8_setvoltage (info->core_voltage, &htc->refvoltage);
+  htc->difficulty = htole32 (0xFFFF001D);
+  htc->chip_mask = (uint8_t) info->chip_mask;
+  libhex8_csum (&htc->startbyte, &htc->csum, &htc->csum);
+}
+
+static inline void
+hexminer8_init_task (struct hexminer8_task *ht, struct hexminer8_info *info)
+{
+  ht->startbyte = 0x53;
+  ht->datalength = (uint8_t) ((HEXMINER8_TASK_SIZE - 6) / 2);
+  ht->command = 0x57;
+  ht->address = htole16 (0x3080);
+  ht->difficulty = htole32 (0xFFFF001D);
+  ht->status = htole16 ((uint16_t) HEX8_STAT_NEW_WORK_CLEAR_OLD);
+}
+
+static bool
+need_reset (struct cgpu_info *hexminer8)
+{
+  struct hexminer8_info *info = hexminer8->device_data;
+  time_t now = time (NULL);
+  bool ret = false;
+  int i = 0;
+  int secs = 15;
+  if (!info->diff1)
+    secs = 60;
+  if (no_work)
+    {
+      while (i < info->asic_count)
+        {
+          if (info->last_chip_valid_work[i] > 0)
+            info->last_chip_valid_work[i] = now + 10;
+          i++;
+        }
+      return false;
+    }
+  while (i < info->asic_count)
+    {
+      if (!info->chips_enabled[i])
+        {
+          i++;
+          continue;
+        }
+      if (!info->chip_is_dead[i]
+          && (info->chip_con_resets[i] < 5 && info->matching_work[i]
+              && info->engines[i])
+          && (info->last_chip_valid_work[i] +
+              (int) (secs * 32 / info->engines[i]) < now))
+        {
+          ret = true;
+          info->chip_con_resets[i]++;
+          info->last_chip_valid_work[i] = now;
+          if (info->chip_con_resets[i] == 5)
+            {
+              info->chip_is_dead[i] = true;
+              info->engines[i] = 0;
+            }
+          break;
+        }
+      info->chip_con_resets[i] = 0;
+      i++;
+    }
+  info->timing_adjusted = true;
+  reajust_timings (hexminer8);
+  return ret;
+}
+
+static struct cgpu_info *
+hexminer8_detect_one (libusb_device * dev, struct usb_find_devices *found)
+{
+  int asic_count, frequency;
+  
+  struct hexminer8_info *info;
+  struct cgpu_info *hexminer8;
+  bool configured = false;
+  int i = 0;
+  hexminer8 = usb_alloc_cgpu (&hexminer8_drv, HEX8_MINER_THREADS);
+  if (!usb_init (hexminer8, dev, found))
+    {
+      usb_uninit (hexminer8);
+      return NULL;
+    }
+  hexminer8->device_data = calloc (sizeof (struct hexminer8_info), 1);
+  if (unlikely (!(hexminer8->device_data)))
+    {
+      hexminer8->device_data = NULL;
+      usb_uninit (hexminer8);
+      return NULL;
+    }
+  if (opt_hexminer8_options != NULL)
+  	configured = (sscanf(opt_hexminer8_options, "%d:%d", &asic_count, &frequency) == 2);	
+  
+  if (opt_hexminer8_core_voltage < HEX8_MIN_COREMV
+      || opt_hexminer8_core_voltage > HEX8_MAX_COREMV)
+    {
+      applog (LOG_ERR, "Invalid hexminer8-voltage %d must be %dmV - %dmV",
+              opt_hexminer8_core_voltage, HEX8_MIN_COREMV, HEX8_MAX_COREMV);
+      free (hexminer8->device_data);
+      hexminer8->device_data = NULL;
+      usb_uninit (hexminer8);
+      return NULL;
+    }
+  info = hexminer8->device_data;
+  info->hexworks = calloc (sizeof (struct work *), HEXMINER8_ARRAY_SIZE);
+  if (unlikely (!(info->hexworks)))
+    {
+      free (hexminer8->device_data);
+      hexminer8->device_data = NULL;
+      usb_uninit (hexminer8);
+      return NULL;
+    }
+  info->wr = (struct work8_result *) malloc (sizeof (struct work8_result));
+  info->array_nonce_cache = calloc (16, sizeof (struct chip_results8));
+  info->readbuf = calloc (HEX8_HASH_BUF_SIZE, sizeof (unsigned char));
+  info->write_pos = 0;
+  info->usb_bad_reads = -30;
+  info->hash_read_pos = 0;
+  info->hash_write_pos = 0;
+  info->shut_read = false;
+  info->shut_write = false;
+  info->shut_reset = false;
+  info->work = NULL;
+  info->cached_diff = -1;
+  info->miner_count = HEX8_DEFAULT_MINER_NUM;
+  info->asic_count = HEX8_DEFAULT_ASIC_NUM;
+  info->frequency = HEX8_DEFAULT_FREQUENCY;
+  info->pic_voltage_readings = HEX8_DEFAULT_CORE_VOLTAGE;
+  info->core_voltage = opt_hexminer8_core_voltage;
+  info->chip_mask = opt_hexminer8_chip_mask;
+  info->diff1 = (bool) opt_hexminer8_set_config_diff_to_one;
+  info->wr->buf_empty_space = 63;
+  info->work_block_local = -1;
+  info->work_pool_update = -1;
+  info->reset_work = true;
+  info->jobs_to_send = 12;
+  info->roll = 0;
+  info->timing_adjusted = false;
+  if (configured)
+    {
+      info->asic_count = asic_count;
+      info->frequency = frequency;
+    }
+  gettimeofday (&info->last_wr, NULL);
+  info->wsem_ustiming =
+    (int64_t) (0x100000000ll / (info->asic_count * info->frequency * 4 * 32));
+  info->ping_period =
+    (int) (1000 * 1000 / info->wsem_ustiming * 60 / info->asic_count / 17);
+  info->ht = calloc (sizeof (struct hexminer8_task), 1);
+  hexminer8_init_task (info->ht, info);
+  info->ping_counter = 0;
+  info->random_job = 0;
+  while (i < HEXMINER8_ARRAY_SIZE)
+    {
+      info->hexworks[i] = calloc (1, sizeof (struct work));
+      info->hexworks[i]->pool = NULL;
+      i++;
+    } i = 0;
+  info->power_checked = time (NULL);
+  while (i < HEX8_DEFAULT_ASIC_NUM)
+    info->chip_is_dead[i++] = false;
+  if (!add_cgpu (hexminer8))
+    {
+      free (info->hexworks);
+      free (hexminer8->device_data);
+      hexminer8->device_data = NULL;
+      hexminer8 = usb_free_cgpu (hexminer8);
+      usb_uninit (hexminer8);
+      return NULL;
+    }
+  return hexminer8;
+}
+
+static void
+hexminer8_detect (bool __maybe_unused hotplug)
+{
+  usb_detect (&hexminer8_drv, hexminer8_detect_one);
+}
+
+static void
+do_hexminer8_close (struct thr_info *thr)
+{
+  struct cgpu_info *hexminer8 = thr->cgpu;
+  struct hexminer8_info *info = hexminer8->device_data;
+  int i = 0;
+  while (i < HEXMINER8_ARRAY_SIZE)
+    {
+      free_work (info->hexworks[i]);
+      i++;
+    }
+  free (info->hexworks);
+  free (info->readbuf);
+  free (info->array_nonce_cache);
+  free (info->wr);
+  free (info->ht);
+  if (info->work)
+    free_work (info->work);
+}
+
+static void
+hexminer8_shutdown (struct thr_info *thr)
+{
+  struct cgpu_info *hexminer8 = thr->cgpu;
+  do_hexminer8_close (thr);
+  usb_nodev (hexminer8);
+}
+
+static bool
+hexminer8_thread_init (struct thr_info *thr)
+{
+  struct cgpu_info *hexminer8 = thr->cgpu;
+  struct hexminer8_info *info = hexminer8->device_data;
+  uint8_t i = 0;
+  info->thr = thr;
+  cgsleep_ms (200);
+  struct hexminer8_config_task *htc;
+  htc = calloc (sizeof (struct hexminer8_config_task), 1);
+  hexminer8_init_task_c (htc, info);
+  int ret = libhex8_sendHashData (hexminer8, &htc->startbyte,
+                                  sizeof (struct hexminer8_config_task));
+  if (ret != sizeof (struct hexminer8_config_task))
+    {
+    	applog (LOG_ERR, "HEX8 %i Send config failed disabling!!", hexminer8->device_id);
+   		libhex8_reset (hexminer8);
+   		info->shut_write = true;
+ 		}	  
+  free (htc);
+
+  while (i < info->asic_count)
+    {
+      info->chips_enabled[i] =
+        (((uint8_t) info->chip_mask & (uint8_t) pow (2, i)) ==
+         (uint8_t) pow (2, i));
+      i++;
+    }
+  return true;
+}
+
+extern bool stale_work (struct work *work, bool share);
+
+static void
+do_write_hex8 (struct thr_info *thr)
+{
+  struct cgpu_info *hexminer8 = thr->cgpu;
+  struct hexminer8_info *info = hexminer8->device_data;
+  struct timeval tm;
+  struct work *tmpwork = NULL;
+  bool power;
+  int jobs_to_send = info->jobs_to_send;
+  int send_jobs, ret;
+  if ((time (NULL) - info->power_checked) > 20)
+    {
+      info->power_checked = time (NULL);
+      power = need_reset (hexminer8);
+      if (power)
+        {
+          info->b_reset_count++;
+          libhex8_set_word (hexminer8, 0x3080 + HEXMINER8_TASK_SIZE - 8,
+                            0x0004);
+          cgsleep_ms (100);
+          struct hexminer8_config_task *htc;
+          htc = calloc (sizeof (struct hexminer8_config_task), 1);
+          hexminer8_init_task_c (htc, info);
+          ret =
+            libhex8_sendHashData (hexminer8, &htc->startbyte,
+                                  sizeof (struct hexminer8_config_task));
+          free (htc);
+          hexminer8_init_task (info->ht, info);
+          ret = hexminer8_send_task (info->ht, hexminer8);
+          cgsleep_ms (200);
+          gettimeofday (&info->last_wr, NULL);
+          info->reset_work = true;
+          jobs_to_send = 12;
+        }
+    }
+  send_jobs = 0;
+  while (!libhex8_usb_dead (hexminer8) && (send_jobs < jobs_to_send))
+    {
+    again:
+      if (!info->work)
+        {
+          info->roll = 0;
+          info->work = get_work (thr, thr->id);
+          info->work->ping = (info->reset_work || info->diff1
+                              || !info->timing_adjusted);
+        }
+      if (stale_work (info->work, false))
+        {
+          free_work (info->work);
+          info->work = NULL;
+          if (info->work_block_local != work_block || info->work_pool_update != work_pool_update)
+            {
+              info->reset_work = true;
+              send_jobs = 0;
+              jobs_to_send = 12;
+              info->work_block_local = work_block;
+              info->work_pool_update = work_pool_update;
+            }
+          goto again;
+        }
+      if (info->write_pos >= HEXMINER8_ARRAY_SIZE_REAL)
+        info->write_pos = 0;
+      info->work->subid = info->write_pos;
+      tmpwork = copy_work_noffset_fast_no_id (info->work, info->roll++);
+      if (info->ping_counter == info->random_job)
+        tmpwork->ping = 1;
+      hexminer8_create_task (info->reset_work, info->ht, tmpwork, info->diff1,
+                             &info->asic_difficulty, &info->cached_diff);
+      free_work (info->hexworks[info->write_pos]);
+      info->hexworks[info->write_pos] = tmpwork;
+      if (!info->diff1)
+        {
+          info->ping_counter++;
+          if (info->ping_counter == info->ping_period)
+            {
+              info->ping_counter = 0;
+              gettimeofday (&tm, NULL);
+              srandom (tm.tv_sec + tm.tv_usec * 1000000ul);
+              info->random_job = rand () % info->ping_period;
+            }
+        }
+      if (info->work->drv_rolllimit)
+        info->work->drv_rolllimit--;
+      else
+        {
+          free_work (info->work);
+          info->work = NULL;
+        }
+      ret = hexminer8_send_task (info->ht, hexminer8);
+      info->write_pos++;
+      send_jobs++;
+      if (ret == HEXMINER8_TASK_SIZE && info->reset_work)
+        {
+          info->reset_work = false;
+          gettimeofday (&info->last_wr, NULL);
+        }
+    }
+}
+
+extern void inc_hw_errors_hex8 (struct thr_info *thr, int diff);
+
+static int64_t
+hexminer8_scanhash (struct thr_info *thr)
+{
+  struct cgpu_info *hexminer8 = thr->cgpu;
+  struct hexminer8_info *info = hexminer8->device_data;
+  struct timeval now;
+  struct timeval diff;
+  int64_t tdif, rethash_count = 0;
+  int ret_r, rminder = 0;
+  double found, hash_count = 0;
+  uint32_t nonce;
+  if (info->work_block_local != work_block || info->work_pool_update != work_pool_update)
+    {
+      info->reset_work = true;
+      info->jobs_to_send = 12;
+      info->work_block_local = work_block;
+      info->work_pool_update = work_pool_update;
+      if (info->work)
+        {
+          free_work (info->work);
+          info->work = NULL;
+        }
+      gettimeofday (&info->last_wr, NULL);
+      do_write_hex8 (thr);
+      goto done_wr;
+    }
+  gettimeofday (&now, NULL);
+  tdif = timediff (&now, &info->last_wr);
+  info->jobs_to_send = (int) (tdif / info->wsem_ustiming);
+  rminder = (int) (tdif % info->wsem_ustiming);
+  if (info->jobs_to_send > 0 || info->wr->buf_empty_space > 50)
+    {
+      gettimeofday (&info->last_wr, NULL);
+      if (info->wr->buf_empty_space < 40)
+        goto done_wr;
+      now.tv_sec = 0;
+      now.tv_usec = rminder;
+      timersub (&info->last_wr, &now, &diff);
+      memcpy (&info->last_wr, &diff, sizeof (struct timeval));
+      if (info->wr->buf_empty_space > 50)
+        info->jobs_to_send++;
+      if (info->jobs_to_send > 12)
+        info->jobs_to_send = 12;
+      do_write_hex8 (thr);
+    }
+done_wr:
+  if (libhex8_usb_dead (hexminer8))
+    {
+      hexminer8->shutdown = true;
+      return -1;
+    }
+  if (info->hash_write_pos + HEX8_USB_R_SIZE > HEX8_HASH_BUF_SIZE_OK)
+    {
+      info->hash_write_pos = info->hash_write_pos - info->hash_read_pos;
+      memcpy (info->readbuf, info->readbuf + info->hash_read_pos,
+              info->hash_write_pos);
+      info->hash_read_pos = 0;
+    }
+  if (info->hash_write_pos - info->hash_read_pos > 7)
+    {
+    again:
+    	if (info->work_block_local != work_block || info->work_pool_update != work_pool_update)
+    		goto new_block;
+      ret_r =
+        libhex8_eatHashData (info->wr, info->readbuf, &info->hash_read_pos,
+                             &info->hash_write_pos);
+      if (ret_r > HEX8_BUF_DATA)
+        goto out;
+      if (info->wr->datalength == 1)
+        goto done;
+      if (info->wr->lastnonceid > HEXMINER8_ARRAY_SIZE_REAL)
+        info->wr->lastnonceid = 0;
+      if (info->wr->lastchippos >= HEX8_DEFAULT_ASIC_NUM)
+        info->wr->lastchippos = 7;
+      if (libhex8_cachenonce
+          (&info->array_nonce_cache[info->wr->lastchippos],
+           info->wr->lastnonce))
+        {
+          nonce = htole32 (info->wr->lastnonce);
+          found =
+            hexminer8_predecode_nonce (hexminer8, thr, nonce,
+                                       info->wr->lastnonceid, info->diff1);
+          if (found > 0)
+            {
+              info->engines[(uint8_t) info->wr->lastchippos] =
+                info->wr->good_engines;
+              info->last_chip_valid_work[(uint8_t) info->wr->lastchippos] =
+                time (NULL);
+              if (hash_count == 0)
+                libhex8_getvoltage (htole16 (info->wr->lastvoltage),
+                                    &info->pic_voltage_readings);
+              hash_count += found;
+              info->matching_work[info->wr->lastchippos]++;
+            }
+          else
+            inc_hw_errors_hex8 (thr, (int) found);
+        }
+      else
+        info->dupe[info->wr->lastchippos]++;
+    out:
+      if (ret_r == HEX8_BUF_ERR)
+        info->usb_r_errors++;
+    done:
+      if (ret_r != HEX8_BUF_SKIP)
+        goto again;
+    }
+  if (info->work_block_local != work_block || info->work_pool_update != work_pool_update)
+    		goto new_block;
+  ret_r =
+    libhex8_readHashData (hexminer8, info->readbuf, &info->hash_write_pos,
+                          HEXMINER8_BULK_READ_TIMEOUT);
+  if (ret_r != LIBUSB_SUCCESS)
+    info->usb_bad_reads++;
+  else
+    info->usb_bad_reads = 0;
+  if (info->usb_bad_reads > 20)
+    libhex8_reset (hexminer8);
+  new_block:
+  rethash_count = (0xffffffffull * (int64_t) hash_count);
+  if (libhex8_usb_dead (hexminer8))
+    {
+      hexminer8->shutdown = true;
+      return -1;
+    }
+  return rethash_count;
+}
+
+static void
+get_hexminer8_statline_before (char *buf, size_t bufsiz,
+                               struct cgpu_info *hexminer8)
+{
+  if (!hexminer8->device_data)
+    return;
+  struct hexminer8_info *info = hexminer8->device_data;
+  tailsprintf (buf, bufsiz, "%3d %4d/%4dmV", info->frequency,
+               info->core_voltage, info->pic_voltage_readings);
+}
+
+extern void suffix_string (uint64_t val, char *buf, size_t bufsiz,
+                           int sigdigits);
+
+static struct api_data *
+hexminer8_api_stats (struct cgpu_info *cgpu)
+{
+  struct api_data *root = NULL;
+  struct timeval now;
+  struct hexminer8_info *info = cgpu->device_data;
+  char displayed_hashes[16], displayed_rolling[16];
+  double dev_runtime, hwp;
+  uint64_t dh64, dr64;
+  int i;
+  if (!info)
+    return NULL;
+  hwp =
+    (cgpu->hw_errors +
+     cgpu->diff1) ? (double) (cgpu->hw_errors) / (double) (cgpu->hw_errors +
+                                                           cgpu->diff1) : 0;
+  if (cgpu->dev_start_tv.tv_sec == 0)
+    dev_runtime = total_secs;
+  else
+    {
+      cgtime (&now);
+      dev_runtime = tdiff (&now, &(cgpu->dev_start_tv));
+    }
+  if (dev_runtime < 1.0)
+    dev_runtime = 1.0;
+  dh64 = (double) cgpu->total_mhashes / dev_runtime * 1000000ull;
+  dr64 = (double) cgpu->rolling * 1000000ull;
+  suffix_string (dh64, displayed_hashes, sizeof (displayed_hashes), 4);
+  suffix_string (dr64, displayed_rolling, sizeof (displayed_rolling), 4);
+  root = api_add_string (root, "MHS 5s", displayed_rolling, true);
+  root = api_add_string (root, "MHS av", displayed_hashes, true);
+  root = api_add_int (root, "Hardware Errors", &(cgpu->hw_errors), true);
+  root = api_add_percent (root, "Hardware Errors%", &hwp, true);
+  root = api_add_int (root, "USB Read Errors", &(info->usb_r_errors), true);
+  root = api_add_int (root, "USB Write Errors", &(info->usb_w_errors), true);
+  root =
+    api_add_int (root, "USB Reset Count", &(info->usb_reset_count), true);
+  root =
+    api_add_int (root, "Miner Reset Count", &(info->b_reset_count), true);
+  root =
+    api_add_time (root, "Last Share Time", &(cgpu->last_share_pool_time),
+                  true);
+  root = api_add_int (root, "Chip Count", &(info->asic_count), true);
+  root = api_add_int (root, "Frequency", &(info->frequency), true);
+  root = api_add_int (root, "Core Voltage", &(info->core_voltage), true);
+  root =
+    api_add_int (root, "PIC Voltage Readings", &(info->pic_voltage_readings),
+                 true);
+  for (i = 0; i < info->asic_count; i++)
+    {
+      char mcw[24];
+      sprintf (mcw, "Chip%d Nonces", i + 1);
+      root = api_add_int (root, mcw, &(info->matching_work[i]), true);
+      sprintf (mcw, "Chip%d Engines", i + 1);
+      root = api_add_int (root, mcw, &(info->engines[i]), true);
+      sprintf (mcw, "Chip%d Dupes", i + 1);
+      root = api_add_int (root, mcw, &(info->dupe[i]), true);
+    }
+  return root;
+}
+
+struct device_drv hexminer8_drv = {
+  .drv_id = DRIVER_hexminer8,
+  .dname = "hexminer8",
+  .name = "HEX8",
+  .drv_detect = hexminer8_detect,
+  .thread_init = hexminer8_thread_init,
+  .hash_work = hash_driver_work,
+  .scanwork = hexminer8_scanhash,
+  .get_api_stats = hexminer8_api_stats,
+  .get_statline_before = get_hexminer8_statline_before,
+  .thread_shutdown = hexminer8_shutdown,
+};
--- cg_o/driver-hexminer8.h	1970-01-01 02:00:00.000000000 +0200
+++ cgminer_hex/driver-hexminer8.h	2014-09-22 19:28:38.671387123 +0300
@@ -0,0 +1,150 @@
+/*$T indentinput.h GC 1.140 10/16/13 10:20:01 */
+#ifndef HEX8_H
+#define HEX8_H
+#ifdef USE_HEXMINER8
+#include "util.h"
+
+/* hexminer8_task/work_reply status Definitions: */
+#define HEX8_STAT_IDLE 0        /* Idle or data already Sent to the buffer */
+#define HEX8_STAT_NEW_WORK 1    /* Request for write in the buffer */
+#define HEX8_STAT_WAITING 2     /* Wait For Buffer Empty Position */
+#define HEX8_STAT_CLR_BUFF 3    /* Force Buffer Empty */
+#define HEX8_STAT_STOP_REQ 4    /* Stop Request */
+#define HEX8_STAT_NEW_WORK_CLEAR_OLD 5  /* Clear Buffers and after that fill the first buffer */
+#define HEX8_STAT_UNUSED 6
+
+/* libhex8_eatHashData/BUF_reply status Definitions: */
+#define HEX8_BUF_DATA 0
+#define HEX8_BUF_ERR 1
+#define HEX8_BUF_SKIP 2
+
+/* MISC */
+#define HEXMINER8_ARRAY_PIC_SIZE 64
+#define HEXMINER8_ARRAY_SIZE HEXMINER8_ARRAY_PIC_SIZE * 4
+#define HEXMINER8_ARRAY_SIZE_REAL HEXMINER8_ARRAY_SIZE - 2
+#define HEX8_NONCE_CASH_SIZE 1
+#define HEX8_USB_R_SIZE 64
+#define HEX8_USB_WR_SIZE 64
+#define HEX8_HASH_BUF_SIZE 2048
+#define HEX8_HASH_BUF_SIZE_OK HEX8_HASH_BUF_SIZE - 4
+#define HEXMINER8_BULK_READ_TIMEOUT 1000
+#define HEX8_USB_WR_TIME_OUT 500
+#define HEX8_MINER_THREADS 1
+#define HEX8_DEFAULT_MINER_NUM 0x01
+#define HEX8_DEFAULT_ASIC_NUM 0x08
+#define HEX8_MIN_FREQUENCY 0
+#define HEX8_MAX_FREQUENCY 511
+#define HEX8_DEFAULT_FREQUENCY 200
+#define HEX8_DEFAULT_CORE_VOLTAGE 800   /* in millivolts */
+#define HEX8_MIN_COREMV 300     /* in millivolts */
+#define HEX8_MAX_COREMV 2101    /* in millivolts */
+struct chip_results8
+{
+  uint8_t nonce_cache_write_pos;
+  uint32_t nonces[HEX8_NONCE_CASH_SIZE];
+};
+struct hexminer8_task
+{
+  uint8_t startbyte;
+  uint8_t datalength;
+  uint8_t command;
+  uint16_t address;
+  uint8_t midstate[32];
+  uint32_t merkle[3];
+  uint32_t difficulty;
+  uint16_t id;
+  uint16_t status;
+  uint8_t csum;
+  uint8_t pad[2];
+} __attribute__ ((packed, aligned (4)));
+struct work8_result
+{
+  uint8_t startbyte;
+  uint8_t datalength;
+  uint8_t command;
+  uint16_t address;
+  uint32_t lastnonce;
+  uint8_t lastnonceid;
+  uint8_t status;
+  uint16_t lastvoltage;
+  uint8_t lastchippos;
+  uint8_t buf_empty_space;
+  uint8_t good_engines;
+  uint8_t dum;
+  uint8_t csum;
+  uint8_t pad[2];
+} __attribute__ ((packed, aligned (4)));
+struct hexminer8_info
+{
+  struct timeval last_wr;
+  int jobs_to_send;
+  int64_t wsem_ustiming;
+  bool timing_adjusted;
+  bool shut_read;
+  bool shut_write;
+  bool shut_reset;
+  bool diff1;
+  bool reset_work;
+  bool chips_enabled[HEX8_DEFAULT_ASIC_NUM];
+  int usb_bad_reads;
+  int write_pos;
+  int ping_period;
+  int ping_counter;
+  int random_job;
+  int roll;
+  double cached_diff;
+  uint32_t asic_difficulty;
+  int chip_mask;
+  int miner_count;
+  int asic_count;
+  int core_voltage;
+  int frequency;
+  int usb_r_errors;
+  int usb_w_errors;
+  int usb_reset_count;
+  int b_reset_count;
+  int pic_voltage_readings;
+  int hash_read_pos;
+  int hash_write_pos;
+  int dupe[HEX8_DEFAULT_ASIC_NUM];
+  int matching_work[HEX8_DEFAULT_ASIC_NUM];
+  int engines[HEX8_DEFAULT_ASIC_NUM];
+  unsigned int work_block_local;
+  unsigned int work_pool_update;
+  struct work *work;
+  unsigned char *readbuf;
+  struct work8_result *wr;
+  struct chip_results8 *array_nonce_cache;
+  struct thr_info *thr;
+  struct work **hexworks;
+  time_t last_chip_valid_work[HEX8_DEFAULT_ASIC_NUM];
+  int chip_con_resets[HEX8_DEFAULT_ASIC_NUM];
+  bool chip_is_dead[HEX8_DEFAULT_ASIC_NUM];
+  time_t power_checked;
+  struct hexminer8_task *ht;
+};
+struct hexminer8_config_task
+{
+  uint8_t startbyte;
+  uint8_t datalength;
+  uint8_t command;
+  uint16_t address;
+  uint16_t hashclock;
+  uint16_t refvoltage;
+  uint32_t difficulty;
+  uint8_t chip_mask;
+  uint8_t wr_interwal;
+  uint8_t csum;
+} __attribute__ ((packed, aligned (4)));
+
+#define HEX8_WORKANSWER_ADR 0x3000
+#define HEXMINER8_TASK_SIZE (sizeof(struct hexminer8_task)-2)
+#define HEX8_MAX_WORK_SIZE (sizeof(struct work8_result)-2)
+#define HEX8_BASE_WORK_SIZE 6
+extern int opt_hexminer8_core_voltage;
+extern int opt_hexminer8_chip_mask;
+extern int opt_hexminer8_set_config_diff_to_one;
+extern struct hexminer8_info **hexminer8_info;
+
+#endif /* USE_HEXMINER8 */
+#endif /* HEX8_H */
--- cg_o/libhex3.c	1970-01-01 02:00:00.000000000 +0200
+++ cgminer_hex/libhex3.c	2014-09-22 19:28:38.671387123 +0300
@@ -0,0 +1,296 @@
+/*$T indentinput.c GC 1.140 10/16/13 10:20:34 */
+#define rotate(x, y)	((x << y) | (x >> (sizeof(x) * 8 - y)))
+#define rotr(x, y)		((x >> y) | (x << (sizeof(x) * 8 - y)))
+#define R(a, b, c, d, e, f, g, h, w, k) \
+		h = h + \
+		(rotate(e, 26) ^ rotate(e, 21) ^ rotate(e, 7)) + \
+		(g ^ (e & (f ^ g))) + \
+		k + \
+		w; \
+	d = d + h; \
+	h = h + (rotate(a, 30) ^ rotate(a, 19) ^ rotate(a, 10)) + ((a & b) | (c & (a | b)))
+const uint32_t SHA256_K3[3] = { 0x428a2f98, 0x71374491, 0xb5c0fbcf };
+
+static int64_t
+timediff (const struct timeval *a, const struct timeval *b)
+{
+  struct timeval diff;
+  timersub (a, b, &diff);
+  return diff.tv_sec * 1000000 + diff.tv_usec;
+}
+
+static void
+reajust_timings3 (struct cgpu_info *hexminer3)
+{
+  struct hexminer3_info *info = hexminer3->device_data;
+  int i = 0;
+  int chips = 0;
+  while (i < HEX3_DEFAULT_ASIC_NUM)
+    if (!info->chip_is_dead[i++])
+      chips++;
+  if (chips == 0)
+    chips = 6;
+  info->wsem_ustiming =
+    (int64_t) (0x100000000ll / (chips * 1.7275 * info->frequency));
+}
+
+static bool
+libhex3_cachenonce (struct chip_results3 *nonce_cache, uint32_t nonce)
+{
+  int i = 0;
+  while (i < HEX3_NONCE_CASH_SIZE && nonce_cache->nonces[i] != nonce)
+    i++;
+  if (i < HEX3_NONCE_CASH_SIZE)
+    return false;
+  if (nonce_cache->nonce_cache_write_pos == HEX3_NONCE_CASH_SIZE)
+    nonce_cache->nonce_cache_write_pos = 0;
+  nonce_cache->nonces[nonce_cache->nonce_cache_write_pos++] = nonce;
+  return true;
+}
+
+static void
+libhex3_calc_hexminer (struct work *work, struct hexminer3_task *ht)
+{
+  uint32_t a0a1a2e0e1e2[6];
+  uint32_t A, B, C, D, E, F, G, H;
+  uint32_t state[8];
+  uint32_t data[3];
+  memcpy (&state, work->midstate, 32);
+  memcpy (&data, work->data + 64, 12);
+
+#if defined(__BIG_ENDIAN__) || defined(MIPSEB)
+  int i;
+  for (i = 0; i < 8; i++)
+    state[i] = htole32 (state[i]);
+  for (i = 0; i < 3; i++)
+    data[i] = htole32 (data[i]);
+
+#endif
+  A = state[0];
+  B = state[1];
+  C = state[2];
+  D = state[3];
+  E = state[4];
+  F = state[5];
+  G = state[6];
+  H = state[7];
+  R (A, B, C, D, E, F, G, H, data[0], SHA256_K3[0]);
+  a0a1a2e0e1e2[0] = htole32 (H);
+  a0a1a2e0e1e2[3] = htole32 (D);
+  R (H, A, B, C, D, E, F, G, data[1], SHA256_K3[1]);
+  a0a1a2e0e1e2[1] = htole32 (G);
+  a0a1a2e0e1e2[4] = htole32 (C);
+  R (G, H, A, B, C, D, E, F, data[2], SHA256_K3[2]);
+  a0a1a2e0e1e2[2] = htole32 (F);
+  a0a1a2e0e1e2[5] = htole32 (B);
+  memcpy (&ht->a0, &a0a1a2e0e1e2[0], 4);
+  memcpy (&ht->a1, &a0a1a2e0e1e2[1], 4);
+  memcpy (&ht->a2, &a0a1a2e0e1e2[2], 4);
+  memcpy (&ht->e0, &a0a1a2e0e1e2[3], 4);
+  memcpy (&ht->e1, &a0a1a2e0e1e2[4], 4);
+  memcpy (&ht->e2, &a0a1a2e0e1e2[5], 4);
+}
+
+static void
+libhex3_csum (unsigned char *startptr, unsigned char *endptr,
+              unsigned char *resptr)
+{
+  unsigned char *b = startptr;
+  uint8_t sum = 0;
+  while (b < endptr)
+    sum += *b++;
+  memcpy (resptr, &sum, 1);
+}
+
+
+static bool
+libhex3_usb_dead (struct cgpu_info *hexminer3)
+{
+  struct cg_usb_device *usbdev;
+  struct hexminer3_info *info = hexminer3->device_data;
+  if (!info)
+    return true;
+  usbdev = hexminer3->usbdev;
+  bool ret = (usbdev == NULL || usbdev->handle == NULL || hexminer3->shutdown
+              || info->shut_read || info->shut_write || info->shut_reset
+              || hexminer3->usbinfo.nodev || hexminer3->deven != DEV_ENABLED);
+  return ret;
+}
+
+static int
+libhex3_sendHashData (struct cgpu_info *hexminer3, unsigned char *sendbuf,
+                      size_t buf_len)
+{
+  struct hexminer3_info *info = hexminer3->device_data;
+  struct cg_usb_device *usbdev;
+  int wrote = 0, written = 0;
+  int err = LIBUSB_SUCCESS;
+  usbdev = hexminer3->usbdev;
+  if (libhex3_usb_dead (hexminer3))
+    goto out;
+  while (written < buf_len && err == LIBUSB_SUCCESS)
+    {
+      err =
+        libusb_bulk_transfer (usbdev->handle, 0x02, sendbuf + written,
+                              MIN (HEX3_USB_WR_SIZE, buf_len - written),
+                              &wrote, HEX3_USB_WR_TIME_OUT);
+      if (err == LIBUSB_SUCCESS)
+        written += wrote;
+    }
+out:
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+    info->shut_write = true;
+  return written;
+}
+
+static void
+libhex3_reset (struct cgpu_info *hexminer3)
+{
+  struct hexminer3_info *info = hexminer3->device_data;
+  struct cg_usb_device *usbdev;
+  int err = LIBUSB_SUCCESS;
+  usbdev = hexminer3->usbdev;
+  if (libhex3_usb_dead (hexminer3))
+    goto out;
+  err = libusb_reset_device (usbdev->handle);
+out:
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+    info->shut_reset = true;
+  info->usb_reset_count++;
+}
+
+static int
+libhex3_readHashData (struct cgpu_info *hexminer3, unsigned char *hash,
+                      int *hash_write_pos, int timeout)
+{
+  struct hexminer3_info *info = hexminer3->device_data;
+  struct cg_usb_device *usbdev;
+  int read = 0;
+  int err = LIBUSB_SUCCESS;
+  usbdev = hexminer3->usbdev;
+  if (libhex3_usb_dead (hexminer3))
+    goto out;
+  err =
+    libusb_bulk_transfer (usbdev->handle, 0x82, hash + *hash_write_pos,
+                          HEX3_USB_R_SIZE, &read, timeout);
+  if (err == LIBUSB_SUCCESS)
+    *hash_write_pos += MIN (read, HEX3_USB_R_SIZE);
+out:
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+    info->shut_read = true;
+  return err;
+}
+
+extern bool submit_tested_work_fast_clone (struct thr_info *thr,
+                                           struct work *work, bool diff1);
+static int
+hexminer3_predecode_nonce (struct cgpu_info *hexminer3, struct thr_info *thr,
+                           uint32_t nonce, uint8_t work_id)
+{
+  struct hexminer3_info *info = hexminer3->device_data;
+  if (info->hexworks[work_id]->pool == NULL)
+    return 0;
+  if (test_nonce (info->hexworks[work_id], nonce))
+    {
+      submit_tested_work_fast_clone (thr, info->hexworks[work_id], true);
+      return 1;
+    }
+  return 0;
+}
+
+static void
+libhex3_getvoltage (uint16_t wr_bukvoltage, int *info_pic_voltage_readings)
+{
+  float voltagehuman;
+  voltagehuman =
+    (float) ((float) wr_bukvoltage * (float) 3300 / (float) ((1 << 12) - 1));
+  *info_pic_voltage_readings = (int) voltagehuman;
+}
+
+static void
+libhex3_setvoltage (int info_voltage, uint16_t * refvoltage)
+{
+  uint16_t voltageadc;
+  voltageadc =
+    (uint16_t) ((float) info_voltage / (float) 1000 / (float) 3.3 *
+                ((1 << 12) - 1));
+  *refvoltage = htole16 (voltageadc);
+}
+
+static void
+libhex3_generatenrange_new (unsigned char *buf, int asic_num)
+{
+  uint32_t nonceAdd;
+  int noncePos;
+  int64_t nonceCalc = 0x100000000ll;
+  nonceCalc /= asic_num;
+  nonceAdd = (uint32_t) nonceCalc;
+  uint32_t chip_noce;
+  for (noncePos = 0; noncePos < asic_num; noncePos++)
+    {                           /* * chip_noce = htole32(noncePos * nonceAdd);
+                                 */
+      chip_noce = noncePos * nonceAdd;
+      memcpy (buf + noncePos * 4, &chip_noce, 4);
+    }
+}
+
+static int
+libhex3_eatHashData (struct work3_result *wr, unsigned char *hash,
+                     int *hash_read_pos, int *hash_write_pos)
+{
+  uint8_t psum;
+  int wrpos;
+  unsigned char *csum_pos;
+  bool ok;
+eat:
+  while (*hash_read_pos < *hash_write_pos && hash[*hash_read_pos] != 0x53)
+    {
+      *hash_read_pos += 1;
+    }
+  if (*hash_write_pos - *hash_read_pos < 8)
+    return HEX3_BUF_SKIP;
+  memcpy ((char *) &wr->startbyte, &hash[*hash_read_pos],
+          HEX3_BASE_WORK_SIZE - 1);
+  wr->address = htole16 (wr->address);
+  ok = (wr->command == 0x52) &&
+    ((wr->address == HEX3_WORKANSWER_ADR && wr->datalength == 0x05)
+     || (wr->address == 0x3008 && wr->datalength == 1));
+  if (!ok)
+    {
+      *hash_read_pos += 1;
+      goto eat;
+    }
+  if (*hash_write_pos - *hash_read_pos <
+      HEX3_BASE_WORK_SIZE + wr->datalength * 2)
+    return HEX3_BUF_SKIP;
+  csum_pos =
+    hash + *hash_read_pos + HEX3_BASE_WORK_SIZE + wr->datalength * 2 - 1;
+  libhex3_csum (hash + *hash_read_pos, csum_pos, &psum);
+  if (psum != *csum_pos)
+    {
+      *hash_read_pos += 1;
+      return HEX3_BUF_ERR;
+    }
+  wrpos = (wr->address - HEX3_WORKANSWER_ADR) + HEX3_BASE_WORK_SIZE - 1;
+  memcpy ((char *) &wr->startbyte + wrpos,
+          &hash[*hash_read_pos + HEX3_BASE_WORK_SIZE - 1],
+          wr->datalength * 2);
+  *hash_read_pos += HEX3_BASE_WORK_SIZE + wr->datalength * 2;
+  return HEX3_BUF_DATA;
+}
+
+static void
+libhex3_set_word (struct cgpu_info *hexminer3, uint16_t address,
+                  uint16_t word)
+{
+  unsigned char status[10];
+  uint16_t wr_adr = htole16 (address);
+  uint16_t ledata = htole16 (word);
+  status[0] = 0x53;
+  status[1] = 0x01;
+  status[2] = 0x57;
+  memcpy (status + 3, &wr_adr, 2);
+  memcpy (status + 5, &ledata, 2);
+  libhex3_csum (status, status + 7, status + 7);
+  libhex3_sendHashData (hexminer3, status, 8);
+}
--- cg_o/driver-hexminer3.c	1970-01-01 02:00:00.000000000 +0200
+++ cgminer_hex/driver-hexminer3.c	2014-09-22 19:28:38.671387123 +0300
@@ -0,0 +1,620 @@
+/*$T indentinput.c GC 1.140 10/16/13 10:19:47 */
+#include "config.h"
+#include <limits.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <ctype.h>
+#include <dirent.h>
+#include <unistd.h>
+#ifndef WIN32
+#include <sys/select.h>
+#include <termios.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#ifndef O_CLOEXEC
+#define O_CLOEXEC 0
+#endif
+#else
+#include "compat.h"
+#include <windows.h>
+#include <io.h>
+#endif
+#include "elist.h"
+#include "miner.h"
+#include "usbutils.h"
+#include "driver-hexminer3.h"
+#include "util.h"
+extern unsigned int work_block;
+extern unsigned int work_pool_update;
+extern struct work *copy_work_noffset_fast_no_id (struct work *base_work,
+                                                  int noffset);
+extern bool stale_work (struct work *work, bool share);
+struct device_drv hexminer3_drv;
+extern bool no_work;
+int opt_hexminer3_chip_mask = 0xFF;
+int opt_hexminer3_core_voltage = HEX3_DEFAULT_CORE_VOLTAGE;
+#include "libhex3.c"
+
+static int
+hexminer3_send_task (struct hexminer3_task *ht, struct cgpu_info *hexminer3)
+{
+  int ret = 0;
+  size_t nr_len = HEXMINER3_TASK_SIZE;
+  struct hexminer3_info *info;
+  info = hexminer3->device_data;
+  libhex3_csum (&ht->startbyte, &ht->csum, &ht->csum);
+  ret = libhex3_sendHashData (hexminer3, &ht->startbyte, nr_len);
+  if (ret != nr_len)
+    {
+      libhex3_reset (hexminer3);
+      info->usb_w_errors++;
+      return -1;
+    }
+  return ret;
+}
+
+static inline void
+hexminer3_create_task (bool reset_work, struct hexminer3_task *ht,
+                       struct work *work)
+{
+  if (reset_work)
+    ht->status = HEX3_STAT_NEW_WORK_CLEAR_OLD;
+  else
+    ht->status = HEX3_STAT_NEW_WORK;
+  memcpy (ht->midstate, work->midstate, 32);
+  memcpy (ht->merkle, work->data + 64, 12);
+  ht->id = (uint8_t) work->subid;
+  libhex3_calc_hexminer (work, ht);
+}
+
+static inline void
+hexminer3_init_task_c (struct hexminer3_config_task *htc,
+                       struct hexminer3_info *info)
+{
+  htc->startbyte = 0x53;
+  htc->datalength =
+    (uint8_t) ((sizeof (struct hexminer3_config_task) - 6 - 2) / 2);
+  htc->command = 0x57;
+  htc->address = htole16 (0x30C0);
+  htc->hashclock = htole16 ((uint16_t) info->frequency);
+  libhex3_setvoltage (info->core_voltage, &htc->refvoltage);
+  htc->chip_mask = (uint8_t) info->chip_mask;
+  htc->chipcount = htole16 (info->asic_count);
+  libhex3_csum (&htc->startbyte, &htc->csum, &htc->csum);
+}
+
+static inline void
+hexminer3_init_task (struct hexminer3_task *ht, struct hexminer3_info *info)
+{
+  ht->startbyte = 0x53;
+  ht->datalength = (uint8_t) ((HEXMINER3_TASK_SIZE - 6) / 2);
+  ht->command = 0x57;
+  ht->address = htole16 (0x3080);
+  ht->status = HEX3_STAT_NEW_WORK_CLEAR_OLD;
+}
+
+#ifdef PWR_HEX3
+static bool
+need_reset (struct cgpu_info *hexminer3)
+{
+  if (no_work)
+    return false;
+  struct hexminer3_info *info = hexminer3->device_data;
+  time_t now = time (NULL);
+  bool ret = false;
+  int i = 0;
+  int secs = 20;
+  while (i < info->asic_count)
+    {
+      if (!info->chip_is_dead[i]
+          && (info->chip_con_resets[i] < 5 && info->matching_work[i])
+          && ((info->last_chip_valid_work[i] + secs) < now))
+        {
+          ret = true;
+          info->chip_con_resets[i]++;
+          info->last_chip_valid_work[i] = now;
+          if (info->chip_con_resets[i] == 5)
+            {
+              info->chip_is_dead[i] = true;
+            }
+          break;
+        }
+      info->chip_con_resets[i] = 0;
+      i++;
+    }
+  reajust_timings3 (hexminer3);
+  info->timing_adjusted = true;
+  return ret;
+}
+#endif
+
+static struct cgpu_info *
+hexminer3_detect_one (libusb_device * dev, struct usb_find_devices *found)
+{
+  int asic_count, frequency;
+  struct hexminer3_info *info;
+  struct cgpu_info *hexminer3;
+  bool configured = false;
+  int i = 0;
+  hexminer3 = usb_alloc_cgpu (&hexminer3_drv, HEX3_MINER_THREADS);
+  if (!usb_init (hexminer3, dev, found))
+    {
+      usb_uninit (hexminer3);
+      return NULL;
+    }
+  hexminer3->device_data = calloc (sizeof (struct hexminer3_info), 1);
+  if (unlikely (!(hexminer3->device_data)))
+    {
+      hexminer3->device_data = NULL;
+      usb_uninit (hexminer3);
+      return NULL;
+    }
+  if (opt_hexminerc_options != NULL)
+  	configured = (sscanf(opt_hexminerc_options, "%d:%d", &asic_count, &frequency) == 2);	
+  
+  if (opt_hexminer3_core_voltage < HEX3_MIN_COREMV
+      || opt_hexminer3_core_voltage > HEX3_MAX_COREMV)
+    {
+      applog (LOG_ERR, "Invalid hexminer3-voltage %d must be %dmV - %dmV",
+              opt_hexminer3_core_voltage, HEX3_MIN_COREMV, HEX3_MAX_COREMV);
+      free (hexminer3->device_data);
+      hexminer3->device_data = NULL;
+      usb_uninit (hexminer3);
+      return NULL;
+    }
+  info = hexminer3->device_data;
+  info->hexworks = calloc (sizeof (struct work *), HEXMINER3_ARRAY_SIZE);
+  if (unlikely (!(info->hexworks)))
+    {
+      free (hexminer3->device_data);
+      hexminer3->device_data = NULL;
+      usb_uninit (hexminer3);
+      return NULL;
+    }
+  info->wr = (struct work3_result *) malloc (sizeof (struct work3_result));
+  info->array_nonce_cache = calloc (16, sizeof (struct chip_results3));
+  info->readbuf = calloc (HEX3_HASH_BUF_SIZE, sizeof (unsigned char));
+  info->hash_read_pos = 0;
+  info->hash_write_pos = 0;
+  info->shut_read = false;
+  info->shut_write = false;
+  info->shut_reset = false;
+  info->miner_count = HEX3_DEFAULT_MINER_NUM;
+  info->asic_count = HEX3_DEFAULT_ASIC_NUM;
+  info->frequency = HEX3_DEFAULT_FREQUENCY;
+  info->pic_voltage_readings = HEX3_DEFAULT_CORE_VOLTAGE;
+  info->core_voltage = opt_hexminer3_core_voltage;
+  info->chip_mask = opt_hexminer3_chip_mask;
+  info->wr->buf_empty_space = 63;
+  info->work_block_local = -1;
+  info->work_pool_update = -1;
+  info->reset_work = true;
+  info->jobs_to_send = 20;
+  info->roll = 0;
+  info->timing_adjusted = false;
+  info->ht = calloc (sizeof (struct hexminer3_task), 1);
+  info->work = NULL;
+  info->write_pos = 0;
+  if (configured)
+    {
+      info->asic_count = asic_count;
+      info->frequency = frequency;
+    }
+  hexminer3_init_task (info->ht, info);
+  gettimeofday (&info->last_wr, NULL);
+  info->wsem_ustiming =
+    (int64_t) (0x100000000ll / (info->asic_count * 1.7275 * info->frequency));
+  if (!add_cgpu (hexminer3))
+    {
+      free (info->hexworks);
+      free (hexminer3->device_data);
+      hexminer3->device_data = NULL;
+      hexminer3 = usb_free_cgpu (hexminer3);
+      usb_uninit (hexminer3);
+      return NULL;
+    }
+  while (i < HEXMINER3_ARRAY_SIZE)
+    {
+      info->hexworks[i] = calloc (1, sizeof (struct work));
+      info->hexworks[i]->pool = NULL;
+      i++;
+    } i = 0;
+  info->power_checked = time (NULL);
+  while (i < HEX3_DEFAULT_ASIC_NUM)
+    info->chip_is_dead[i++] = false;
+  libhex3_generatenrange_new ((unsigned char *) &info->nonces_range,
+                              info->asic_count);
+  return hexminer3;
+}
+
+static void
+hexminer3_detect (bool __maybe_unused hotplug)
+{
+  usb_detect (&hexminer3_drv, hexminer3_detect_one);
+}
+
+static void
+do_hexminer3_close (struct thr_info *thr)
+{
+  struct cgpu_info *hexminer3 = thr->cgpu;
+  struct hexminer3_info *info = hexminer3->device_data;
+  int i = 0;
+  while (i < HEXMINER3_ARRAY_SIZE)
+    {
+      free_work (info->hexworks[i]);
+      i++;
+    }
+  free (info->hexworks);
+  free (info->readbuf);
+  free (info->array_nonce_cache);
+  free (info->wr);
+  free (info->ht);
+  if (info->work)
+    free_work (info->work);
+}
+
+static void
+hexminer3_shutdown (struct thr_info *thr)
+{
+  struct cgpu_info *hexminer3 = thr->cgpu;
+  do_hexminer3_close (thr);
+  usb_nodev (hexminer3);
+}
+
+static bool
+hexminer3_thread_init (struct thr_info *thr)
+{
+  struct cgpu_info *hexminer3 = thr->cgpu;
+  struct hexminer3_info *info = hexminer3->device_data;
+  info->thr = thr;
+  libhex3_set_word (hexminer3, 0x3080 + HEXMINER3_TASK_SIZE - 8, 0x0004);
+  cgsleep_ms (100);
+  struct hexminer3_config_task *htc;
+  htc = calloc (sizeof (struct hexminer3_config_task), 1);
+  hexminer3_init_task_c (htc, info);
+  int ret = libhex3_sendHashData (hexminer3, &htc->startbyte,
+                                  sizeof (struct hexminer3_config_task) - 2);
+  if (ret != sizeof (struct hexminer3_config_task) - 2)
+    applog (LOG_ERR, "HEX3 %i Send config failed", hexminer3->device_id);
+  free (htc);
+  ret = hexminer3_send_task (info->ht, hexminer3);
+  cgsleep_ms (200);
+  return true;
+}
+
+static void
+do_write_hex3 (struct thr_info *thr)
+{
+  struct cgpu_info *hexminer3 = thr->cgpu;
+  struct hexminer3_info *info = hexminer3->device_data;
+  struct work *tmpwork = NULL;
+  bool power;
+  int jobs_to_send = info->jobs_to_send;
+  int send_jobs, ret;
+
+#ifdef PWR_HEX3
+  if (time (NULL) - info->power_checked > 30)
+    {
+      info->power_checked = time (NULL);
+      power = need_reset (hexminer3);
+      if (power)
+        {
+          info->b_reset_count++;
+          libhex3_set_word (hexminer3, 0x3080 + HEXMINER3_TASK_SIZE - 8,
+                            0x0004);
+          cgsleep_ms (100);
+          struct hexminer3_config_task *htc;
+          htc = calloc (sizeof (struct hexminer3_config_task), 1);
+          hexminer3_init_task_c (htc, info);
+          ret =
+            libhex3_sendHashData (hexminer3, &htc->startbyte,
+                                  sizeof (struct hexminer3_config_task) - 2);
+          if (ret != sizeof (struct hexminer3_config_task) - 2)
+            applog (LOG_ERR, "HEX3 %i Send config failed",
+                    hexminer3->device_id);
+          free (htc);
+          hexminer3_init_task (info->ht, info);
+          ret = hexminer3_send_task (info->ht, hexminer3);
+          cgsleep_ms (200);
+          gettimeofday (&info->last_wr, NULL);
+          info->reset_work = true;
+          jobs_to_send = 20;
+        }
+    }
+#endif
+  send_jobs = 0;
+  while (!libhex3_usb_dead (hexminer3) && (send_jobs < jobs_to_send))
+    {
+    again:
+      if (!info->work)
+        {
+          info->roll = 0;
+          info->work = get_work (thr, thr->id);
+          info->work->ping = 1;
+          if (info->work_block_local != work_block || info->work_pool_update != work_pool_update)
+            {
+              info->reset_work = true;
+              send_jobs = 0;
+              jobs_to_send = 20;
+              info->work_block_local = work_block;
+              info->work_pool_update = work_pool_update;
+            }
+        }
+      if (stale_work (info->work, false))
+        {
+          free_work (info->work);
+          info->work = NULL;
+          goto again;
+        }
+      if (info->write_pos >= HEXMINER3_ARRAY_SIZE_REAL || info->reset_work)
+        info->write_pos = 0;
+      info->work->subid = info->write_pos;
+      tmpwork = copy_work_noffset_fast_no_id (info->work, info->roll++);
+      hexminer3_create_task (info->reset_work, info->ht, tmpwork);
+      free_work (info->hexworks[info->write_pos]);
+      info->hexworks[info->write_pos] = tmpwork;
+      if (info->work->drv_rolllimit)
+        info->work->drv_rolllimit--;
+      else
+        {
+          free_work (info->work);
+          info->work = NULL;
+        }
+      ret = hexminer3_send_task (info->ht, hexminer3);
+      info->write_pos++;
+      send_jobs++;
+      if (ret == HEXMINER3_TASK_SIZE && info->reset_work)
+        {
+          info->reset_work = false;
+          gettimeofday (&info->last_wr, NULL);
+        }
+    }
+}
+
+static int64_t
+hexminer3_scanhash (struct thr_info *thr)
+{
+  struct cgpu_info *hexminer3 = thr->cgpu;
+  struct hexminer3_info *info = hexminer3->device_data;
+  uint32_t nonce;
+  double found;
+  double hash_count = 0;
+  int i = 0, lastchippos = 0;
+  int ret_r = 0;
+  int64_t rethash_count = 0;
+  int64_t tdif;
+  int rminder = 0;
+  struct timeval now;
+  struct timeval diff;
+  if (info->work_block_local != work_block || info->work_pool_update != work_pool_update)
+    {
+      info->reset_work = true;
+      info->jobs_to_send = 20;
+      info->work_block_local = work_block;
+      info->work_pool_update = work_pool_update;
+      if (info->work)
+        {
+          free_work (info->work);
+          info->work = NULL;
+        }
+      gettimeofday (&info->last_wr, NULL);
+      do_write_hex3 (thr);
+      goto done_wr;
+    }
+  gettimeofday (&now, NULL);
+  tdif = timediff (&now, &info->last_wr);
+  info->jobs_to_send = (int) (tdif / info->wsem_ustiming);
+  rminder = (int) (tdif % info->wsem_ustiming);
+  if (info->jobs_to_send > 0 || info->wr->buf_empty_space > 45)
+    {
+      gettimeofday (&info->last_wr, NULL);
+      if (info->wr->buf_empty_space < 25)
+        {
+          goto done_wr;
+        }
+      now.tv_sec = 0;
+      now.tv_usec = rminder;
+      timersub (&info->last_wr, &now, &diff);
+      memcpy (&info->last_wr, &diff, sizeof (struct timeval));
+      if (info->wr->buf_empty_space > 45)
+        info->jobs_to_send++;
+      if (info->jobs_to_send > 20)
+        info->jobs_to_send = 20;
+      do_write_hex3 (thr);
+    }
+done_wr:
+  if (libhex3_usb_dead (hexminer3))
+    {
+      hexminer3->shutdown = true;
+      return -1;
+    }
+  if (info->hash_write_pos + HEX3_USB_R_SIZE > HEX3_HASH_BUF_SIZE_OK)
+    {
+      info->hash_write_pos = info->hash_write_pos - info->hash_read_pos;
+      memcpy (info->readbuf, info->readbuf + info->hash_read_pos,
+              info->hash_write_pos);
+      info->hash_read_pos = 0;
+    }
+  if (info->hash_write_pos - info->hash_read_pos > 7)
+    {
+    again:
+    	if (info->work_block_local != work_block || info->work_pool_update != work_pool_update)
+    		goto new_block;
+      ret_r =
+        libhex3_eatHashData (info->wr, info->readbuf, &info->hash_read_pos,
+                             &info->hash_write_pos);
+      if (ret_r > HEX3_BUF_DATA)
+        goto out;
+      if (info->wr->datalength == 1)
+        goto done;
+      if (info->wr->lastnonceid > HEXMINER3_ARRAY_SIZE_REAL)
+        info->wr->lastnonceid = 0;
+      nonce = htole32 (info->wr->lastnonce);
+      i = 0;
+      while (i < info->asic_count)
+        {
+          if (nonce < info->nonces_range[++i])
+            {
+              lastchippos = --i;
+              break;
+            }
+        }
+      if (i == info->asic_count)
+        lastchippos = info->asic_count - 1;
+      if (libhex3_cachenonce
+          (&info->array_nonce_cache[lastchippos], info->wr->lastnonce))
+        {
+          found =
+            hexminer3_predecode_nonce (hexminer3, thr, nonce,
+                                       info->wr->lastnonceid);
+          if (found > 0)
+            {
+#ifdef PWR_HEX3
+              info->last_chip_valid_work[(uint8_t) lastchippos] = time (NULL);
+
+#endif
+              if (hash_count == 0)
+                libhex3_getvoltage (htole16 (info->wr->lastvoltage),
+                                    &info->pic_voltage_readings);
+              hash_count += found;
+              info->matching_work[(uint8_t) lastchippos]++;
+            }
+          else
+            inc_hw_errors (thr);
+        }
+      else
+        info->dupe[(uint8_t) lastchippos]++;
+    out:
+      if (ret_r == HEX3_BUF_ERR)
+        info->usb_r_errors++;
+    done:
+      if (ret_r != HEX3_BUF_SKIP)
+        goto again;
+    }
+  if (info->work_block_local != work_block || info->work_pool_update != work_pool_update)
+    		goto new_block;
+  ret_r =
+    libhex3_readHashData (hexminer3, info->readbuf, &info->hash_write_pos,
+                          HEXMINER3_BULK_READ_TIMEOUT);
+  if (ret_r != LIBUSB_SUCCESS)
+    info->usb_bad_reads++;
+  else
+    info->usb_bad_reads = 0;
+  if (info->usb_bad_reads > 20)
+    libhex3_reset (hexminer3);
+  new_block:
+  rethash_count = (0xffffffffull * (int64_t) hash_count);
+  if (libhex3_usb_dead (hexminer3))
+    {
+      hexminer3->shutdown = true;
+      return -1;
+    }
+  return rethash_count;
+}
+
+#ifdef DBG_HEX3
+static void
+zero_hexminer3_stats (struct cgpu_info *hexminer3)
+{
+  if (!hexminer3->device_data)
+    return;
+  struct hexminer3_info *info = hexminer3->device_data;
+  int i;
+  for (i = 0; i < info->asic_count; i++)
+    {
+      info->matching_work[i] = 0;
+      info->dupe[i] = 0;
+    }
+}
+#endif
+
+static void
+get_hexminer3_statline_before (char *buf, size_t bufsiz,
+                               struct cgpu_info *hexminer3)
+{
+  if (!hexminer3->device_data)
+    return;
+  struct hexminer3_info *info = hexminer3->device_data;
+  tailsprintf (buf, bufsiz, "%3d %4d/%4dmV", info->frequency,
+               info->core_voltage, info->pic_voltage_readings);
+}
+
+extern void suffix_string (uint64_t val, char *buf, size_t bufsiz,
+                           int sigdigits);
+
+static struct api_data *
+hexminer3_api_stats (struct cgpu_info *cgpu)
+{
+  struct api_data *root = NULL;
+  struct timeval now;
+  struct hexminer3_info *info = cgpu->device_data;
+  char displayed_hashes[16], displayed_rolling[16];
+  double dev_runtime, hwp;
+  uint64_t dh64, dr64;
+  int i;
+  if (!info)
+    return NULL;
+  hwp =
+    (cgpu->hw_errors +
+     cgpu->diff1) ? (double) (cgpu->hw_errors) / (double) (cgpu->hw_errors +
+                                                           cgpu->diff1) : 0;
+  if (cgpu->dev_start_tv.tv_sec == 0)
+    dev_runtime = total_secs;
+  else
+    {
+      cgtime (&now);
+      dev_runtime = tdiff (&now, &(cgpu->dev_start_tv));
+    }
+  if (dev_runtime < 1.0)
+    dev_runtime = 1.0;
+  dh64 = (double) cgpu->total_mhashes / dev_runtime * 1000000ull;
+  dr64 = (double) cgpu->rolling * 1000000ull;
+  suffix_string (dh64, displayed_hashes, sizeof (displayed_hashes), 4);
+  suffix_string (dr64, displayed_rolling, sizeof (displayed_rolling), 4);
+  root = api_add_string (root, "MHS 5s", displayed_rolling, true);
+  root = api_add_string (root, "MHS av", displayed_hashes, true);
+  root = api_add_int (root, "Hardware Errors", &(cgpu->hw_errors), true);
+  root = api_add_percent (root, "Hardware Errors%", &hwp, true);
+  root = api_add_int (root, "USB Read Errors", &(info->usb_r_errors), true);
+  root = api_add_int (root, "USB Write Errors", &(info->usb_w_errors), true);
+  root =
+    api_add_int (root, "USB Reset Count", &(info->usb_reset_count), true);
+  root =
+    api_add_int (root, "Miner Reset Count", &(info->b_reset_count), true);
+  root =
+    api_add_time (root, "Last Share Time", &(cgpu->last_share_pool_time),
+                  true);
+  root = api_add_int (root, "Chip Count", &(info->asic_count), true);
+  root = api_add_int (root, "Frequency", &(info->frequency), true);
+  root = api_add_int (root, "Core Voltage", &(info->core_voltage), true);
+  root =
+    api_add_int (root, "PIC Voltage Readings", &(info->pic_voltage_readings),
+                 true);
+  for (i = 0; i < info->asic_count; i++)
+    {
+      char mcw[24];
+      sprintf (mcw, "Chip%d Nonces", i + 1);
+      root = api_add_int (root, mcw, &(info->matching_work[i]), true);
+      sprintf (mcw, "Chip%d Dupes", i + 1);
+      root = api_add_int (root, mcw, &(info->dupe[i]), true);
+    }
+  return root;
+}
+
+struct device_drv hexminer3_drv = {
+  .drv_id = DRIVER_hexminer3,
+  .dname = "hexminer3",
+  .name = "HEX3",
+  .drv_detect = hexminer3_detect,
+  .thread_init = hexminer3_thread_init,
+  .hash_work = hash_driver_work,
+  .scanwork = hexminer3_scanhash,
+  .get_api_stats = hexminer3_api_stats,
+  .get_statline_before = get_hexminer3_statline_before,
+#ifdef DBG_HEX3
+  .zero_stats = zero_hexminer3_stats,
+#endif
+  .thread_shutdown = hexminer3_shutdown,
+};
--- cg_o/driver-hexminer3.h	1970-01-01 02:00:00.000000000 +0200
+++ cgminer_hex/driver-hexminer3.h	2014-09-22 19:28:38.671387123 +0300
@@ -0,0 +1,153 @@
+/*$T indentinput.h GC 1.140 10/16/13 10:20:01 */
+#ifndef HEX3_H
+#define HEX3_H
+#ifdef USE_HEXMINER3
+#include "util.h"
+
+/* hexminer3_task/work_reply status Definitions: */
+#define DBG_HEX3
+#define PWR_HEX3
+#define HEX3_STAT_IDLE 0        /* Idle or data already Sent to the buffer */
+#define HEX3_STAT_NEW_WORK 1    /* Request for write in the buffer */
+#define HEX3_STAT_WAITING 2     /* Wait For Buffer Empty Position */
+#define HEX3_STAT_CLR_BUFF 3    /* Force Buffer Empty */
+#define HEX3_STAT_STOP_REQ 4    /* Stop Request */
+#define HEX3_STAT_NEW_WORK_CLEAR_OLD 5  /* Clear Buffers and after that fill the first buffer */
+#define HEX3_STAT_UNUSED 6
+
+/* libhex3_eatHashData/BUF_reply status Definitions: */
+#define HEX3_BUF_DATA 0
+#define HEX3_BUF_ERR 1
+#define HEX3_BUF_SKIP 2
+
+ /*MISC*/
+#define HEXMINER3_ARRAY_PIC_SIZE 64
+#define HEXMINER3_ARRAY_SIZE HEXMINER3_ARRAY_PIC_SIZE * 4
+#define HEXMINER3_ARRAY_SIZE_REAL HEXMINER3_ARRAY_SIZE - 2
+#define HEX3_NONCE_CASH_SIZE 16
+#define HEX3_USB_R_SIZE 64
+#define HEX3_USB_WR_SIZE 64
+#define HEX3_HASH_BUF_SIZE 1024
+#define HEX3_HASH_BUF_SIZE_OK HEX3_HASH_BUF_SIZE - 4
+#define HEXMINER3_BULK_READ_TIMEOUT 1000
+#define HEX3_USB_WR_TIME_OUT 500
+#define HEX3_MINER_THREADS 1
+#define HEX3_DEFAULT_MINER_NUM 0x01
+#define HEX3_DEFAULT_ASIC_NUM 0x10
+#define HEX3_MIN_FREQUENCY 5000
+#define HEX3_MAX_FREQUENCY 10000
+#define HEX3_DEFAULT_FREQUENCY 7000
+#define HEX3_DEFAULT_CORE_VOLTAGE 850   /* in millivolts */
+#define HEX3_MIN_COREMV 600     /* in millivolts */
+#define HEX3_MAX_COREMV 1100    /* in millivolts */
+struct chip_results3
+{
+  uint8_t nonce_cache_write_pos;
+  uint32_t nonces[HEX3_NONCE_CASH_SIZE];
+};
+struct work3_result
+{
+  uint8_t startbyte;
+  uint8_t datalength;
+  uint8_t command;
+  uint16_t address;
+  uint32_t lastnonce;
+  uint8_t lastnonceid;
+  uint8_t status;
+  uint16_t lastvoltage;
+  uint8_t lastchippos;
+  uint8_t buf_empty_space;
+  uint16_t dum;
+  uint32_t word1;
+  uint32_t word2;
+  uint8_t csum;
+  uint16_t dum1;
+} __attribute__ ((packed, aligned (4)));
+struct hexminer3_task
+{
+  uint8_t startbyte;
+  uint8_t datalength;
+  uint8_t command;
+  uint16_t address;
+  uint32_t merkle[3];
+  uint32_t a1;
+  uint32_t a0;
+  uint32_t e2;
+  uint32_t e1;
+  uint32_t e0;
+  uint8_t midstate[32];
+  uint32_t a2;
+  uint8_t id;
+  uint8_t status;
+  uint8_t csum;
+} __attribute__ ((packed, aligned (4)));
+struct hexminer3_info
+{
+  struct timeval last_wr;
+  int jobs_to_send;
+  int64_t wsem_ustiming;
+  bool timing_adjusted;
+  bool reset_work;
+  int write_pos;
+  int roll;
+  int usb_bad_reads;
+  bool shut_read;
+  bool shut_write;
+  bool shut_reset;
+  int chip_mask;
+  int miner_count;
+  int asic_count;
+  int core_voltage;
+  int frequency;
+  int usb_r_errors;
+  int usb_w_errors;
+  int usb_reset_count;
+  int b_reset_count;
+  int pic_voltage_readings;
+  int hash_read_pos;
+  int hash_write_pos;
+  int dupe[HEX3_DEFAULT_ASIC_NUM];
+  int matching_work[HEX3_DEFAULT_ASIC_NUM];
+  int chip_con_resets[HEX3_DEFAULT_ASIC_NUM];
+  bool chip_is_dead[HEX3_DEFAULT_ASIC_NUM];
+  uint8_t wr_lastnonceid;
+  uint8_t buf_empty_space;
+  unsigned char *readbuf;
+  struct chip_results3 *array_nonce_cache;
+  struct work3_result *wr;
+  struct thr_info *thr;
+  struct work **hexworks;
+  struct hexminer3_task *ht;
+  struct work *work;
+  unsigned int work_block_local;
+  unsigned int work_pool_update;
+  time_t last_chip_valid_work[HEX3_DEFAULT_ASIC_NUM];
+  uint32_t nonces_range[HEX3_DEFAULT_ASIC_NUM];
+  time_t power_checked;
+};
+struct hexminer3_config_task
+{
+  uint8_t startbyte;
+  uint8_t datalength;
+  uint8_t command;
+  uint16_t address;
+  uint16_t hashclock;
+  uint16_t refvoltage;
+  uint32_t startnonce;
+  uint16_t chipcount;
+  uint8_t chip_mask;
+  uint8_t pad;
+  uint8_t csum;
+  uint8_t pad1[2];
+} __attribute__ ((packed, aligned (4)));
+
+#define HEX3_WORKANSWER_ADR 0x3000
+#define HEXMINER3_TASK_SIZE (sizeof(struct hexminer3_task))
+#define HEX3_MAX_WORK_SIZE (sizeof(struct work3_result) - 2)
+#define HEX3_BASE_WORK_SIZE 6
+extern int opt_hexminer3_core_voltage;
+extern int opt_hexminer3_chip_mask;
+extern struct hexminer3_info **hexminer3_info;
+
+#endif /* USE_HEXMINER3 */
+#endif /* HEX3_H */
--- cg_o/libhexr.c	1970-01-01 02:00:00.000000000 +0200
+++ cgminer_hex/libhexr.c	2014-09-22 14:25:09.000000000 +0300
@@ -0,0 +1,250 @@
+static int64_t
+timediff (const struct timeval *a, const struct timeval *b)
+{
+  struct timeval diff;
+  timersub (a, b, &diff);
+  return diff.tv_sec * 1000000 + diff.tv_usec;
+}
+
+static bool
+libhexr_cachenonce (struct chip_resultsr *nonce_cache, uint32_t nonce)
+{
+  int i = 0;
+  while (i < HEXR_NONCE_CASH_SIZE && nonce_cache->nonces[i] != nonce)
+    i++;
+  if (i < HEXR_NONCE_CASH_SIZE)
+    return false;
+  if (nonce_cache->nonce_cache_write_pos == HEXR_NONCE_CASH_SIZE)
+    nonce_cache->nonce_cache_write_pos = 0;
+  nonce_cache->nonces[nonce_cache->nonce_cache_write_pos++] = nonce;
+  return true;
+}
+
+static void
+libhexr_csum (unsigned char *startptr, unsigned char *endptr,
+              unsigned char *resptr)
+{
+  unsigned char *b = startptr;
+  uint8_t sum = 0;
+  while (b < endptr)
+    sum += *b++;
+  memcpy (resptr, &sum, 1);
+}
+
+static bool
+libhexr_usb_dead (struct cgpu_info *hexminerr)
+{
+  struct cg_usb_device *usbdev;
+  struct hexminerr_info *info = hexminerr->device_data;
+  if (!info)
+    return true;
+  usbdev = hexminerr->usbdev;
+  bool ret = (usbdev == NULL || usbdev->handle == NULL || hexminerr->shutdown
+              || info->shut_read || info->shut_write || info->shut_reset
+              || hexminerr->usbinfo.nodev || hexminerr->deven != DEV_ENABLED);
+  return ret;
+}
+
+static int
+libhexr_sendHashData (struct cgpu_info *hexminerr, unsigned char *sendbuf,
+                      size_t buf_len)
+{
+  struct hexminerr_info *info = hexminerr->device_data;
+  struct cg_usb_device *usbdev;
+  int wrote = 0, written = 0;
+  int err = LIBUSB_SUCCESS;
+  usbdev = hexminerr->usbdev;
+  if (libhexr_usb_dead (hexminerr))
+    goto out;
+  while (written < buf_len && err == LIBUSB_SUCCESS)
+    {
+      err =
+        libusb_bulk_transfer (usbdev->handle, 0x02, sendbuf + written,
+                              MIN (HEXR_USB_WR_SIZE, buf_len - written),
+                              &wrote, HEXR_USB_WR_TIME_OUT);
+      if (err == LIBUSB_SUCCESS)
+        written += wrote;
+    }
+out:
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+    info->shut_write = true;
+  return written;
+}
+
+static void
+libhexr_reset (struct cgpu_info *hexminerr)
+{
+  struct hexminerr_info *info = hexminerr->device_data;
+  struct cg_usb_device *usbdev;
+  int err = LIBUSB_SUCCESS;
+  usbdev = hexminerr->usbdev;
+  if (libhexr_usb_dead (hexminerr))
+    goto out;
+  err = libusb_reset_device (usbdev->handle);
+out:
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+    info->shut_reset = true;
+  info->usb_reset_count++;
+}
+
+static int
+libhexr_readHashData (struct cgpu_info *hexminerr, unsigned char *hash,
+                      int *hash_write_pos, int timeout)
+{
+  struct hexminerr_info *info = hexminerr->device_data;
+  struct cg_usb_device *usbdev;
+  int read = 0;
+  int err = LIBUSB_SUCCESS;
+  usbdev = hexminerr->usbdev;
+  if (libhexr_usb_dead (hexminerr))
+    goto out;
+  err =
+    libusb_bulk_transfer (usbdev->handle, 0x82, hash + *hash_write_pos,
+                          HEXR_USB_R_SIZE, &read, timeout);
+  if (err == LIBUSB_SUCCESS)
+    *hash_write_pos += MIN (read, HEXR_USB_R_SIZE);
+out:
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+    info->shut_read = true;
+  return err;
+}
+
+static double
+hexminerr_predecode_nonce_roll (struct cgpu_info *hexminerr,
+                                struct thr_info *thr, uint32_t nonce,
+                                uint8_t work_id, uint8_t rolled)
+{
+  struct hexminerr_info *info = hexminerr->device_data;
+  struct work *work_sub;
+  work_sub = copy_work_noffset_fast_no_id (info->hexworks[work_id], rolled);
+  if (test_nonce (work_sub, nonce))
+    {
+      submit_tested_work_no_clone (thr, work_sub, true);
+      return 1;
+    }
+  free_work (work_sub);
+  return 0;
+}
+
+static void
+libhexr_getvoltage (uint16_t wr_bukvoltage, int *info_pic_voltage_readings)
+{
+  float voltagehuman;
+  voltagehuman =
+    (float) ((float) wr_bukvoltage * (float) 3300 / (float) ((1 << 12) - 1));
+  *info_pic_voltage_readings = (int) voltagehuman;
+}
+
+static void
+libhexr_setvoltage (int info_voltage, uint16_t * refvoltage)
+{
+  uint16_t voltageadc;
+  voltageadc =
+    (uint16_t) ((float) info_voltage / (float) 1000 / (float) 3.3 *
+                ((1 << 12) - 1));
+  *refvoltage = htole16 (voltageadc);
+}
+
+static int
+libhexr_eatHashData (struct workr_result *wr, unsigned char *hash,
+                     int *hash_read_pos, int *hash_write_pos)
+{
+  uint8_t psum;
+  int wrpos;
+  unsigned char *csum_pos;
+  bool ok;
+  int places = 0;
+eat:
+  while (*hash_read_pos < *hash_write_pos && hash[*hash_read_pos] != 0x53)
+    *hash_read_pos += 1;
+  places = *hash_write_pos - *hash_read_pos;
+  if (places < 8)
+    return HEXR_BUF_SKIP;
+  memcpy ((char *) &wr->startbyte, &hash[*hash_read_pos],
+          HEXR_BASE_WORK_SIZE - 1);
+  wr->address = htole16 (wr->address);
+  ok = (wr->command == 0x52)
+    && ((wr->address == HEXR_WORKANSWER_ADR && wr->datalength == 0x05)
+        || (wr->address == 0x3008 && wr->datalength == 1));
+  if (!ok)
+    {
+      *hash_read_pos += 1;
+      goto eat;
+    }
+  if (places < HEXR_BASE_WORK_SIZE + wr->datalength * 2)
+    return HEXR_BUF_SKIP;
+  csum_pos =
+    hash + *hash_read_pos + HEXR_BASE_WORK_SIZE + wr->datalength * 2 - 1;
+  libhexr_csum (hash + *hash_read_pos, csum_pos, &psum);
+  if (psum != *csum_pos)
+    {
+      *hash_read_pos += 1;
+      return HEXR_BUF_ERR;
+    }
+  wrpos = (wr->address - HEXR_WORKANSWER_ADR) + HEXR_BASE_WORK_SIZE - 1;
+  memcpy ((char *) &wr->startbyte + wrpos,
+          &hash[*hash_read_pos + HEXR_BASE_WORK_SIZE - 1],
+          wr->datalength * 2);
+  *hash_read_pos += HEXR_BASE_WORK_SIZE + wr->datalength * 2;
+  return HEXR_BUF_DATA;
+}
+
+static void
+libhexr_shutdown (struct cgpu_info *hexminerr, uint16_t address,
+                  uint16_t word)
+{
+  unsigned char status[65];
+  unsigned char *sendbuf = &status[0];
+  unsigned char *hash = &status[0];
+  struct hexminerr_info *info = hexminerr->device_data;
+  struct cg_usb_device *usbdev;
+  int wrote = 0, written = 0, read = 0;
+  int err = LIBUSB_SUCCESS;
+  size_t buf_len = 8;
+  usbdev = hexminerr->usbdev;
+  uint16_t wr_adr = htole16 (address);
+  uint16_t ledata = htole16 (word);
+  status[0] = 0x53;
+  status[1] = 0x01;
+  status[2] = 0x57;
+  memcpy (status + 3, &wr_adr, 2);
+  memcpy (status + 5, &ledata, 2);
+  libhexr_csum (status, status + 7, status + 7);
+  if (usbdev == NULL || usbdev->handle == NULL || info->shut_read
+      || info->shut_write || info->shut_reset)
+    return;
+  while (written < buf_len && err == LIBUSB_SUCCESS)
+    {
+      err =
+        libusb_bulk_transfer (usbdev->handle, 0x02, sendbuf + written,
+                              MIN (HEXR_USB_WR_SIZE, buf_len - written),
+                              &wrote, HEXR_USB_WR_TIME_OUT);
+      if (err == LIBUSB_SUCCESS)
+        written += wrote;
+        //applog(LOG_ERR, "SHUT lib 2 written %i = 8 buf_len",written);
+    }
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+    return;
+  err =
+      libusb_bulk_transfer (usbdev->handle, 0x82, hash, HEXR_USB_R_SIZE,
+                              &read, 200);
+}
+/*
+static void
+libhexr_set_words (struct cgpu_info *hexminerr, uint16_t address,
+                   uint16_t word, uint16_t word1)
+{
+  unsigned char status[12];
+  uint16_t wr_adr = htole16 (address);
+  uint16_t ledata = htole16 (word);
+  uint16_t ledata1 = htole16 (word1);
+  status[0] = 0x53;
+  status[1] = 0x02;
+  status[2] = 0x57;
+  memcpy (status + 3, &wr_adr, 2);
+  memcpy (status + 5, &ledata, 2);
+  memcpy (status + 7, &ledata1, 2);
+  libhexr_csum (status, status + 9, status + 9);
+  libhexr_sendHashData (hexminerr, status, 10);
+}
+*/
\ No newline at end of file
--- cg_o/driver-hexminerr.c	1970-01-01 02:00:00.000000000 +0200
+++ cgminer_hex/driver-hexminerr.c	2014-09-24 08:27:48.571875075 +0300
@@ -0,0 +1,631 @@
+/*$T indentinput.c GC 1.140 10/16/13 10:19:47 */
+#include "config.h"
+#include <limits.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <ctype.h>
+#include <dirent.h>
+#include <unistd.h>
+#ifndef WIN32
+#include <sys/select.h>
+#include <termios.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#ifndef O_CLOEXEC
+#define O_CLOEXEC 0
+#endif
+#else
+#include "compat.h"
+#include <windows.h>
+#include <io.h>
+#endif
+#include "elist.h"
+#include "miner.h"
+#include "usbutils.h"
+#include "driver-hexminerr.h"
+#include <math.h>
+#include "util.h"
+extern unsigned int work_block;
+extern unsigned int work_pool_update;
+extern struct work *copy_work_noffset_fast_no_id (struct work *base_work,
+                                                  int noffset);
+struct device_drv hexminerr_drv;
+extern bool no_work;
+int opt_hexminerr_chip_mask = 0xFF;
+//int opt_hexminerr_hw_err_res = 0xFF;
+//int opt_hexminerr_nonce_timeout_secs = 0xFF;
+int opt_hexminerr_core_voltage = HEXR_DEFAULT_CORE_VOLTAGE;
+int opt_hexminerr_pic_roll = 0x3c;
+//int opt_hexminerr_reset_below_threshold = 94;
+//int opt_hexminerr_reset_below_threshold_wait = 190;
+int opt_hexminerr_leading_zeros = 1;
+
+
+#include "libhexr.c"
+
+static int
+hexminerr_send_task (struct hexminerr_task *ht, struct cgpu_info *hexminerr)
+{
+  int ret = 0;
+  size_t nr_len = HEXMINERR_TASK_SIZE;
+  struct hexminerr_info *info;
+  info = hexminerr->device_data;
+  libhexr_csum (&ht->startbyte, &ht->csum, &ht->csum);
+  ret = libhexr_sendHashData (hexminerr, &ht->startbyte, nr_len);
+  if (ret != nr_len && info->usb_bad_reads > -1)
+    {
+      libhexr_reset (hexminerr);
+      info->usb_w_errors++;
+      return -1;
+    }
+  return ret;
+}
+
+static inline void
+hexminerr_create_task (bool reset_work, struct hexminerr_task *ht,
+                       struct work *work)
+{
+  if (reset_work)
+    ht->status = (uint8_t) HEXR_STAT_NEW_WORK_CLEAR_OLD;
+  else
+    ht->status = (uint8_t) HEXR_STAT_NEW_WORK;
+  memcpy (ht->midstate, work->midstate, 32);
+  memcpy (ht->merkle, work->data + 64, 12);
+  ht->id = (uint8_t) work->subid;
+}
+
+static inline void
+hexminerr_init_task_c (struct hexminerr_config_task *htc,
+                       struct hexminerr_info *info)
+{
+  htc->startbyte = 0x53;
+  htc->datalength =
+    (uint8_t) ((sizeof (struct hexminerr_config_task) - 6) / 2);
+  htc->command = 0x57;
+  htc->address = htole16 (0x30C0);
+  htc->hashclock = htole16 ((uint16_t) (info->frequency));
+  libhexr_setvoltage (info->core_voltage, &htc->refvoltage);
+  htc->chip_mask = (uint8_t) info->chip_mask;
+  libhexr_csum (&htc->startbyte, &htc->csum, &htc->csum);
+}
+
+static inline void
+hexminerr_init_task (struct hexminerr_task *ht, struct hexminerr_info *info)
+{
+  ht->startbyte = 0x53;
+  ht->datalength = (uint8_t) ((HEXMINERR_TASK_SIZE - 6) / 2);
+  ht->command = 0x57;
+  ht->address = htole16 (0x3080);
+  ht->status = (uint8_t) HEXR_STAT_NEW_WORK_CLEAR_OLD;
+  ht->roll = (uint8_t) info->pic_roll;
+  ht->leading_zeros = (uint8_t)(info->opt_hexminerr_leading_zeros + 30);
+}
+/*
+static void
+do_reset (struct cgpu_info *hexminerr)
+{
+  struct hexminerr_info *info = hexminerr->device_data;
+  time_t now = time (NULL);
+  uint8_t i = 0;
+  if (no_work)
+    {
+      while (i < info->asic_count)
+        {
+          info->hw_err[i] = 0;
+//Pools and all to settle 10 secs add
+          if (info->last_chip_valid_work[i] > 0)
+            info->last_chip_valid_work[i] = now + 10;
+          i++;
+        }
+      return;
+    }
+  while (i < info->asic_count)
+    {
+      if (!info->chips_enabled[i])
+        {
+          i++;
+          continue;
+        }
+      if (info->last_chip_valid_work[i] > 0
+          && ((now - info->last_chip_valid_work[i]) >=
+              info->opt_hexminerr_nonce_timeout_secs))
+        {
+          libhexr_set_words (hexminerr, HEXR_RES_ADR, (uint16_t) i, 0x0007);
+          applog (LOG_ERR,
+                  "HEXR %i Chip[%i] last received nonce %i secs ago reset",
+                  hexminerr->device_id, i,
+                  (int) (now - info->last_chip_valid_work[i]));
+          info->last_chip_valid_work[i] = now;
+          info->hw_err[i] = 0;
+          info->res_timeout_err[i]++;
+          info->b_reset_count++;
+          break;
+        }
+      if (info->hw_err[i] > info->opt_hexminerr_hw_err_res)
+        {
+          libhexr_set_words (hexminerr, HEXR_RES_ADR, (uint16_t) i, 0x0007);
+          applog (LOG_ERR, "HEXR %i Chip[%i] %i consecutive HW errors reset",
+                  hexminerr->device_id, i, (int) info->hw_err[i]);
+          info->last_chip_valid_work[i] = now;
+          info->hw_err[i] = 0;
+          info->res_hew_err[i]++;
+          info->b_reset_count++;
+          break;
+        }
+      i++;
+    }
+}
+*/
+static struct cgpu_info *
+hexminerr_detect_one (libusb_device * dev, struct usb_find_devices *found)
+{
+  int asic_count, frequency;
+  struct hexminerr_info *info;
+  struct cgpu_info *hexminerr;
+  bool configured = false;
+  int i = 0;
+  hexminerr = usb_alloc_cgpu (&hexminerr_drv, HEXR_MINER_THREADS);
+  if (!usb_init (hexminerr, dev, found))
+    {
+      usb_uninit (hexminerr);
+      return NULL;
+    }
+  hexminerr->device_data = calloc (sizeof (struct hexminerr_info), 1);
+  if (unlikely (!(hexminerr->device_data)))
+    {
+      hexminerr->device_data = NULL;
+      usb_uninit (hexminerr);
+      return NULL;
+    }
+  if (opt_hexminerr_options != NULL)
+  	configured = (sscanf(opt_hexminerr_options, "%d:%d", &asic_count, &frequency) == 2);	
+  
+  if (opt_hexminerr_core_voltage < HEXR_MIN_COREMV
+      || opt_hexminerr_core_voltage > HEXR_MAX_COREMV)
+    {
+      applog (LOG_ERR, "Invalid hexminerr-voltage %d must be %dmV - %dmV",
+              opt_hexminerr_core_voltage, HEXR_MIN_COREMV, HEXR_MAX_COREMV);
+      free (hexminerr->device_data);
+      hexminerr->device_data = NULL;
+      usb_uninit (hexminerr);
+      return NULL;
+    }
+  info = hexminerr->device_data;
+  info->hexworks = calloc (sizeof (struct work *), HEXMINERR_ARRAY_SIZE);
+  if (unlikely (!(info->hexworks)))
+    {
+      free (hexminerr->device_data);
+      hexminerr->device_data = NULL;
+      usb_uninit (hexminerr);
+      return NULL;
+    }
+  info->wr = (struct workr_result *) malloc (sizeof (struct workr_result));
+  info->array_nonce_cache = calloc (16, sizeof (struct chip_resultsr));
+  info->readbuf = calloc (HEXR_HASH_BUF_SIZE, sizeof (unsigned char));
+  info->write_pos = 0;
+  info->usb_bad_reads = -30;
+  info->hash_read_pos = 0;
+  info->hash_write_pos = 0;
+  info->shut_read = false;
+  info->shut_write = false;
+  info->shut_reset = false;
+  info->miner_count = HEXR_DEFAULT_MINER_NUM;
+  info->asic_count = HEXR_DEFAULT_ASIC_NUM;
+  info->frequency = HEXR_DEFAULT_FREQUENCY;
+  info->pic_voltage_readings = HEXR_DEFAULT_CORE_VOLTAGE;
+  info->core_voltage = opt_hexminerr_core_voltage;
+  //info->opt_hexminerr_hw_err_res = opt_hexminerr_hw_err_res;
+  //info->opt_hexminerr_nonce_timeout_secs = opt_hexminerr_nonce_timeout_secs;
+  info->chip_mask = opt_hexminerr_chip_mask;
+  info->wr->buf_empty_space = 4;
+  info->work_block_local = -1;
+	info->work_pool_update = -1;
+  info->reset_work = true;
+  info->jobs_to_send = 1;
+  if (configured)
+    {
+      info->asic_count = asic_count;
+      info->frequency = frequency;
+    }
+  info->pic_roll = opt_hexminerr_pic_roll;
+  //info->pic_roll = 31;
+  //info->opt_hexminerr_reset_below_threshold = (double)opt_hexminerr_reset_below_threshold / 100;
+  //info->opt_hexminerr_reset_below_threshold_wait = (double)opt_hexminerr_reset_below_threshold_wait;
+  info->opt_hexminerr_leading_zeros  = opt_hexminerr_leading_zeros;
+  info->hexminerr_work_count = pow( 2, (opt_hexminerr_leading_zeros - 1) );
+  info->work_ping = (opt_hexminerr_leading_zeros == 1);
+  gettimeofday (&info->last_wr, NULL);
+  //info->rolling1 = (double) (info->asic_count * info->frequency * 193  * info->opt_hexminerr_reset_below_threshold);
+  info->wsem_ustiming =
+    (int64_t) (0x100000000ll /
+               (info->asic_count * info->frequency * 193 *
+                (info->pic_roll + 1) * 0.7));
+  info->ht = calloc (sizeof (struct hexminerr_task), 1);
+  hexminerr_init_task (info->ht, info);
+  while (i < HEXMINERR_ARRAY_SIZE)
+    {
+      info->hexworks[i] = calloc (1, sizeof (struct work));
+      info->hexworks[i]->pool = NULL;
+      i++;
+  } if (!add_cgpu (hexminerr))
+    {
+      free (info->hexworks);
+      free (hexminerr->device_data);
+      hexminerr->device_data = NULL;
+      hexminerr = usb_free_cgpu (hexminerr);
+      usb_uninit (hexminerr);
+      return NULL;
+    }
+  return hexminerr;
+}
+
+static void
+hexminerr_detect (bool __maybe_unused hotplug)
+{
+  usb_detect (&hexminerr_drv, hexminerr_detect_one);
+}
+
+static void
+do_hexminerr_close (struct thr_info *thr)
+{
+  struct cgpu_info *hexminerr = thr->cgpu;
+  struct hexminerr_info *info = hexminerr->device_data;
+  int i = 0;
+  while (i < HEXMINERR_ARRAY_SIZE)
+    {
+      free_work (info->hexworks[i]);
+      i++;
+    }
+  free (info->hexworks);
+  free (info->readbuf);
+  free (info->array_nonce_cache);
+  free (info->wr);
+  free (info->ht);
+}
+
+static void
+hexminerr_shutdown (struct thr_info *thr)
+{
+	struct cgpu_info *hexminerr = thr->cgpu;
+  do_hexminerr_close (thr);
+  /*Power off and try to flush USB */
+  libhexr_shutdown (hexminerr, 0x30AE, 0x0004);
+  usb_nodev (hexminerr);
+}
+
+static bool
+hexminerr_thread_init (struct thr_info *thr)
+{
+  struct cgpu_info *hexminerr = thr->cgpu;
+  struct hexminerr_info *info = hexminerr->device_data;
+  uint8_t i = 0;
+  info->thr = thr;
+  struct hexminerr_config_task *htc;
+  htc = calloc (sizeof (struct hexminerr_config_task), 1);
+  hexminerr_init_task_c (htc, info);
+  
+  int ret = libhexr_sendHashData (hexminerr, &htc->startbyte,
+                                  sizeof (struct hexminerr_config_task));
+  cgsleep_ms (200);
+  if (ret != sizeof (struct hexminerr_config_task))
+  	{
+    	applog (LOG_ERR, "HEXR %i Send config failed disabling!!", hexminerr->device_id);
+   		libhexr_reset(hexminerr);
+   		info->shut_write = true;
+    }
+  free (htc);
+/*Pools and all to settle 10 secs add */
+  time_t now = time (NULL) + 10;
+  while (i < info->asic_count)
+    {
+      info->chips_enabled[i] =
+        (((uint8_t) info->chip_mask & (uint8_t) pow (2, i)) ==
+         (uint8_t) pow (2, i));
+      info->last_chip_valid_work[i] = now;
+      i++;
+    }
+  return true;
+}
+
+static void
+do_write_hexr (struct thr_info *thr)
+{
+  struct cgpu_info *hexminerr = thr->cgpu;
+  struct hexminerr_info *info = hexminerr->device_data;
+  struct work *work;
+  int jobs_to_send = info->jobs_to_send;
+  int send_jobs, ret;
+  send_jobs = 0;
+  while (!libhexr_usb_dead (hexminerr) && (send_jobs < jobs_to_send))
+    {
+      work = get_work (thr, thr->id);
+      work->ping = info->work_ping;
+     
+      if (info->work_block_local != work_block || info->work_pool_update != work_pool_update)
+        {
+          
+					info->reset_work = true;
+          send_jobs = 0;
+          jobs_to_send = 2;
+          info->work_pool_update = work_pool_update;
+          info->work_block_local = work_block;
+        }
+      
+      if (info->write_pos >= HEXMINERR_ARRAY_SIZE_REAL)
+        info->write_pos = 0;
+      work->subid = info->write_pos;
+      hexminerr_create_task (info->reset_work, info->ht, work);
+      free_work (info->hexworks[info->write_pos]);
+      info->hexworks[info->write_pos] = work;
+      ret = hexminerr_send_task (info->ht, hexminerr);
+      info->write_pos++;
+      send_jobs++;
+      if (ret == HEXMINERR_TASK_SIZE && info->reset_work)
+        {
+          info->reset_work = false;
+          gettimeofday (&info->last_wr, NULL);
+        }
+    }
+}
+
+extern void inc_hw_errors_hex8 (struct thr_info *thr, int diff);
+
+static int64_t
+hexminerr_scanhash (struct thr_info *thr)
+{
+	
+  struct cgpu_info *hexminerr = thr->cgpu;
+  struct hexminerr_info *info = hexminerr->device_data;
+  struct timeval now;
+  struct timeval diff;
+	//double dev_runtime;
+  int64_t tdif, rethash_count = 0;
+  int ret_r, rminder = 0;
+  double found, hash_count = 0;
+  uint32_t nonce;
+  //uint8_t buf_thr = 2, buf_thrl = 4;
+  uint8_t buf_thr = 60, buf_thrl = 57;
+  //do_reset (hexminerr);
+ /* 
+if (info->wr->buf_empty_space >= HEXMINERR_ARRAY_SIZE_REAL) {
+        applog (LOG_ERR,
+                  "HEXR %i Bugec info->wr->buf_empty_space %i",
+                  hexminerr->device_id, info->wr->buf_empty_space);
+}
+
+if (info->wr->buf_empty_space < 50) {
+        applog (LOG_ERR,
+                  "HEXR %i Bugec info->wr->buf_empty_space %i",
+                  hexminerr->device_id, info->wr->buf_empty_space);
+}
+*/
+  if (info->work_block_local != work_block || info->work_pool_update != work_pool_update)
+    {
+      info->reset_work = true;
+      info->work_block_local = work_block;
+      info->work_pool_update = work_pool_update;
+      info->jobs_to_send = 2;
+      gettimeofday (&info->last_wr, NULL);
+      do_write_hexr (thr);
+      //cgsleep_ms (10);
+      goto done_wr;
+    }
+  gettimeofday (&now, NULL);
+  tdif = timediff (&now, &info->last_wr);
+  info->jobs_to_send = (int) (tdif / info->wsem_ustiming);
+  rminder = (int) (tdif % info->wsem_ustiming);
+  if (info->jobs_to_send > 0 || info->wr->buf_empty_space > buf_thr)
+    {
+      gettimeofday (&info->last_wr, NULL);
+      if (info->wr->buf_empty_space < buf_thrl)
+        goto done_wr;
+      now.tv_sec = 0;
+      now.tv_usec = rminder;
+      timersub (&info->last_wr, &now, &diff);
+      memcpy (&info->last_wr, &diff, sizeof (struct timeval));
+      if (info->wr->buf_empty_space > buf_thr)
+        info->jobs_to_send++;
+      if (info->jobs_to_send > 2)
+        info->jobs_to_send = 2;
+      do_write_hexr (thr);
+    }
+done_wr:
+  if (libhexr_usb_dead (hexminerr))
+    {
+      hexminerr->shutdown = true;
+      return -1;
+    }
+  if (info->hash_write_pos + HEXR_USB_R_SIZE > HEXR_HASH_BUF_SIZE_OK)
+    {
+      info->hash_write_pos = info->hash_write_pos - info->hash_read_pos;
+      memcpy (info->readbuf, info->readbuf + info->hash_read_pos,
+              info->hash_write_pos);
+      info->hash_read_pos = 0;
+    }
+  if (info->hash_write_pos - info->hash_read_pos > 7)
+    {
+    again:
+    	if (info->work_block_local != work_block || info->work_pool_update != work_pool_update)
+    		goto new_block;
+      ret_r =
+        libhexr_eatHashData (info->wr, info->readbuf, &info->hash_read_pos,
+                             &info->hash_write_pos);
+      if (ret_r > HEXR_BUF_DATA)
+        goto out;
+      if (info->wr->datalength == 1)
+        goto done;
+      if (info->wr->lastnonceid >= HEXMINERR_ARRAY_SIZE_REAL) {
+       // applog (LOG_ERR,
+         //         "HEXR %i Bug info->wr->lastnonceid %i",
+           //       hexminerr->device_id, info->wr->lastnonceid);
+        info->wr->lastnonceid = 0;
+         
+       }
+      if (info->wr->lastchippos > HEXR_DEFAULT_RANGE)
+        info->wr->lastchippos = HEXR_DEFAULT_RANGE;
+      if (libhexr_cachenonce
+          (&info->array_nonce_cache[info->wr->lastchippos],
+           info->wr->lastnonce))
+        {
+          nonce = htole32 (info->wr->lastnonce);
+          found =
+            hexminerr_predecode_nonce_roll (hexminerr, thr, nonce,
+                                            info->wr->lastnonceid,
+                                            info->wr->roll);
+          info->last_chip_valid_work[(uint8_t) info->wr->lastchippos] =
+            time (NULL);
+          if (found > 0)
+            {
+              info->hw_err[info->wr->lastchippos] = 0;
+              if (hash_count == 0)
+                libhexr_getvoltage (htole16 (info->wr->lastvoltage),
+                                    &info->pic_voltage_readings);
+              hash_count += found;
+              info->matching_work[info->wr->lastchippos]++;
+            }
+          else
+            {
+              info->hw_err[info->wr->lastchippos]++;
+              inc_hw_errors_hex8 (thr, -info->hexminerr_work_count);
+            }
+        }
+      else
+        info->dupe[info->wr->lastchippos]++;
+    out:
+      if (ret_r == HEXR_BUF_ERR)
+        info->usb_r_errors++;
+    done:
+      if (ret_r != HEXR_BUF_SKIP)
+        goto again;
+    }
+  if (info->work_block_local != work_block || info->work_pool_update != work_pool_update)
+    		goto new_block;
+  ret_r =
+    libhexr_readHashData (hexminerr, info->readbuf, &info->hash_write_pos,
+                          HEXMINERR_BULK_READ_TIMEOUT);
+  if (ret_r != LIBUSB_SUCCESS)
+    info->usb_bad_reads++;
+  else
+    info->usb_bad_reads = 0;
+  if (info->usb_bad_reads > 20)
+    libhexr_reset (hexminerr);
+  new_block:
+  if (libhexr_usb_dead (hexminerr))
+    {
+      hexminerr->shutdown = true;
+      return -1;
+    }
+ /*   
+	if (hexminerr->dev_start_tv.tv_sec == 0)
+    	dev_runtime = total_secs;  
+  else
+    {
+      cgtime (&now);
+      dev_runtime = tdiff (&now, &(hexminerr->dev_start_tv));
+    }
+  if ((dev_runtime > info->opt_hexminerr_reset_below_threshold_wait) && (hexminerr->rolling1 < info->rolling1)) {
+  		libhexr_shutdown (hexminerr, 0x30AE, 0x0004);
+  		info->shut_write = true;  
+  		usb_nodev(hexminerr);
+    	hexminerr->shutdown = true;	
+  		applog (LOG_ERR,
+                  "HEXR %i restarting due to low hash rate (%f < %f). Uptime %f secs",
+                  hexminerr->device_id, hexminerr->rolling1 , info->rolling1, dev_runtime);
+      return -1;
+   }
+  */
+  rethash_count = (0xffffffffull * (int64_t) hash_count * (int64_t) info->hexminerr_work_count);
+  return rethash_count;
+}
+
+static void
+get_hexminerr_statline_before (char *buf, size_t bufsiz,
+                               struct cgpu_info *hexminerr)
+{
+  if (!hexminerr->device_data)
+    return;
+  struct hexminerr_info *info = hexminerr->device_data;
+  tailsprintf (buf, bufsiz, "%3d %4d/%4dmV", info->frequency,
+               info->core_voltage, info->pic_voltage_readings);
+}
+
+extern void suffix_string (uint64_t val, char *buf, size_t bufsiz,
+                           int sigdigits);
+static struct api_data *
+hexminerr_api_stats (struct cgpu_info *cgpu)
+{
+  struct api_data *root = NULL;
+  struct timeval now;
+  struct hexminerr_info *info = cgpu->device_data;
+  char displayed_hashes[16], displayed_rolling[16];
+  double dev_runtime, hwp;
+  uint64_t dh64, dr64;
+  
+  int i;
+  if (!info)
+    return NULL;
+  hwp =
+    (cgpu->hw_errors +
+     cgpu->diff1) ? (double) (cgpu->hw_errors) / (double) (cgpu->hw_errors +
+                                                           cgpu->diff1) : 0;
+  if (cgpu->dev_start_tv.tv_sec == 0)
+    dev_runtime = total_secs;
+  else
+    {
+      cgtime (&now);
+      dev_runtime = tdiff (&now, &(cgpu->dev_start_tv));
+    }
+  if (dev_runtime < 1.0)
+    dev_runtime = 1.0;
+  dh64 = (double) cgpu->total_mhashes / dev_runtime * 1000000ull;
+  dr64 = (double) cgpu->rolling * 1000000ull;
+  suffix_string (dh64, displayed_hashes, sizeof (displayed_hashes), 4);
+  suffix_string (dr64, displayed_rolling, sizeof (displayed_rolling), 4);
+  root = api_add_string (root, "MHS 5s", displayed_rolling, true);
+  root = api_add_string (root, "MHS av", displayed_hashes, true);
+  root = api_add_int (root, "Hardware Errors", &(cgpu->hw_errors), true);
+  root = api_add_percent (root, "Hardware Errors%", &hwp, true);
+  root = api_add_int (root, "USB Read Errors", &(info->usb_r_errors), true);
+  root = api_add_int (root, "USB Write Errors", &(info->usb_w_errors), true);
+  root =
+    api_add_int (root, "USB Reset Count", &(info->usb_reset_count), true);
+  root =
+    api_add_int (root, "Miner Reset Count", &(info->b_reset_count), true);
+  root =
+    api_add_time (root, "Last Share Time", &(cgpu->last_share_pool_time),
+                  true);
+  root = api_add_int (root, "Chip Count", &(info->asic_count), true);
+  root = api_add_int (root, "Frequency", &(info->frequency), true);
+  root = api_add_int (root, "Core Voltage", &(info->core_voltage), true);
+  root =
+    api_add_int (root, "PIC Voltage Readings", &(info->pic_voltage_readings),
+                 true);
+  for (i = 0; i < info->asic_count; i++)
+    {
+      char mcw[24];
+      sprintf (mcw, "Chip%d Nonces", i );
+      root = api_add_int (root, mcw, &(info->matching_work[i]), true);
+      sprintf (mcw, "Chip%d Dupes", i );
+      root = api_add_int (root, mcw, &(info->dupe[i]), true);
+      sprintf (mcw, "Chip%d Timouts Reset", i );
+      root = api_add_int (root, mcw, &(info->res_timeout_err[i]), true);
+      sprintf (mcw, "Chip%d HW Errors Reset", i );
+      root = api_add_int (root, mcw, &(info->res_hew_err[i]), true);
+    }
+  return root;
+}
+
+struct device_drv hexminerr_drv = {
+  .drv_id = DRIVER_hexminerr,
+  .dname = "hexminerr",
+  .name = "HEXR",
+  .drv_detect = hexminerr_detect,
+  .thread_init = hexminerr_thread_init,
+  .hash_work = hash_driver_work,
+  .scanwork = hexminerr_scanhash,
+  .get_api_stats = hexminerr_api_stats,
+  .get_statline_before = get_hexminerr_statline_before,
+  .thread_shutdown = hexminerr_shutdown,
+};
--- cg_o/driver-hexminerr.h	1970-01-01 02:00:00.000000000 +0200
+++ cgminer_hex/driver-hexminerr.h	2014-09-24 08:46:48.489389935 +0300
@@ -0,0 +1,160 @@
+/*$T indentinput.h GC 1.140 10/16/13 10:20:01 */
+#ifndef HEXR_H
+#define HEXR_H
+#ifdef USE_HEXMINERR
+#include "util.h"
+
+/* hexminerr_task/work_reply status Definitions: */
+#define HEXR_STAT_IDLE 0        /* Idle or data already Sent to the buffer */
+#define HEXR_STAT_NEW_WORK 1    /* Request for write in the buffer */
+#define HEXR_STAT_WAITING 2     /* Wait For Buffer Empty Position */
+#define HEXR_STAT_CLR_BUFF 3    /* Force Buffer Empty */
+#define HEXR_STAT_STOP_REQ 4    /* Stop Request */
+#define HEXR_STAT_NEW_WORK_CLEAR_OLD 5  /* Clear Buffers and after that fill the first buffer */
+#define HEXR_STAT_UNUSED 6
+#define HEXR_STAT_RES_HW 12
+#define HEXR_STAT_RES_NO_NONCE 13
+/* libhexr_eatHashData/BUF_reply status Definitions: */
+#define HEXR_BUF_DATA 0
+#define HEXR_BUF_ERR 1
+#define HEXR_BUF_SKIP 2
+/* MISC */
+#define HEXMINERR_ARRAY_PIC_SIZE 64
+#define HEXMINERR_ARRAY_SIZE HEXMINERR_ARRAY_PIC_SIZE
+#define HEXMINERR_ARRAY_SIZE_REAL HEXMINERR_ARRAY_SIZE - 2
+#define HEXR_NONCE_CASH_SIZE 4
+#define HEXR_USB_R_SIZE 64
+#define HEXR_USB_WR_SIZE 64
+#define HEXR_HASH_BUF_SIZE 2048
+#define HEXR_HASH_BUF_SIZE_OK HEXR_HASH_BUF_SIZE - 4
+#define HEXMINERR_BULK_READ_TIMEOUT 1000
+#define HEXR_USB_WR_TIME_OUT 500
+#define HEXR_MINER_THREADS 1
+#define HEXR_DEFAULT_MINER_NUM 0x01
+#define HEXR_DEFAULT_ASIC_NUM 0x04
+#define HEXR_DEFAULT_RANGE HEXR_DEFAULT_ASIC_NUM - 1
+#define HEXR_MIN_FREQUENCY 0
+#define HEXR_MAX_FREQUENCY 1500
+#define HEXR_DEFAULT_FREQUENCY 650
+#define HEXR_DEFAULT_CORE_VOLTAGE 690   /* in millivolts */
+#define HEXR_MIN_COREMV 600     /* in millivolts */
+#define HEXR_MAX_COREMV 1001    /* in millivolts */
+struct chip_resultsr
+{
+  uint8_t nonce_cache_write_pos;
+  uint32_t nonces[HEXR_NONCE_CASH_SIZE];
+};
+struct hexminerr_task
+{
+  uint8_t startbyte;
+  uint8_t datalength;
+  uint8_t command;
+  uint16_t address;
+  uint8_t midstate[32];
+  uint32_t merkle[3];
+  uint8_t roll;
+  uint8_t id;
+  uint8_t status;
+  uint8_t dum;
+  uint8_t leading_zeros;
+  uint8_t dum1;
+  uint8_t csum;
+  uint8_t pad[4];
+  //uint8_t csum;
+  //uint8_t pad[6];
+} __attribute__ ((packed, aligned (4)));
+struct workr_result
+{
+  uint8_t startbyte;
+  uint8_t datalength;
+  uint8_t command;
+  uint16_t address;
+  uint32_t lastnonce;
+  uint8_t roll;
+  uint8_t lastnonceid;
+  uint16_t lastvoltage;
+  uint8_t lastchippos;
+  uint8_t buf_empty_space;
+  uint8_t csum;
+  uint8_t pad[4];
+} __attribute__ ((packed, aligned (4)));
+struct hexminerr_info
+{
+  struct timeval last_wr;
+  int jobs_to_send;
+  int64_t wsem_ustiming;
+  bool shut_read;
+  bool shut_write;
+  bool shut_reset;
+  bool reset_work;
+  bool work_ping;
+  int usb_bad_reads;
+  int write_pos;
+  int chip_mask;
+  bool chips_enabled[HEXR_DEFAULT_ASIC_NUM];
+  int miner_count;
+  int asic_count;
+  int pic_roll;
+  int core_voltage;
+  //int opt_hexminerr_hw_err_res;
+  //int opt_hexminerr_nonce_timeout_secs;
+  //double opt_hexminerr_reset_below_threshold;
+  //double opt_hexminerr_reset_below_threshold_wait;
+  int frequency;
+  int usb_r_errors;
+  int usb_w_errors;
+  int usb_reset_count;
+  int b_reset_count;
+  int pic_voltage_readings;
+  int hash_read_pos;
+  int hash_write_pos;
+  int opt_hexminerr_leading_zeros;
+  int hexminerr_work_count;
+  int dupe[HEXR_DEFAULT_ASIC_NUM];
+  int res_hew_err[HEXR_DEFAULT_ASIC_NUM];
+  int res_timeout_err[HEXR_DEFAULT_ASIC_NUM];
+  int matching_work[HEXR_DEFAULT_ASIC_NUM];
+  int hw_err[HEXR_DEFAULT_ASIC_NUM];
+  unsigned int work_block_local;
+  unsigned int work_pool_update;
+  unsigned char *readbuf;
+  struct workr_result *wr;
+  struct chip_resultsr *array_nonce_cache;
+  struct thr_info *thr;
+  struct work **hexworks;
+  time_t last_chip_valid_work[HEXR_DEFAULT_ASIC_NUM];
+  struct hexminerr_task *ht;
+  //double rolling1;
+};
+struct hexminerr_config_task
+{
+  uint8_t startbyte;
+  uint8_t datalength;
+  uint8_t command;
+  uint16_t address;
+  uint16_t hashclock;
+  uint16_t refvoltage;
+  uint32_t difficulty;
+  uint8_t chip_mask;
+  uint8_t wr_interwal;
+  uint8_t csum;
+} __attribute__ ((packed, aligned (4)));
+
+#define HEXR_WORKANSWER_ADR 0x3000
+#define HEXR_RES_ADR 0x30AC
+//#define HEXMINERR_TASK_SIZE (sizeof(struct hexminerr_task)-6)
+#define HEXMINERR_TASK_SIZE (sizeof(struct hexminerr_task)-4)
+#define HEXR_MAX_WORK_SIZE (sizeof(struct workr_result)-4)
+#define HEXR_BASE_WORK_SIZE 6
+extern int opt_hexminerr_core_voltage;
+extern int opt_hexminerr_chip_mask;
+//extern int opt_hexminerr_hw_err_res;
+extern int opt_hexminerr_pic_roll;
+//extern int opt_hexminerr_nonce_timeout_secs;
+//extern int opt_hexminerr_reset_below_threshold;
+//extern int opt_hexminerr_reset_below_threshold_wait;
+extern int opt_hexminerr_leading_zeros;
+extern struct hexminerr_info **hexminerr_info;
+
+#endif /* USE_HEXMINERR */
+#endif /* HEXR_H */
--- cg_o/libhexm.c	1970-01-01 02:00:00.000000000 +0200
+++ cgminer_hex/libhexm.c	2014-09-22 14:25:09.000000000 +0300
@@ -0,0 +1,249 @@
+static int64_t
+timediff (const struct timeval *a, const struct timeval *b)
+{
+  struct timeval diff;
+  timersub (a, b, &diff);
+  return diff.tv_sec * 1000000 + diff.tv_usec;
+}
+
+static bool
+libhexm_cachenonce (struct chip_resultsm *nonce_cache, uint32_t nonce)
+{
+  int i = 0;
+  while (i < HEXM_NONCE_CASH_SIZE && nonce_cache->nonces[i] != nonce)
+    i++;
+  if (i < HEXM_NONCE_CASH_SIZE)
+    return false;
+  if (nonce_cache->nonce_cache_write_pos == HEXM_NONCE_CASH_SIZE)
+    nonce_cache->nonce_cache_write_pos = 0;
+  nonce_cache->nonces[nonce_cache->nonce_cache_write_pos++] = nonce;
+  return true;
+}
+
+static void
+libhexm_csum (unsigned char *startptr, unsigned char *endptr,
+              unsigned char *resptr)
+{
+  unsigned char *b = startptr;
+  uint8_t sum = 0;
+  while (b < endptr)
+    sum += *b++;
+  memcpy (resptr, &sum, 1);
+}
+
+static bool
+libhexm_usb_dead (struct cgpu_info *hexminerm)
+{
+  struct cg_usb_device *usbdev;
+  struct hexminerm_info *info = hexminerm->device_data;
+  if (!info)
+    return true;
+  usbdev = hexminerm->usbdev;
+  bool ret = (usbdev == NULL || usbdev->handle == NULL || hexminerm->shutdown
+              || info->shut_read || info->shut_write || info->shut_reset
+              || hexminerm->usbinfo.nodev || hexminerm->deven != DEV_ENABLED);
+  return ret;
+}
+
+static int
+libhexm_sendHashData (struct cgpu_info *hexminerm, unsigned char *sendbuf,
+                      size_t buf_len)
+{
+  struct hexminerm_info *info = hexminerm->device_data;
+  struct cg_usb_device *usbdev;
+  int wrote = 0, written = 0;
+  int err = LIBUSB_SUCCESS;
+  usbdev = hexminerm->usbdev;
+  if (libhexm_usb_dead (hexminerm))
+    goto out;
+  while (written < buf_len && err == LIBUSB_SUCCESS)
+    {
+      err =
+        libusb_bulk_transfer (usbdev->handle, 0x02, sendbuf + written,
+                              MIN (HEXM_USB_WR_SIZE, buf_len - written),
+                              &wrote, HEXM_USB_WR_TIME_OUT);
+      if (err == LIBUSB_SUCCESS)
+        written += wrote;
+    }
+out:
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+    info->shut_write = true;
+  return written;
+}
+
+static void
+libhexm_reset (struct cgpu_info *hexminerm)
+{
+  struct hexminerm_info *info = hexminerm->device_data;
+  struct cg_usb_device *usbdev;
+  int err = LIBUSB_SUCCESS;
+  usbdev = hexminerm->usbdev;
+  if (libhexm_usb_dead (hexminerm))
+    goto out;
+  err = libusb_reset_device (usbdev->handle);
+out:
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+    info->shut_reset = true;
+  info->usb_reset_count++;
+}
+
+static int
+libhexm_readHashData (struct cgpu_info *hexminerm, unsigned char *hash,
+                      int *hash_write_pos, int timeout)
+{
+  struct hexminerm_info *info = hexminerm->device_data;
+  struct cg_usb_device *usbdev;
+  int read = 0;
+  int err = LIBUSB_SUCCESS;
+  usbdev = hexminerm->usbdev;
+  if (libhexm_usb_dead (hexminerm))
+    goto out;
+  err =
+    libusb_bulk_transfer (usbdev->handle, 0x82, hash + *hash_write_pos,
+                          HEXM_USB_R_SIZE, &read, timeout);
+  if (err == LIBUSB_SUCCESS)
+    *hash_write_pos += MIN (read, HEXM_USB_R_SIZE);
+out:
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+    info->shut_read = true;
+  return err;
+}
+
+static double
+hexminerm_predecode_nonce_roll (struct cgpu_info *hexminerm,
+                                struct thr_info *thr, uint32_t nonce,
+                                uint8_t work_id, uint8_t rolled)
+{
+  struct hexminerm_info *info = hexminerm->device_data;
+  struct work *work_sub;
+  work_sub = copy_work_noffset_fast_no_id (info->hexworks[work_id], rolled);
+  if (test_nonce (work_sub, nonce))
+    {
+      submit_tested_work_no_clone (thr, work_sub, true);
+      return 1;
+    }
+  free_work (work_sub);
+  return 0;
+}
+
+static void
+libhexm_getvoltage (uint16_t wr_bukvoltage, int *info_pic_voltage_readings)
+{
+  float voltagehuman;
+  voltagehuman =
+    (float) ((float) wr_bukvoltage * (float) 3300 / (float) ((1 << 12) - 1));
+  *info_pic_voltage_readings = (int) voltagehuman;
+}
+
+static void
+libhexm_setvoltage (int info_voltage, uint16_t * refvoltage)
+{
+  uint16_t voltageadc;
+  voltageadc =
+    (uint16_t) ((float) info_voltage / (float) 1000 / (float) 3.3 *
+                ((1 << 12) - 1));
+  *refvoltage = htole16 (voltageadc);
+}
+
+static int
+libhexm_eatHashData (struct workm_result *wr, unsigned char *hash,
+                     int *hash_read_pos, int *hash_write_pos)
+{
+  uint8_t psum;
+  int wrpos;
+  unsigned char *csum_pos;
+  bool ok;
+  int places = 0;
+eat:
+  while (*hash_read_pos < *hash_write_pos && hash[*hash_read_pos] != 0x53)
+    *hash_read_pos += 1;
+  places = *hash_write_pos - *hash_read_pos;
+  if (places < 8)
+    return HEXM_BUF_SKIP;
+  memcpy ((char *) &wr->startbyte, &hash[*hash_read_pos],
+          HEXM_BASE_WORK_SIZE - 1);
+  wr->address = htole16 (wr->address);
+  ok = (wr->command == 0x52)
+    && ((wr->address == HEXM_WORKANSWER_ADR && wr->datalength == 0x05)
+        || (wr->address == 0x3008 && wr->datalength == 1));
+  if (!ok)
+    {
+      *hash_read_pos += 1;
+      goto eat;
+    }
+  if (places < HEXM_BASE_WORK_SIZE + wr->datalength * 2)
+    return HEXM_BUF_SKIP;
+  csum_pos =
+    hash + *hash_read_pos + HEXM_BASE_WORK_SIZE + wr->datalength * 2 - 1;
+  libhexm_csum (hash + *hash_read_pos, csum_pos, &psum);
+  if (psum != *csum_pos)
+    {
+      *hash_read_pos += 1;
+      return HEXM_BUF_ERR;
+    }
+  wrpos = (wr->address - HEXM_WORKANSWER_ADR) + HEXM_BASE_WORK_SIZE - 1;
+  memcpy ((char *) &wr->startbyte + wrpos,
+          &hash[*hash_read_pos + HEXM_BASE_WORK_SIZE - 1],
+          wr->datalength * 2);
+  *hash_read_pos += HEXM_BASE_WORK_SIZE + wr->datalength * 2;
+  return HEXM_BUF_DATA;
+}
+
+static void
+libhexm_shutdown (struct cgpu_info *hexminerm, uint16_t address,
+                  uint16_t word)
+{
+  unsigned char status[65];
+  unsigned char *sendbuf = &status[0];
+  unsigned char *hash = &status[0];
+  struct hexminerm_info *info = hexminerm->device_data;
+  struct cg_usb_device *usbdev;
+  int wrote = 0, written = 0, read = 0;
+  int err = LIBUSB_SUCCESS;
+  size_t buf_len = 8;
+  usbdev = hexminerm->usbdev;
+  uint16_t wr_adr = htole16 (address);
+  uint16_t ledata = htole16 (word);
+  status[0] = 0x53;
+  status[1] = 0x01;
+  status[2] = 0x57;
+  memcpy (status + 3, &wr_adr, 2);
+  memcpy (status + 5, &ledata, 2);
+  libhexm_csum (status, status + 7, status + 7);
+  if (usbdev == NULL || usbdev->handle == NULL || info->shut_read
+      || info->shut_write || info->shut_reset)
+    return;
+  while (written < buf_len && err == LIBUSB_SUCCESS)
+    {
+      err =
+        libusb_bulk_transfer (usbdev->handle, 0x02, sendbuf + written,
+                              MIN (HEXM_USB_WR_SIZE, buf_len - written),
+                              &wrote, HEXM_USB_WR_TIME_OUT);
+      if (err == LIBUSB_SUCCESS)
+        written += wrote;
+        //applog(LOG_ERR, "SHUT lib 2 written %i = 8 buf_len",written);
+    }
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+    return;
+  err =
+      libusb_bulk_transfer (usbdev->handle, 0x82, hash, HEXM_USB_R_SIZE,
+                              &read, 200);
+}
+
+static void
+libhexm_set_words (struct cgpu_info *hexminerm, uint16_t address,
+                   uint16_t word, uint16_t word1)
+{
+  unsigned char status[12];
+  uint16_t wr_adr = htole16 (address);
+  uint16_t ledata = htole16 (word);
+  uint16_t ledata1 = htole16 (word1);
+  status[0] = 0x53;
+  status[1] = 0x02;
+  status[2] = 0x57;
+  memcpy (status + 3, &wr_adr, 2);
+  memcpy (status + 5, &ledata, 2);
+  memcpy (status + 7, &ledata1, 2);
+  libhexm_csum (status, status + 9, status + 9);
+  libhexm_sendHashData (hexminerm, status, 10);
+}
--- cg_o/driver-hexminerm.c	1970-01-01 02:00:00.000000000 +0200
+++ cgminer_hex/driver-hexminerm.c	2014-09-22 14:25:09.000000000 +0300
@@ -0,0 +1,597 @@
+/*$T indentinput.c GC 1.140 10/16/13 10:19:47 */
+#include "config.h"
+#include <limits.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <ctype.h>
+#include <dirent.h>
+#include <unistd.h>
+#ifndef WIN32
+#include <sys/select.h>
+#include <termios.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#ifndef O_CLOEXEC
+#define O_CLOEXEC 0
+#endif
+#else
+#include "compat.h"
+#include <windows.h>
+#include <io.h>
+#endif
+#include "elist.h"
+#include "miner.h"
+#include "usbutils.h"
+#include "driver-hexminerm.h"
+#include <math.h>
+#include "util.h"
+extern unsigned int work_block;
+extern unsigned int work_pool_update;
+extern struct work *copy_work_noffset_fast_no_id (struct work *base_work,
+                                                  int noffset);
+struct device_drv hexminerm_drv;
+extern bool no_work;
+int opt_hexminerm_chip_mask = 0xFF;
+int opt_hexminerm_hw_err_res = 0xFF;
+int opt_hexminerm_nonce_timeout_secs = 0xFF;
+int opt_hexminerm_core_voltage = HEXM_DEFAULT_CORE_VOLTAGE;
+int opt_hexminerm_pic_roll = 0x3c;
+int opt_hexminerm_reset_below_threshold = 94;
+int opt_hexminerm_reset_below_threshold_wait = 190;
+
+#include "libhexm.c"
+
+static int
+hexminerm_send_task (struct hexminerm_task *ht, struct cgpu_info *hexminerm)
+{
+  int ret = 0;
+  size_t nr_len = HEXMINERM_TASK_SIZE;
+  struct hexminerm_info *info;
+  info = hexminerm->device_data;
+  libhexm_csum (&ht->startbyte, &ht->csum, &ht->csum);
+  ret = libhexm_sendHashData (hexminerm, &ht->startbyte, nr_len);
+  if (ret != nr_len && info->usb_bad_reads > -1)
+    {
+      libhexm_reset (hexminerm);
+      info->usb_w_errors++;
+      return -1;
+    }
+  return ret;
+}
+
+static inline void
+hexminerm_create_task (bool reset_work, struct hexminerm_task *ht,
+                       struct work *work)
+{
+  if (reset_work)
+    ht->status = (uint8_t) HEXM_STAT_NEW_WORK_CLEAR_OLD;
+  else
+    ht->status = (uint8_t) HEXM_STAT_NEW_WORK;
+  memcpy (ht->midstate, work->midstate, 32);
+  memcpy (ht->merkle, work->data + 64, 12);
+  ht->id = (uint8_t) work->subid;
+}
+
+static inline void
+hexminerm_init_task_c (struct hexminerm_config_task *htc,
+                       struct hexminerm_info *info)
+{
+  htc->startbyte = 0x53;
+  htc->datalength =
+    (uint8_t) ((sizeof (struct hexminerm_config_task) - 6) / 2);
+  htc->command = 0x57;
+  htc->address = htole16 (0x30C0);
+  htc->hashclock = htole16 ((uint16_t) (info->frequency / 4));
+  libhexm_setvoltage (info->core_voltage, &htc->refvoltage);
+  htc->chip_mask = (uint8_t) info->chip_mask;
+  libhexm_csum (&htc->startbyte, &htc->csum, &htc->csum);
+}
+
+static inline void
+hexminerm_init_task (struct hexminerm_task *ht, struct hexminerm_info *info)
+{
+  ht->startbyte = 0x53;
+  ht->datalength = (uint8_t) ((HEXMINERM_TASK_SIZE - 6) / 2);
+  ht->command = 0x57;
+  ht->address = htole16 (0x3080);
+  ht->status = (uint8_t) HEXM_STAT_NEW_WORK_CLEAR_OLD;
+  ht->roll = (uint8_t) info->pic_roll;
+}
+
+static void
+do_reset (struct cgpu_info *hexminerm)
+{
+  struct hexminerm_info *info = hexminerm->device_data;
+  time_t now = time (NULL);
+  uint8_t i = 0;
+  if (no_work)
+    {
+      while (i < info->asic_count)
+        {
+          info->hw_err[i] = 0;
+/*Pools and all to settle 10 secs add */
+          if (info->last_chip_valid_work[i] > 0)
+            info->last_chip_valid_work[i] = now + 10;
+          i++;
+        }
+      return;
+    }
+  while (i < info->asic_count)
+    {
+      if (!info->chips_enabled[i])
+        {
+          i++;
+          continue;
+        }
+      if (info->last_chip_valid_work[i] > 0
+          && ((now - info->last_chip_valid_work[i]) >=
+              info->opt_hexminerm_nonce_timeout_secs))
+        {
+          libhexm_set_words (hexminerm, HEXM_RES_ADR, (uint16_t) i, 0x0007);
+          applog (LOG_ERR,
+                  "HEXM %i Chip[%i] last received nonce %i secs ago reset",
+                  hexminerm->device_id, i,
+                  (int) (now - info->last_chip_valid_work[i]));
+          info->last_chip_valid_work[i] = now;
+          info->hw_err[i] = 0;
+          info->res_timeout_err[i]++;
+          info->b_reset_count++;
+          break;
+        }
+      if (info->hw_err[i] > info->opt_hexminerm_hw_err_res)
+        {
+          libhexm_set_words (hexminerm, HEXM_RES_ADR, (uint16_t) i, 0x0007);
+          applog (LOG_ERR, "HEXM %i Chip[%i] %i consecutive HW errors reset",
+                  hexminerm->device_id, i, (int) info->hw_err[i]);
+          info->last_chip_valid_work[i] = now;
+          info->hw_err[i] = 0;
+          info->res_hew_err[i]++;
+          info->b_reset_count++;
+          break;
+        }
+      i++;
+    }
+}
+
+static struct cgpu_info *
+hexminerm_detect_one (libusb_device * dev, struct usb_find_devices *found)
+{
+  int asic_count, frequency;
+  struct hexminerm_info *info;
+  struct cgpu_info *hexminerm;
+  bool configured = false;
+  int i = 0;
+  hexminerm = usb_alloc_cgpu (&hexminerm_drv, HEXM_MINER_THREADS);
+  if (!usb_init (hexminerm, dev, found))
+    {
+      usb_uninit (hexminerm);
+      return NULL;
+    }
+  hexminerm->device_data = calloc (sizeof (struct hexminerm_info), 1);
+  if (unlikely (!(hexminerm->device_data)))
+    {
+      hexminerm->device_data = NULL;
+      usb_uninit (hexminerm);
+      return NULL;
+    }
+  if (opt_hexminerm_options != NULL)
+  	configured = (sscanf(opt_hexminerm_options, "%d:%d", &asic_count, &frequency) == 2);	
+  
+  if (opt_hexminerm_core_voltage < HEXM_MIN_COREMV
+      || opt_hexminerm_core_voltage > HEXM_MAX_COREMV)
+    {
+      applog (LOG_ERR, "Invalid hexminerm-voltage %d must be %dmV - %dmV",
+              opt_hexminerm_core_voltage, HEXM_MIN_COREMV, HEXM_MAX_COREMV);
+      free (hexminerm->device_data);
+      hexminerm->device_data = NULL;
+      usb_uninit (hexminerm);
+      return NULL;
+    }
+  info = hexminerm->device_data;
+  info->hexworks = calloc (sizeof (struct work *), HEXMINERM_ARRAY_SIZE);
+  if (unlikely (!(info->hexworks)))
+    {
+      free (hexminerm->device_data);
+      hexminerm->device_data = NULL;
+      usb_uninit (hexminerm);
+      return NULL;
+    }
+  info->wr = (struct workm_result *) malloc (sizeof (struct workm_result));
+  info->array_nonce_cache = calloc (16, sizeof (struct chip_resultsm));
+  info->readbuf = calloc (HEXM_HASH_BUF_SIZE, sizeof (unsigned char));
+  info->write_pos = 0;
+  info->usb_bad_reads = -30;
+  info->hash_read_pos = 0;
+  info->hash_write_pos = 0;
+  info->shut_read = false;
+  info->shut_write = false;
+  info->shut_reset = false;
+  info->miner_count = HEXM_DEFAULT_MINER_NUM;
+  info->asic_count = HEXM_DEFAULT_ASIC_NUM;
+  info->frequency = HEXM_DEFAULT_FREQUENCY;
+  info->pic_voltage_readings = HEXM_DEFAULT_CORE_VOLTAGE;
+  info->core_voltage = opt_hexminerm_core_voltage;
+  info->opt_hexminerm_hw_err_res = opt_hexminerm_hw_err_res;
+  info->opt_hexminerm_nonce_timeout_secs = opt_hexminerm_nonce_timeout_secs;
+  info->chip_mask = opt_hexminerm_chip_mask;
+  info->wr->buf_empty_space = 63;
+  info->work_block_local = -1;
+	info->work_pool_update = -1;
+  info->reset_work = true;
+  info->jobs_to_send = 1;
+  if (configured)
+    {
+      info->asic_count = asic_count;
+      info->frequency = frequency;
+    }
+  info->pic_roll = opt_hexminerm_pic_roll;
+  info->opt_hexminerm_reset_below_threshold = (double)opt_hexminerm_reset_below_threshold / 100;
+  info->opt_hexminerm_reset_below_threshold_wait = (double)opt_hexminerm_reset_below_threshold_wait;
+  gettimeofday (&info->last_wr, NULL);
+  info->rolling1 = (double) (info->asic_count * info->frequency * 99  * info->opt_hexminerm_reset_below_threshold);
+  
+  info->wsem_ustiming =
+    (int64_t) (0x100000000ll /
+               (info->asic_count * info->frequency * 99 *
+                (info->pic_roll + 1) * 0.75));
+  info->ht = calloc (sizeof (struct hexminerm_task), 1);
+  hexminerm_init_task (info->ht, info);
+  while (i < HEXMINERM_ARRAY_SIZE)
+    {
+      info->hexworks[i] = calloc (1, sizeof (struct work));
+      info->hexworks[i]->pool = NULL;
+      i++;
+  } if (!add_cgpu (hexminerm))
+    {
+      free (info->hexworks);
+      free (hexminerm->device_data);
+      hexminerm->device_data = NULL;
+      hexminerm = usb_free_cgpu (hexminerm);
+      usb_uninit (hexminerm);
+      return NULL;
+    }
+  return hexminerm;
+}
+
+static void
+hexminerm_detect (bool __maybe_unused hotplug)
+{
+  usb_detect (&hexminerm_drv, hexminerm_detect_one);
+}
+
+static void
+do_hexminerm_close (struct thr_info *thr)
+{
+  struct cgpu_info *hexminerm = thr->cgpu;
+  struct hexminerm_info *info = hexminerm->device_data;
+  int i = 0;
+  while (i < HEXMINERM_ARRAY_SIZE)
+    {
+      free_work (info->hexworks[i]);
+      i++;
+    }
+  free (info->hexworks);
+  free (info->readbuf);
+  free (info->array_nonce_cache);
+  free (info->wr);
+  free (info->ht);
+}
+
+static void
+hexminerm_shutdown (struct thr_info *thr)
+{
+	struct cgpu_info *hexminerm = thr->cgpu;
+  do_hexminerm_close (thr);
+  /*Power off and try to flush USB */
+  libhexm_shutdown (hexminerm, 0x30AE, 0x0004);
+  usb_nodev (hexminerm);
+}
+
+static bool
+hexminerm_thread_init (struct thr_info *thr)
+{
+  struct cgpu_info *hexminerm = thr->cgpu;
+  struct hexminerm_info *info = hexminerm->device_data;
+  uint8_t i = 0;
+  info->thr = thr;
+  struct hexminerm_config_task *htc;
+  htc = calloc (sizeof (struct hexminerm_config_task), 1);
+  hexminerm_init_task_c (htc, info);
+  cgsleep_ms (200);
+  int ret = libhexm_sendHashData (hexminerm, &htc->startbyte,
+                                  sizeof (struct hexminerm_config_task));
+  if (ret != sizeof (struct hexminerm_config_task))
+  	{
+    	applog (LOG_ERR, "HEXM %i Send config failed disabling!!", hexminerm->device_id);
+   		libhexm_reset(hexminerm);
+   		info->shut_write = true;
+    }
+  free (htc);
+/*Pools and all to settle 10 secs add */
+  time_t now = time (NULL) + 10;
+  while (i < info->asic_count)
+    {
+      info->chips_enabled[i] =
+        (((uint8_t) info->chip_mask & (uint8_t) pow (2, i)) ==
+         (uint8_t) pow (2, i));
+      info->last_chip_valid_work[i] = now;
+      i++;
+    }
+  return true;
+}
+
+static void
+do_write_hexm (struct thr_info *thr)
+{
+  struct cgpu_info *hexminerm = thr->cgpu;
+  struct hexminerm_info *info = hexminerm->device_data;
+  struct work *work;
+  int jobs_to_send = info->jobs_to_send;
+  int send_jobs, ret;
+  send_jobs = 0;
+  while (!libhexm_usb_dead (hexminerm) && (send_jobs < jobs_to_send))
+    {
+      work = get_work (thr, thr->id);
+      work->ping = 1;
+      if (info->work_block_local != work_block || info->work_pool_update != work_pool_update)
+        {
+          info->reset_work = true;
+          send_jobs = 0;
+          jobs_to_send = 2;
+          info->work_pool_update = work_pool_update;
+          info->work_block_local = work_block;
+        }
+      if (info->write_pos >= HEXMINERM_ARRAY_SIZE_REAL)
+        info->write_pos = 0;
+      work->subid = info->write_pos;
+      hexminerm_create_task (info->reset_work, info->ht, work);
+      free_work (info->hexworks[info->write_pos]);
+      info->hexworks[info->write_pos] = work;
+      ret = hexminerm_send_task (info->ht, hexminerm);
+      info->write_pos++;
+      send_jobs++;
+      if (ret == HEXMINERM_TASK_SIZE && info->reset_work)
+        {
+          info->reset_work = false;
+          gettimeofday (&info->last_wr, NULL);
+        }
+    }
+}
+
+static int64_t
+hexminerm_scanhash (struct thr_info *thr)
+{
+	
+  struct cgpu_info *hexminerm = thr->cgpu;
+  struct hexminerm_info *info = hexminerm->device_data;
+  struct timeval now;
+  struct timeval diff;
+	double dev_runtime;
+  int64_t tdif, rethash_count = 0;
+  int ret_r, rminder = 0;
+  double found, hash_count = 0;
+  uint32_t nonce;
+  uint8_t buf_thr = 61, buf_thrl = 57;
+  do_reset (hexminerm);
+  if (info->work_block_local != work_block || info->work_pool_update != work_pool_update)
+    {
+      info->reset_work = true;
+      info->work_block_local = work_block;
+      info->work_pool_update = work_pool_update;
+      info->jobs_to_send = 2;
+      gettimeofday (&info->last_wr, NULL);
+      do_write_hexm (thr);
+      goto done_wr;
+    }
+  gettimeofday (&now, NULL);
+  tdif = timediff (&now, &info->last_wr);
+  info->jobs_to_send = (int) (tdif / info->wsem_ustiming);
+  rminder = (int) (tdif % info->wsem_ustiming);
+  if (info->jobs_to_send > 0 || info->wr->buf_empty_space > buf_thr)
+    {
+      gettimeofday (&info->last_wr, NULL);
+      if (info->wr->buf_empty_space < buf_thrl)
+        goto done_wr;
+      now.tv_sec = 0;
+      now.tv_usec = rminder;
+      timersub (&info->last_wr, &now, &diff);
+      memcpy (&info->last_wr, &diff, sizeof (struct timeval));
+      if (info->wr->buf_empty_space > buf_thr)
+        info->jobs_to_send++;
+      if (info->jobs_to_send > 2)
+        info->jobs_to_send = 2;
+      do_write_hexm (thr);
+    }
+done_wr:
+  if (libhexm_usb_dead (hexminerm))
+    {
+      hexminerm->shutdown = true;
+      return -1;
+    }
+  if (info->hash_write_pos + HEXM_USB_R_SIZE > HEXM_HASH_BUF_SIZE_OK)
+    {
+      info->hash_write_pos = info->hash_write_pos - info->hash_read_pos;
+      memcpy (info->readbuf, info->readbuf + info->hash_read_pos,
+              info->hash_write_pos);
+      info->hash_read_pos = 0;
+    }
+  if (info->hash_write_pos - info->hash_read_pos > 7)
+    {
+    again:
+    	if (info->work_block_local != work_block || info->work_pool_update != work_pool_update)
+    		goto new_block;
+      ret_r =
+        libhexm_eatHashData (info->wr, info->readbuf, &info->hash_read_pos,
+                             &info->hash_write_pos);
+      if (ret_r > HEXM_BUF_DATA)
+        goto out;
+      if (info->wr->datalength == 1)
+        goto done;
+      if (info->wr->lastnonceid > HEXMINERM_ARRAY_SIZE_REAL)
+        info->wr->lastnonceid = 0;
+      if (info->wr->lastchippos > HEXM_DEFAULT_RANGE)
+        info->wr->lastchippos = HEXM_DEFAULT_RANGE;
+      if (libhexm_cachenonce
+          (&info->array_nonce_cache[info->wr->lastchippos],
+           info->wr->lastnonce))
+        {
+          nonce = htole32 (info->wr->lastnonce);
+          found =
+            hexminerm_predecode_nonce_roll (hexminerm, thr, nonce,
+                                            info->wr->lastnonceid,
+                                            info->wr->roll);
+          info->last_chip_valid_work[(uint8_t) info->wr->lastchippos] =
+            time (NULL);
+          if (found > 0)
+            {
+              info->hw_err[info->wr->lastchippos] = 0;
+              if (hash_count == 0)
+                libhexm_getvoltage (htole16 (info->wr->lastvoltage),
+                                    &info->pic_voltage_readings);
+              hash_count += found;
+              info->matching_work[info->wr->lastchippos]++;
+            }
+          else
+            {
+              info->hw_err[info->wr->lastchippos]++;
+              inc_hw_errors (thr);
+            }
+        }
+      else
+        info->dupe[info->wr->lastchippos]++;
+    out:
+      if (ret_r == HEXM_BUF_ERR)
+        info->usb_r_errors++;
+    done:
+      if (ret_r != HEXM_BUF_SKIP)
+        goto again;
+    }
+  if (info->work_block_local != work_block || info->work_pool_update != work_pool_update)
+    		goto new_block;
+  ret_r =
+    libhexm_readHashData (hexminerm, info->readbuf, &info->hash_write_pos,
+                          HEXMINERM_BULK_READ_TIMEOUT);
+  if (ret_r != LIBUSB_SUCCESS)
+    info->usb_bad_reads++;
+  else
+    info->usb_bad_reads = 0;
+  if (info->usb_bad_reads > 20)
+    libhexm_reset (hexminerm);
+  new_block:
+  if (libhexm_usb_dead (hexminerm))
+    {
+      hexminerm->shutdown = true;
+      return -1;
+    }
+	if (hexminerm->dev_start_tv.tv_sec == 0)
+    	dev_runtime = total_secs;  
+  else
+    {
+      cgtime (&now);
+      dev_runtime = tdiff (&now, &(hexminerm->dev_start_tv));
+    }
+  if ((dev_runtime > info->opt_hexminerm_reset_below_threshold_wait) && (hexminerm->rolling1 < info->rolling1)) {
+  		libhexm_shutdown (hexminerm, 0x30AE, 0x0004);
+  		info->shut_write = true;  
+  		usb_nodev(hexminerm);
+    	hexminerm->shutdown = true;	
+  		applog (LOG_ERR,
+                  "HEXM %i restarting due to low hash rate (%f < %f). Uptime %f secs",
+                  hexminerm->device_id, hexminerm->rolling1 , info->rolling1, dev_runtime);
+      return -1;
+   }
+  rethash_count = (0xffffffffull * (int64_t) hash_count);
+  return rethash_count;
+}
+
+static void
+get_hexminerm_statline_before (char *buf, size_t bufsiz,
+                               struct cgpu_info *hexminerm)
+{
+  if (!hexminerm->device_data)
+    return;
+  struct hexminerm_info *info = hexminerm->device_data;
+  tailsprintf (buf, bufsiz, "%3d %4d/%4dmV", info->frequency,
+               info->core_voltage, info->pic_voltage_readings);
+}
+
+extern void suffix_string (uint64_t val, char *buf, size_t bufsiz,
+                           int sigdigits);
+static struct api_data *
+hexminerm_api_stats (struct cgpu_info *cgpu)
+{
+  struct api_data *root = NULL;
+  struct timeval now;
+  struct hexminerm_info *info = cgpu->device_data;
+  char displayed_hashes[16], displayed_rolling[16];
+  double dev_runtime, hwp;
+  uint64_t dh64, dr64;
+  
+  int i;
+  if (!info)
+    return NULL;
+  hwp =
+    (cgpu->hw_errors +
+     cgpu->diff1) ? (double) (cgpu->hw_errors) / (double) (cgpu->hw_errors +
+                                                           cgpu->diff1) : 0;
+  if (cgpu->dev_start_tv.tv_sec == 0)
+    dev_runtime = total_secs;
+  else
+    {
+      cgtime (&now);
+      dev_runtime = tdiff (&now, &(cgpu->dev_start_tv));
+    }
+  if (dev_runtime < 1.0)
+    dev_runtime = 1.0;
+  dh64 = (double) cgpu->total_mhashes / dev_runtime * 1000000ull;
+  dr64 = (double) cgpu->rolling * 1000000ull;
+  suffix_string (dh64, displayed_hashes, sizeof (displayed_hashes), 4);
+  suffix_string (dr64, displayed_rolling, sizeof (displayed_rolling), 4);
+  root = api_add_string (root, "MHS 5s", displayed_rolling, true);
+  root = api_add_string (root, "MHS av", displayed_hashes, true);
+  root = api_add_int (root, "Hardware Errors", &(cgpu->hw_errors), true);
+  root = api_add_percent (root, "Hardware Errors%", &hwp, true);
+  root = api_add_int (root, "USB Read Errors", &(info->usb_r_errors), true);
+  root = api_add_int (root, "USB Write Errors", &(info->usb_w_errors), true);
+  root =
+    api_add_int (root, "USB Reset Count", &(info->usb_reset_count), true);
+  root =
+    api_add_int (root, "Miner Reset Count", &(info->b_reset_count), true);
+  root =
+    api_add_time (root, "Last Share Time", &(cgpu->last_share_pool_time),
+                  true);
+  root = api_add_int (root, "Chip Count", &(info->asic_count), true);
+  root = api_add_int (root, "Frequency", &(info->frequency), true);
+  root = api_add_int (root, "Core Voltage", &(info->core_voltage), true);
+  root =
+    api_add_int (root, "PIC Voltage Readings", &(info->pic_voltage_readings),
+                 true);
+  for (i = 0; i < info->asic_count; i++)
+    {
+      char mcw[24];
+      sprintf (mcw, "Chip%d Nonces", i );
+      root = api_add_int (root, mcw, &(info->matching_work[i]), true);
+      sprintf (mcw, "Chip%d Dupes", i );
+      root = api_add_int (root, mcw, &(info->dupe[i]), true);
+      sprintf (mcw, "Chip%d Timouts Reset", i );
+      root = api_add_int (root, mcw, &(info->res_timeout_err[i]), true);
+      sprintf (mcw, "Chip%d HW Errors Reset", i );
+      root = api_add_int (root, mcw, &(info->res_hew_err[i]), true);
+    }
+  return root;
+}
+
+struct device_drv hexminerm_drv = {
+  .drv_id = DRIVER_hexminerm,
+  .dname = "hexminerm",
+  .name = "HEXM",
+  .drv_detect = hexminerm_detect,
+  .thread_init = hexminerm_thread_init,
+  .hash_work = hash_driver_work,
+  .scanwork = hexminerm_scanhash,
+  .get_api_stats = hexminerm_api_stats,
+  .get_statline_before = get_hexminerm_statline_before,
+  .thread_shutdown = hexminerm_shutdown,
+};
--- cg_o/driver-hexminerm.h	1970-01-01 02:00:00.000000000 +0200
+++ cgminer_hex/driver-hexminerm.h	2014-09-22 14:25:09.000000000 +0300
@@ -0,0 +1,151 @@
+/*$T indentinput.h GC 1.140 10/16/13 10:20:01 */
+#ifndef HEXM_H
+#define HEXM_H
+#ifdef USE_HEXMINERM
+#include "util.h"
+
+/* hexminerm_task/work_reply status Definitions: */
+#define HEXM_STAT_IDLE 0        /* Idle or data already Sent to the buffer */
+#define HEXM_STAT_NEW_WORK 1    /* Request for write in the buffer */
+#define HEXM_STAT_WAITING 2     /* Wait For Buffer Empty Position */
+#define HEXM_STAT_CLR_BUFF 3    /* Force Buffer Empty */
+#define HEXM_STAT_STOP_REQ 4    /* Stop Request */
+#define HEXM_STAT_NEW_WORK_CLEAR_OLD 5  /* Clear Buffers and after that fill the first buffer */
+#define HEXM_STAT_UNUSED 6
+#define HEXM_STAT_RES_HW 12
+#define HEXM_STAT_RES_NO_NONCE 13
+/* libhexm_eatHashData/BUF_reply status Definitions: */
+#define HEXM_BUF_DATA 0
+#define HEXM_BUF_ERR 1
+#define HEXM_BUF_SKIP 2
+/* MISC */
+#define HEXMINERM_ARRAY_PIC_SIZE 64
+#define HEXMINERM_ARRAY_SIZE HEXMINERM_ARRAY_PIC_SIZE
+#define HEXMINERM_ARRAY_SIZE_REAL HEXMINERM_ARRAY_SIZE - 2
+#define HEXM_NONCE_CASH_SIZE 4
+#define HEXM_USB_R_SIZE 64
+#define HEXM_USB_WR_SIZE 64
+#define HEXM_HASH_BUF_SIZE 2048
+#define HEXM_HASH_BUF_SIZE_OK HEXM_HASH_BUF_SIZE - 4
+#define HEXMINERM_BULK_READ_TIMEOUT 1000
+#define HEXM_USB_WR_TIME_OUT 500
+#define HEXM_MINER_THREADS 1
+#define HEXM_DEFAULT_MINER_NUM 0x01
+#define HEXM_DEFAULT_ASIC_NUM 0x04
+#define HEXM_DEFAULT_RANGE HEXM_DEFAULT_ASIC_NUM - 1
+#define HEXM_MIN_FREQUENCY 0
+#define HEXM_MAX_FREQUENCY 1200
+#define HEXM_DEFAULT_FREQUENCY 1024
+#define HEXM_DEFAULT_CORE_VOLTAGE 820   /* in millivolts */
+#define HEXM_MIN_COREMV 600     /* in millivolts */
+#define HEXM_MAX_COREMV 1001    /* in millivolts */
+struct chip_resultsm
+{
+  uint8_t nonce_cache_write_pos;
+  uint32_t nonces[HEXM_NONCE_CASH_SIZE];
+};
+struct hexminerm_task
+{
+  uint8_t startbyte;
+  uint8_t datalength;
+  uint8_t command;
+  uint16_t address;
+  uint8_t midstate[32];
+  uint32_t merkle[3];
+  uint8_t roll;
+  uint8_t id;
+  uint8_t status;
+  uint8_t dum;
+  uint8_t csum;
+  uint8_t pad[6];
+} __attribute__ ((packed, aligned (4)));
+struct workm_result
+{
+  uint8_t startbyte;
+  uint8_t datalength;
+  uint8_t command;
+  uint16_t address;
+  uint32_t lastnonce;
+  uint8_t roll;
+  uint8_t lastnonceid;
+  uint16_t lastvoltage;
+  uint8_t lastchippos;
+  uint8_t buf_empty_space;
+  uint8_t csum;
+  uint8_t pad[4];
+} __attribute__ ((packed, aligned (4)));
+struct hexminerm_info
+{
+  struct timeval last_wr;
+  int jobs_to_send;
+  int64_t wsem_ustiming;
+  bool shut_read;
+  bool shut_write;
+  bool shut_reset;
+  bool reset_work;
+  int usb_bad_reads;
+  int write_pos;
+  int chip_mask;
+  bool chips_enabled[HEXM_DEFAULT_ASIC_NUM];
+  int miner_count;
+  int asic_count;
+  int pic_roll;
+  int core_voltage;
+  int opt_hexminerm_hw_err_res;
+  int opt_hexminerm_nonce_timeout_secs;
+  double opt_hexminerm_reset_below_threshold;
+  double opt_hexminerm_reset_below_threshold_wait;
+  int frequency;
+  int usb_r_errors;
+  int usb_w_errors;
+  int usb_reset_count;
+  int b_reset_count;
+  int pic_voltage_readings;
+  int hash_read_pos;
+  int hash_write_pos;
+  int dupe[HEXM_DEFAULT_ASIC_NUM];
+  int res_hew_err[HEXM_DEFAULT_ASIC_NUM];
+  int res_timeout_err[HEXM_DEFAULT_ASIC_NUM];
+  int matching_work[HEXM_DEFAULT_ASIC_NUM];
+  int hw_err[HEXM_DEFAULT_ASIC_NUM];
+  unsigned int work_block_local;
+  unsigned int work_pool_update;
+  unsigned char *readbuf;
+  struct workm_result *wr;
+  struct chip_resultsm *array_nonce_cache;
+  struct thr_info *thr;
+  struct work **hexworks;
+  time_t last_chip_valid_work[HEXM_DEFAULT_ASIC_NUM];
+  struct hexminerm_task *ht;
+  double rolling1;
+};
+struct hexminerm_config_task
+{
+  uint8_t startbyte;
+  uint8_t datalength;
+  uint8_t command;
+  uint16_t address;
+  uint16_t hashclock;
+  uint16_t refvoltage;
+  uint32_t difficulty;
+  uint8_t chip_mask;
+  uint8_t wr_interwal;
+  uint8_t csum;
+} __attribute__ ((packed, aligned (4)));
+
+#define HEXM_WORKANSWER_ADR 0x3000
+#define HEXM_RES_ADR 0x30AC
+#define HEXMINERM_TASK_SIZE (sizeof(struct hexminerm_task)-6)
+#define HEXM_MAX_WORK_SIZE (sizeof(struct workm_result)-4)
+#define HEXM_BASE_WORK_SIZE 6
+extern int opt_hexminerm_core_voltage;
+extern int opt_hexminerm_chip_mask;
+extern int opt_hexminerm_hw_err_res;
+extern int opt_hexminerm_pic_roll;
+extern int opt_hexminerm_nonce_timeout_secs;
+extern int opt_hexminerm_reset_below_threshold;
+extern int opt_hexminerm_reset_below_threshold_wait;
+extern struct hexminerm_info **hexminerm_info;
+
+#endif /* USE_HEXMINERM */
+#endif /* HEXM_H */
--- cg_o/libhexbe200.c	1970-01-01 02:00:00.000000000 +0200
+++ cgminer_hex/libhexbe200.c	2014-09-22 19:28:38.671387123 +0300
@@ -0,0 +1,298 @@
+static int64_t
+timediff (const struct timeval *a, const struct timeval *b)
+{
+  struct timeval diff;
+  timersub (a, b, &diff);
+  return diff.tv_sec * 1000000 + diff.tv_usec;
+}
+
+static bool
+libhex_be200_cachenonce (struct chip_resultsbe200 *nonce_cache,
+                         uint32_t nonce)
+{
+  int i = 0;
+  while (i < HEX_BE200NONCE_CASH_SIZE && nonce_cache->nonces[i] != nonce)
+    i++;
+  if (i < HEX_BE200NONCE_CASH_SIZE)
+    return false;
+  if (nonce_cache->nonce_cache_write_pos == HEX_BE200NONCE_CASH_SIZE)
+    nonce_cache->nonce_cache_write_pos = 0;
+  nonce_cache->nonces[nonce_cache->nonce_cache_write_pos++] = nonce;
+  return true;
+}
+
+static void
+libhex_be200_csum (unsigned char *startptr, unsigned char *endptr,
+                   unsigned char *resptr)
+{
+  unsigned char *b = startptr;
+  uint8_t sum = 0;
+  while (b < endptr)
+    sum += *b++;
+  memcpy (resptr, &sum, 1);
+}
+
+static bool
+libhex_be200_usb_dead (struct cgpu_info *hexminerbe200)
+{
+  struct cg_usb_device *usbdev;
+  struct hexminerbe200_info *info = hexminerbe200->device_data;
+  if (!info)
+    return true;
+  usbdev = hexminerbe200->usbdev;
+  bool ret = (usbdev == NULL || usbdev->handle == NULL
+              || hexminerbe200->shutdown || info->shut_read
+              || info->shut_write || info->shut_reset
+              || hexminerbe200->usbinfo.nodev
+              || hexminerbe200->deven != DEV_ENABLED);
+  return ret;
+}
+
+static int
+libhex_be200_sendHashData (struct cgpu_info *hexminerbe200,
+                           unsigned char *sendbuf, size_t buf_len)
+{
+  struct hexminerbe200_info *info = hexminerbe200->device_data;
+  struct cg_usb_device *usbdev;
+  int wrote = 0, written = 0;
+  int err = LIBUSB_SUCCESS;
+  usbdev = hexminerbe200->usbdev;
+  if (libhex_be200_usb_dead (hexminerbe200))
+    goto out;
+  while (written < buf_len && err == LIBUSB_SUCCESS)
+    {
+      err =
+        libusb_bulk_transfer (usbdev->handle, 0x02, sendbuf + written,
+                              MIN (HEX_BE200USB_WR_SIZE, buf_len - written),
+                              &wrote, HEX_BE200USB_WR_TIME_OUT);
+      if (err == LIBUSB_SUCCESS)
+        written += wrote;
+    }
+out:
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+    info->shut_write = true;
+  return written;
+}
+
+static void
+libhex_be200_reset (struct cgpu_info *hexminerbe200)
+{
+  struct hexminerbe200_info *info = hexminerbe200->device_data;
+  struct cg_usb_device *usbdev;
+  int err = LIBUSB_SUCCESS;
+  usbdev = hexminerbe200->usbdev;
+  if (libhex_be200_usb_dead (hexminerbe200))
+    goto out;
+  err = libusb_reset_device (usbdev->handle);
+out:
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+    info->shut_reset = true;
+  info->usb_reset_count++;
+}
+
+static int
+libhex_be200_readHashData (struct cgpu_info *hexminerbe200,
+                           unsigned char *hash, int *hash_write_pos,
+                           int timeout)
+{
+  struct hexminerbe200_info *info = hexminerbe200->device_data;
+  struct cg_usb_device *usbdev;
+  int read = 0;
+  int err = LIBUSB_SUCCESS;
+  usbdev = hexminerbe200->usbdev;
+  if (libhex_be200_usb_dead (hexminerbe200))
+    goto out;
+  err =
+    libusb_bulk_transfer (usbdev->handle, 0x82, hash + *hash_write_pos,
+                          HEX_BE200USB_R_SIZE, &read, timeout);
+  if (err == LIBUSB_SUCCESS)
+    *hash_write_pos += MIN (read, HEX_BE200USB_R_SIZE);
+out:
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+    {
+      info->shut_read = true;
+    }
+  return err;
+}
+
+/*LTE TBD!!! */
+static double
+be200_nonce_roll (struct cgpu_info *hexminerbe200, struct thr_info *thr,
+                  uint32_t nonce, uint8_t work_id, uint8_t rolled,
+                  uint8_t interval)
+{
+  struct hexminerbe200_info *info = hexminerbe200->device_data;
+  struct work *work_sub;
+  int i = 1;
+  double ret = 0;
+  uint32_t nonce_to_test;
+  work_sub = copy_work_noffset_fast_no_id (info->hexworks[work_id], rolled);
+  if (test_nonce (work_sub, nonce))
+    {
+#ifdef DBG_HW_HEXBE200
+      info->nincdec[interval]++;
+#endif
+      submit_tested_work_no_clone (thr, work_sub, true);
+      ret = 1;
+    }
+  else
+    {
+      while (i < HEX_BE200NROLL)
+        {
+          nonce_to_test = nonce + i;
+          if (test_nonce (work_sub, nonce_to_test))
+            {
+#ifdef DBG_HW_HEXBE200
+              info->nincdec[interval + i]++;
+#endif
+              submit_tested_work_no_clone (thr, work_sub, true);
+              ret = 1;
+              break;
+            }
+          nonce_to_test = nonce - i;
+          if (test_nonce (work_sub, nonce_to_test))
+            {
+#ifdef DBG_HW_HEXBE200
+              info->nincdec[interval - i]++;
+#endif
+              submit_tested_work_no_clone (thr, work_sub, true);
+              ret = 1;
+              break;
+            }
+          i++;
+        }
+    }
+  if (ret == 0)
+    free_work (work_sub);
+  return ret;
+}
+
+/*LTE TBD!!! */
+static void
+libhex_be200_getvoltage (uint16_t wr_bukvoltage,
+                         int *info_pic_voltage_readings)
+{
+  float voltagehuman;
+  voltagehuman =
+    (float) ((float) wr_bukvoltage * (float) 3300 / (float) ((1 << 12) - 1));
+  *info_pic_voltage_readings = (int) voltagehuman;
+}
+
+static void
+libhex_be200_setvoltage (int info_voltage, uint16_t * refvoltage)
+{
+  uint16_t voltageadc;
+  voltageadc =
+    (uint16_t) ((float) info_voltage / (float) 1000 / (float) 3.3 *
+                ((1 << 12) - 1));
+  *refvoltage = htole16 (voltageadc);
+}
+
+static int
+libhex_be200_eatHashData (struct workbe200_result *wr, unsigned char *hash,
+                          int *hash_read_pos, int *hash_write_pos)
+{
+  uint8_t psum;
+  int wrpos;
+  unsigned char *csum_pos;
+  bool ok;
+  int places = 0;
+eat:
+  while (*hash_read_pos < *hash_write_pos && hash[*hash_read_pos] != 0x53)
+    *hash_read_pos += 1;
+  places = *hash_write_pos - *hash_read_pos;
+  if (places < 8)
+    return HEX_BE200BUF_SKIP;
+  memcpy ((char *) &wr->startbyte, &hash[*hash_read_pos],
+          HEX_BE200BASE_WORK_SIZE - 1);
+  wr->address = htole16 (wr->address);
+  ok = (wr->command == 0x52)
+    && ((wr->address == HEX_BE200WORKANSWER_ADR && wr->datalength == 0x05)
+        || (wr->address == 0x3008 && wr->datalength == 1));
+  if (!ok)
+    {
+      *hash_read_pos += 1;
+      goto eat;
+    }
+  if (places < HEX_BE200BASE_WORK_SIZE + wr->datalength * 2)
+    return HEX_BE200BUF_SKIP;
+  csum_pos =
+    hash + *hash_read_pos + HEX_BE200BASE_WORK_SIZE + wr->datalength * 2 - 1;
+  {
+    libhex_be200_csum (hash + *hash_read_pos, csum_pos, &psum);
+    if (psum != *csum_pos)
+      {
+        *hash_read_pos += 1;
+        return HEX_BE200BUF_ERR;
+      }
+  }
+  wrpos =
+    (wr->address - HEX_BE200WORKANSWER_ADR) + HEX_BE200BASE_WORK_SIZE - 1;
+  memcpy ((char *) &wr->startbyte + wrpos,
+          &hash[*hash_read_pos + HEX_BE200BASE_WORK_SIZE - 1],
+          wr->datalength * 2);
+  *hash_read_pos += HEX_BE200BASE_WORK_SIZE + wr->datalength * 2;
+  return HEX_BE200BUF_DATA;
+}
+
+static void
+libhex_be200_shutdown (struct cgpu_info *hexminerbe200, uint16_t address,
+                       uint16_t word)
+{
+  unsigned char status[65];
+  unsigned char *sendbuf = &status[0];
+  unsigned char *hash = &status[0];
+  struct hexminerbe200_info *info = hexminerbe200->device_data;
+  struct cg_usb_device *usbdev;
+  int wrote = 0, written = 0, read = 0;
+  int err = LIBUSB_SUCCESS;
+  size_t buf_len = 8;
+  usbdev = hexminerbe200->usbdev;
+  uint16_t wr_adr = htole16 (address);
+  uint16_t ledata = htole16 (word);
+  status[0] = 0x53;
+  status[1] = 0x01;
+  status[2] = 0x57;
+  memcpy (status + 3, &wr_adr, 2);
+  memcpy (status + 5, &ledata, 2);
+  libhex_be200_csum (status, status + 7, status + 7);
+  if (usbdev == NULL || usbdev->handle == NULL || info->shut_read
+      || info->shut_write || info->shut_reset)
+    return;
+  while (written < buf_len && err == LIBUSB_SUCCESS)
+    {
+      err =
+        libusb_bulk_transfer (usbdev->handle, 0x02, sendbuf + written,
+                              MIN (HEX_BE200USB_WR_SIZE, buf_len - written),
+                              &wrote, HEX_BE200USB_WR_TIME_OUT);
+      if (err == LIBUSB_SUCCESS)
+        written += wrote;
+    }
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+    return;
+  //err = LIBUSB_SUCCESS;
+  //while (err == LIBUSB_SUCCESS)
+    {
+      err =
+        libusb_bulk_transfer (usbdev->handle, 0x82, hash, HEX_BE200USB_R_SIZE,
+                              &read, 200);
+    }
+}
+
+static void
+libhex_be200_set_words (struct cgpu_info *hexminerbe200, uint16_t address,
+                        uint16_t word, uint16_t word1)
+{
+  unsigned char status[12];
+  uint16_t wr_adr = htole16 (address);
+  uint16_t ledata = htole16 (word);
+  uint16_t ledata1 = htole16 (word1);
+  status[0] = 0x53;
+  status[1] = 0x02;
+  status[2] = 0x57;
+  memcpy (status + 3, &wr_adr, 2);
+  memcpy (status + 5, &ledata, 2);
+  memcpy (status + 7, &ledata1, 2);
+  libhex_be200_csum (status, status + 9, status + 9);
+  libhex_be200_sendHashData (hexminerbe200, status, 10);
+}
--- cg_o/driver-hexminerbe200.c	1970-01-01 02:00:00.000000000 +0200
+++ cgminer_hex/driver-hexminerbe200.c	2014-09-22 19:28:38.671387123 +0300
@@ -0,0 +1,659 @@
+/*$T indentinput.c GC 1.140 10/16/13 10:19:47*/
+#include "config.h"
+#include <limits.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <ctype.h>
+#include <dirent.h>
+#include <unistd.h>
+#ifndef WIN32
+#include <sys/select.h>
+#include <termios.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#ifndef O_CLOEXEC
+#define O_CLOEXEC 0
+#endif
+#else
+#include "compat.h"
+#include <windows.h>
+#include <io.h>
+#endif
+#include "elist.h"
+#include "miner.h"
+#include "usbutils.h"
+#include "driver-hexminerbe200.h"
+#include <math.h>
+#include "util.h"
+extern unsigned int work_block;
+extern unsigned int work_pool_update;
+extern struct work *copy_work_noffset_fast_no_id (struct work *base_work,
+                                                  int noffset);
+extern bool no_work;
+struct device_drv hexminerbe200_drv;
+int opt_hexminerbe200_chip_mask = 0xFFFF;
+int opt_hexminerbe200_hw_err_res = 10;
+int opt_hexminerbe200_nonce_timeout_secs = 10;
+int opt_hexminerbe200_diff = 0;
+int opt_hexminerbe200_skip_hw_res = 1;
+int opt_hexminerbe200_core_voltage = HEX_BE200DEFAULT_CORE_VOLTAGE;
+int opt_hexminerbe200_pic_roll = 0x3c;
+#include "libhexbe200.c"
+
+static int
+hexminerbe200_send_task (struct hexminerbe200_task *ht,
+                         struct cgpu_info *hexminerbe200)
+{
+  int ret = 0;
+  size_t nr_len = HEXMINERBE200_TASK_SIZE;
+  struct hexminerbe200_info *info;
+  info = hexminerbe200->device_data;
+  libhex_be200_csum (&ht->startbyte, &ht->csum, &ht->csum);
+  ret = libhex_be200_sendHashData (hexminerbe200, &ht->startbyte, nr_len);
+  if (ret != nr_len && info->usb_bad_reads > -1)
+    {
+      libhex_be200_reset (hexminerbe200);
+      info->usb_w_errors++;
+      return -1;
+    }
+  return ret;
+}
+
+static inline void
+hexminerbe200_create_task (bool reset_work, struct hexminerbe200_task *ht,
+                           struct work *work)
+{
+  if (reset_work)
+    ht->status = (uint8_t) HEX_BE200STAT_NEW_WORK_CLEAR_OLD;
+  else
+    ht->status = (uint8_t) HEX_BE200STAT_NEW_WORK;
+  memcpy (ht->midstate, work->midstate, 32);
+  memcpy (ht->merkle, work->data + 64, 12);
+  ht->id = (uint8_t) work->subid;
+}
+
+static inline void
+hexminerbe200_init_task_c (struct hexminerbe200_config_task *htc,
+                           struct hexminerbe200_info *info)
+{
+  htc->startbyte = 0x53;
+  htc->datalength =
+    (uint8_t) ((sizeof (struct hexminerbe200_config_task) - 6) / 2);
+  htc->command = 0x57;
+  htc->address = htole16 (0x30C0);
+  htc->hashclock = htole16 ((uint16_t) (info->frequency));
+  libhex_be200_setvoltage (info->core_voltage, &htc->refvoltage);
+  htc->chip_mask = (uint16_t) htole16 (info->chip_mask);
+  libhex_be200_csum (&htc->startbyte, &htc->csum, &htc->csum);
+}
+
+static inline void
+hexminerbe200_init_task (struct hexminerbe200_task *ht,
+                         struct hexminerbe200_info *info)
+{
+  ht->startbyte = 0x53;
+  ht->datalength = (uint8_t) ((HEXMINERBE200_TASK_SIZE - 6) / 2);
+  ht->command = 0x57;
+  ht->address = htole16 (0x3080);
+  ht->status = (uint8_t) HEX_BE200STAT_NEW_WORK_CLEAR_OLD;
+  ht->roll = (uint8_t) info->pic_roll;
+  ht->diff = htole16 (info->diff);
+}
+
+static void
+do_reset (struct cgpu_info *hexminerbe200)
+{
+  struct hexminerbe200_info *info = hexminerbe200->device_data;
+  time_t now = time (NULL);
+  uint8_t i = 0;
+  if (no_work)
+    {
+      while (i < info->asic_count)
+        {
+          info->hw_err[i] = 0;
+          /*Pools and all to settle 10 secs add */
+          if (info->last_chip_valid_work[i] > 0)
+            info->last_chip_valid_work[i] = now + 20;
+          i++;
+        }
+      return;
+    }
+  while (i < info->asic_count)
+    {
+      if (!info->chips_enabled[i])
+        {
+          i++;
+          continue;
+        }
+      if (info->last_chip_valid_work[i] > 0
+          && ((now - info->last_chip_valid_work[i]) >=
+              info->opt_hexminerbe200_nonce_timeout_secs))
+        {
+          if (info->opt_hexminerbe200_skip_hw_res == 0)
+            {
+              libhex_be200_set_words (hexminerbe200, HEX_BE200RES_ADR,
+                                      (uint16_t) i, 0x0007);
+              applog (LOG_ERR,
+                      "HEXE %i Chip[%i] last received nonce %i secs ago reset",
+                      hexminerbe200->device_id, i,
+                      (int) (now - info->last_chip_valid_work[i]));
+            }
+          else
+            {
+              applog (LOG_ERR,
+                      "HEXE %i Chip[%i] last received nonce %i secs ago log only",
+                      hexminerbe200->device_id, i,
+                      (int) (now - info->last_chip_valid_work[i]));
+            }
+          info->last_chip_valid_work[i] = now;
+          info->hw_err[i] = 0;
+          info->res_timeout_err[i]++;
+          info->b_reset_count++;
+          break;
+        }
+      if (info->hw_err[i] > info->opt_hexminerbe200_hw_err_res)
+        {
+          if (info->opt_hexminerbe200_skip_hw_res == 0)
+            {
+              libhex_be200_set_words (hexminerbe200, HEX_BE200RES_ADR,
+                                      (uint16_t) i, 0x0007);
+              applog (LOG_ERR,
+                      "HEXE %i Chip[%i] %i consecutive HW errors reset",
+                      hexminerbe200->device_id, i, (int) info->hw_err[i]);
+            }
+          else
+              applog (LOG_ERR,
+                      "HEXE %i Chip[%i] %i consecutive HW errors log only",
+                      hexminerbe200->device_id, i, (int) info->hw_err[i]);
+          info->last_chip_valid_work[i] = now;
+          info->hw_err[i] = 0;
+          info->res_hew_err[i]++;
+          info->b_reset_count++;
+          break;
+        }
+      i++;
+    }
+}
+
+static struct cgpu_info *
+hexminerbe200_detect_one (libusb_device * dev, struct usb_find_devices *found)
+{
+  int asic_count, frequency;
+  struct hexminerbe200_info *info;
+  struct cgpu_info *hexminerbe200;
+  bool configured = false;
+  int i = 0;
+  hexminerbe200 = usb_alloc_cgpu (&hexminerbe200_drv, HEX_BE200MINER_THREADS);
+  if (!usb_init (hexminerbe200, dev, found))
+    {
+      usb_uninit (hexminerbe200);
+      return NULL;
+    }
+  hexminerbe200->device_data = calloc (sizeof (struct hexminerbe200_info), 1);
+  if (unlikely (!(hexminerbe200->device_data)))
+    {
+      hexminerbe200->device_data = NULL;
+      usb_uninit (hexminerbe200);
+      return NULL;
+    }
+   if (opt_hexminerbe200_options != NULL)
+  	configured = (sscanf(opt_hexminerbe200_options, "%d:%d", &asic_count, &frequency) == 2);	
+  
+  if (opt_hexminerbe200_core_voltage < HEX_BE200MIN_COREMV
+      || opt_hexminerbe200_core_voltage > HEX_BE200MAX_COREMV)
+    {
+      applog (LOG_ERR, "Invalid hexminerbe200-voltage %d must be %dmV - %dmV",
+              opt_hexminerbe200_core_voltage, HEX_BE200MIN_COREMV,
+              HEX_BE200MAX_COREMV);
+      free (hexminerbe200->device_data);
+      hexminerbe200->device_data = NULL;
+      usb_uninit (hexminerbe200);
+      return NULL;
+    }
+  info = hexminerbe200->device_data;
+  info->hexworks = calloc (sizeof (struct work *), HEXMINERBE200_ARRAY_SIZE);
+  if (unlikely (!(info->hexworks)))
+    {
+      free (hexminerbe200->device_data);
+      hexminerbe200->device_data = NULL;
+      usb_uninit (hexminerbe200);
+      return NULL;
+    }
+  info->wr =
+    (struct workbe200_result *) malloc (sizeof (struct workbe200_result));
+  info->array_nonce_cache = calloc (16, sizeof (struct chip_resultsbe200));
+  info->readbuf = calloc (HEX_BE200HASH_BUF_SIZE, sizeof (unsigned char));
+  info->write_pos = 0;
+  info->usb_bad_reads = -30;
+  info->hash_read_pos = 0;
+  info->hash_write_pos = 0;
+  info->shut_read = false;
+  info->shut_write = false;
+  info->shut_reset = false;
+  info->miner_count = HEX_BE200DEFAULT_MINER_NUM;
+  info->asic_count = HEX_BE200DEFAULT_ASIC_NUM;
+  info->frequency = HEX_BE200DEFAULT_FREQUENCY;
+  info->pic_voltage_readings = HEX_BE200DEFAULT_CORE_VOLTAGE;
+  info->core_voltage = opt_hexminerbe200_core_voltage;
+  info->opt_hexminerbe200_hw_err_res = opt_hexminerbe200_hw_err_res;
+  info->opt_hexminerbe200_nonce_timeout_secs =
+    opt_hexminerbe200_nonce_timeout_secs;
+  info->diff = opt_hexminerbe200_diff;
+  info->opt_hexminerbe200_skip_hw_res = opt_hexminerbe200_skip_hw_res;
+  info->chip_mask = opt_hexminerbe200_chip_mask;
+  info->wr->buf_empty_space = 63;
+  info->work_block_local = -1;
+  info->work_pool_update = -1;
+  info->reset_work = true;
+  info->jobs_to_send = 1;
+  if (configured)
+    {
+      info->asic_count = asic_count;
+      info->frequency = frequency;
+    }
+  info->pic_roll = opt_hexminerbe200_pic_roll;
+  gettimeofday (&info->last_wr, NULL);
+  info->wsem_ustiming =
+    (int64_t) (0x100000000ll /
+               (info->asic_count * info->frequency * 32 *
+                (info->pic_roll + 1) * 0.75));
+  info->ht = calloc (sizeof (struct hexminerbe200_task), 1);
+  hexminerbe200_init_task (info->ht, info);
+  while (i < HEXMINERBE200_ARRAY_SIZE)
+    {
+      info->hexworks[i] = calloc (1, sizeof (struct work));
+      info->hexworks[i]->pool = NULL;
+      i++;
+    }
+  if (!add_cgpu (hexminerbe200))
+    {
+      free (info->hexworks);
+      free (hexminerbe200->device_data);
+      hexminerbe200->device_data = NULL;
+      hexminerbe200 = usb_free_cgpu (hexminerbe200);
+      usb_uninit (hexminerbe200);
+      return NULL;
+    }
+  return hexminerbe200;
+}
+
+static void
+hexminerbe200_detect (bool __maybe_unused hotplug)
+{
+  usb_detect (&hexminerbe200_drv, hexminerbe200_detect_one);
+}
+
+static void
+do_hexminerbe200_close (struct thr_info *thr)
+{
+  struct cgpu_info *hexminerbe200 = thr->cgpu;
+  struct hexminerbe200_info *info = hexminerbe200->device_data;
+  int i = 0;
+  while (i < HEXMINERBE200_ARRAY_SIZE)
+    {
+      free_work (info->hexworks[i]);
+      i++;
+    }
+  free (info->hexworks);
+  free (info->readbuf);
+  free (info->array_nonce_cache);
+  free (info->wr);
+  free (info->ht);
+}
+
+static void
+hexminerbe200_shutdown (struct thr_info *thr)
+{
+  struct cgpu_info *hexminerbe200 = thr->cgpu;
+  do_hexminerbe200_close (thr);
+  /*Power off and try to flush USB */
+  libhex_be200_shutdown (hexminerbe200, 0x30AE, 0x0004);
+  usb_nodev (hexminerbe200);
+}
+
+static bool
+hexminerbe200_thread_init (struct thr_info *thr)
+{
+  struct cgpu_info *hexminerbe200 = thr->cgpu;
+  struct hexminerbe200_info *info = hexminerbe200->device_data;
+  struct hexminerbe200_config_task *htc;
+  uint8_t i = 0;
+  info->thr = thr;
+  htc = calloc (sizeof (struct hexminerbe200_config_task), 1);
+  hexminerbe200_init_task_c (htc, info);
+  cgsleep_ms (200);
+  int ret = libhex_be200_sendHashData (hexminerbe200, &htc->startbyte,
+                                       sizeof (struct
+                                               hexminerbe200_config_task));
+  if (ret != sizeof (struct hexminerbe200_config_task))
+  	{
+    applog (LOG_ERR, "HEXE %i Send config failed disabling!!", hexminerbe200->device_id);
+   	libhex_be200_reset(hexminerbe200);
+   	info->shut_write = true;
+   }
+  free (htc);
+  /*Pools and all to settle 10 secs add */
+  time_t now = time (NULL) + 10;
+  while (i < info->asic_count)
+    {
+      info->chips_enabled[i] =
+        (((uint16_t) info->chip_mask & (uint16_t) pow (2, i)) ==
+         (uint16_t) pow (2, i));
+      info->last_chip_valid_work[i] = now;
+      i++;
+    }
+  return true;
+}
+
+static void
+do_write_hexm (struct thr_info *thr)
+{
+  struct cgpu_info *hexminerbe200 = thr->cgpu;
+  struct hexminerbe200_info *info = hexminerbe200->device_data;
+  struct work *work;
+  int jobs_to_send = info->jobs_to_send;
+  int send_jobs, ret;
+  send_jobs = 0;
+  while (!libhex_be200_usb_dead (hexminerbe200) && (send_jobs < jobs_to_send))
+    {
+      work = get_work (thr, thr->id);
+      if (info->diff == 0)
+        work->ping = 1;
+      else
+        work->ping = 0;
+      if (info->work_block_local != work_block || info->work_pool_update != work_pool_update)
+        {
+          info->reset_work = true;
+          send_jobs = 0;
+          jobs_to_send = 2;
+          info->work_block_local = work_block;
+          info->work_pool_update = work_pool_update;
+        }
+      if (info->write_pos >= HEXMINERBE200_ARRAY_SIZE_REAL)
+        info->write_pos = 0;
+      work->subid = info->write_pos;
+      hexminerbe200_create_task (info->reset_work, info->ht, work);
+      free_work (info->hexworks[info->write_pos]);
+      info->hexworks[info->write_pos] = work;
+      ret = hexminerbe200_send_task (info->ht, hexminerbe200);
+      info->write_pos++;
+      send_jobs++;
+      if (ret == HEXMINERBE200_TASK_SIZE && info->reset_work)
+        {
+          info->reset_work = false;
+          gettimeofday (&info->last_wr, NULL);
+        }
+    }
+}
+
+extern void inc_hw_errors_hex8 (struct thr_info *thr, int diff);
+
+static int64_t
+hexminerbe200_scanhash (struct thr_info *thr)
+{
+  struct cgpu_info *hexminerbe200 = thr->cgpu;
+  struct hexminerbe200_info *info = hexminerbe200->device_data;
+  struct timeval now;
+  struct timeval diff;
+  int64_t tdif, rethash_count = 0;
+  int ret_r, rminder = 0;
+  double found, hash_count = 0;
+  uint32_t nonce;
+  uint8_t buf_thr = 61, buf_thrl = 57;
+  do_reset (hexminerbe200);
+  if (info->work_block_local != work_block || info->work_pool_update != work_pool_update)
+    {
+      info->reset_work = true;
+      info->work_block_local = work_block;
+      info->work_pool_update = work_pool_update;
+      info->jobs_to_send = 2;
+      gettimeofday (&info->last_wr, NULL);
+      do_write_hexm (thr);
+      goto done_wr;
+    }
+  gettimeofday (&now, NULL);
+  tdif = timediff (&now, &info->last_wr);
+  info->jobs_to_send = (int) (tdif / info->wsem_ustiming);
+  rminder = (int) (tdif % info->wsem_ustiming);
+  if (info->jobs_to_send > 0 || info->wr->buf_empty_space > buf_thr)
+    {
+      gettimeofday (&info->last_wr, NULL);
+      if (info->wr->buf_empty_space < buf_thrl)
+        goto done_wr;
+      now.tv_sec = 0;
+      now.tv_usec = rminder;
+      timersub (&info->last_wr, &now, &diff);
+      memcpy (&info->last_wr, &diff, sizeof (struct timeval));
+      if (info->wr->buf_empty_space > buf_thr)
+        info->jobs_to_send++;
+      if (info->jobs_to_send > 2)
+        info->jobs_to_send = 2;
+      do_write_hexm (thr);
+    }
+done_wr:
+  if (libhex_be200_usb_dead (hexminerbe200))
+    {
+      hexminerbe200->shutdown = true;
+      return -1;
+    }
+  if (info->hash_write_pos + HEX_BE200USB_R_SIZE > HEX_BE200HASH_BUF_SIZE_OK)
+    {
+      info->hash_write_pos = info->hash_write_pos - info->hash_read_pos;
+      memcpy (info->readbuf, info->readbuf + info->hash_read_pos,
+              info->hash_write_pos);
+      info->hash_read_pos = 0;
+    }
+  if (info->hash_write_pos - info->hash_read_pos > 7)
+    {
+    again:
+    	if (info->work_block_local != work_block || info->work_pool_update != work_pool_update)
+    		goto new_block;
+      ret_r =
+        libhex_be200_eatHashData (info->wr, info->readbuf,
+                                  &info->hash_read_pos,
+                                  &info->hash_write_pos);
+      if (ret_r > HEX_BE200BUF_DATA)
+        goto out;
+      if (info->wr->datalength == 1)
+        goto done;
+      if (info->wr->lastnonceid > HEXMINERBE200_ARRAY_SIZE_REAL)
+        info->wr->lastnonceid = 0;
+      if (info->wr->lastchippos > HEXBE200_DEFAULT_RANGE)
+        info->wr->lastchippos = HEXBE200_DEFAULT_RANGE;
+      if (libhex_be200_cachenonce
+          (&info->array_nonce_cache[info->wr->lastchippos],
+           info->wr->lastnonce))
+        {                       
+        	/*LTE TBD!!! */
+          nonce = htole32 (info->wr->lastnonce) + 1;
+          found =
+            be200_nonce_roll (hexminerbe200, thr, nonce,
+                              info->wr->lastnonceid, info->wr->roll,
+                              HEX_BE200NROLL);
+          info->last_chip_valid_work[(uint8_t) info->wr->lastchippos] =
+            time (NULL);
+          if (found > 0)
+            {
+              info->hw_err[info->wr->lastchippos] = 0;
+              if (hash_count == 0)
+                libhex_be200_getvoltage (htole16 (info->wr->lastvoltage),
+                                         &info->pic_voltage_readings);
+              hash_count += found;
+              info->matching_work[info->wr->lastchippos]++;
+            }
+          else
+            {
+              info->hw_err[info->wr->lastchippos]++;
+              switch (info->diff)
+                {
+                case 1:
+                  inc_hw_errors_hex8 (thr, -64);
+                  break;
+                case 0:
+                  inc_hw_errors_hex8 (thr, -1);
+                  break;
+                case 2:
+                  inc_hw_errors_hex8 (thr, -4096);
+                  break;
+                case 3:
+                  inc_hw_errors_hex8 (thr, -262144);
+                  break;
+                default:
+                  inc_hw_errors_hex8 (thr, -64);
+                  break;
+                }
+            }
+        }
+      else
+        info->dupe[info->wr->lastchippos]++;
+    out:
+      if (ret_r == HEX_BE200BUF_ERR)
+        info->usb_r_errors++;
+    done:
+      if (ret_r != HEX_BE200BUF_SKIP)
+        goto again;
+    }
+  if (info->work_block_local != work_block || info->work_pool_update != work_pool_update)
+    		goto new_block;
+  ret_r =
+    libhex_be200_readHashData (hexminerbe200, info->readbuf,
+                               &info->hash_write_pos,
+                               HEXMINERBE200_BULK_READ_TIMEOUT);
+  if (ret_r != LIBUSB_SUCCESS)
+    info->usb_bad_reads++;
+  else
+    info->usb_bad_reads = 0;
+  if (info->usb_bad_reads > 20)
+    libhex_be200_reset (hexminerbe200);
+  new_block:
+  if (libhex_be200_usb_dead (hexminerbe200))
+    {
+      hexminerbe200->shutdown = true;
+      return -1;
+    }
+  switch (info->diff)
+    {
+    case 1:
+      rethash_count = (0xffffffffull * (int64_t) hash_count * 64);
+      break;
+    case 0:
+      rethash_count = (0xffffffffull * (int64_t) hash_count);
+      break;
+    case 2:
+      rethash_count = (0xffffffffull * (int64_t) hash_count * 4096);
+      break;
+    case 3:
+      rethash_count = (0xffffffffull * (int64_t) hash_count * 262144);
+      break;
+    default:
+      rethash_count = (0xffffffffull * (int64_t) hash_count * 64);
+      break;
+    }
+  return rethash_count;
+}
+
+static void
+get_hexminerbe200_statline_before (char *buf, size_t bufsiz,
+                                   struct cgpu_info *hexminerbe200)
+{
+  if (!hexminerbe200->device_data)
+    return;
+  struct hexminerbe200_info *info = hexminerbe200->device_data;
+  tailsprintf (buf, bufsiz, "%3d %4d/%4dmV", info->frequency,
+               info->core_voltage, info->pic_voltage_readings);
+}
+
+extern void suffix_string (uint64_t val, char *buf, size_t bufsiz,
+                           int sigdigits);
+static struct api_data *
+hexminerbe200_api_stats (struct cgpu_info *cgpu)
+{
+  struct api_data *root = NULL;
+  struct timeval now;
+  struct hexminerbe200_info *info = cgpu->device_data;
+  char displayed_hashes[16], displayed_rolling[16];
+  double dev_runtime, hwp;
+  uint64_t dh64, dr64;
+  int i;
+  if (!info)
+    return NULL;
+  hwp =
+    (cgpu->hw_errors +
+     cgpu->diff1) ? (double) (cgpu->hw_errors) / (double) (cgpu->hw_errors +
+                                                           cgpu->diff1) : 0;
+  if (cgpu->dev_start_tv.tv_sec == 0)
+    dev_runtime = total_secs;
+  else
+    {
+      cgtime (&now);
+      dev_runtime = tdiff (&now, &(cgpu->dev_start_tv));
+    }
+  if (dev_runtime < 1.0)
+    dev_runtime = 1.0;
+  dh64 = (double) cgpu->total_mhashes / dev_runtime * 1000000ull;
+  dr64 = (double) cgpu->rolling * 1000000ull;
+  suffix_string (dh64, displayed_hashes, sizeof (displayed_hashes), 4);
+  suffix_string (dr64, displayed_rolling, sizeof (displayed_rolling), 4);
+  root = api_add_string (root, "MHS 5s", displayed_rolling, true);
+  root = api_add_string (root, "MHS av", displayed_hashes, true);
+  root = api_add_int (root, "Hardware Errors", &(cgpu->hw_errors), true);
+  root = api_add_percent (root, "Hardware Errors%", &hwp, true);
+  root = api_add_int (root, "USB Read Errors", &(info->usb_r_errors), true);
+  root = api_add_int (root, "USB Write Errors", &(info->usb_w_errors), true);
+  root =
+    api_add_int (root, "USB Reset Count", &(info->usb_reset_count), true);
+  root =
+    api_add_int (root, "Miner Reset Count", &(info->b_reset_count), true);
+  root =
+    api_add_time (root, "Last Share Time", &(cgpu->last_share_pool_time),
+                  true);
+  root = api_add_int (root, "Chip Count", &(info->asic_count), true);
+  root = api_add_int (root, "Frequency", &(info->frequency), true);
+  root = api_add_int (root, "Core Voltage", &(info->core_voltage), true);
+  root =
+    api_add_int (root, "PIC Voltage Readings", &(info->pic_voltage_readings),
+                 true);
+  for (i = 0; i < info->asic_count; i++)
+    {
+      char mcw[24];
+      sprintf (mcw, "Chip%d Nonces", i );
+      root = api_add_int (root, mcw, &(info->matching_work[i]), true);
+      sprintf (mcw, "Chip%d Dupes", i );
+      root = api_add_int (root, mcw, &(info->dupe[i]), true);
+      sprintf (mcw, "Chip%d Timouts Reset", i );
+      root = api_add_int (root, mcw, &(info->res_timeout_err[i]), true);
+      sprintf (mcw, "Chip%d HW Errors Reset", i );
+      root = api_add_int (root, mcw, &(info->res_hew_err[i]), true);
+    }
+#ifdef DBG_HW_HEXBE200
+#ifdef DBG_HW_HEXBE200_PRINT
+  int vv = 0;
+  while (vv < HEX_BE200NROLL_ARR)
+    {
+      char mcww[24];
+      if (info->nincdec[vv] > 0)
+        {
+          sprintf (mcww, "nincdec[%d] ", vv);
+          root = api_add_int (root, mcww, &(info->nincdec[vv]), true);
+        }
+      vv++;
+    }
+#endif
+#endif
+  return root;
+}
+
+struct device_drv hexminerbe200_drv = {
+  .drv_id = DRIVER_hexminerbe200,
+  .dname = "hexminerbe200",
+  .name = "HEXE",
+  .drv_detect = hexminerbe200_detect,
+  .thread_init = hexminerbe200_thread_init,
+  .hash_work = hash_driver_work,
+  .scanwork = hexminerbe200_scanhash,
+  .get_api_stats = hexminerbe200_api_stats,
+  .get_statline_before = get_hexminerbe200_statline_before,
+  .thread_shutdown = hexminerbe200_shutdown,
+};
--- cg_o/driver-hexminerbe200.h	1970-01-01 02:00:00.000000000 +0200
+++ cgminer_hex/driver-hexminerbe200.h	2014-09-22 19:28:38.671387123 +0300
@@ -0,0 +1,160 @@
+/*$T indentinput.h GC 1.140 10/16/13 10:20:01 */
+#ifndef HEX_BE200H
+#define HEX_BE200H
+#ifdef USE_HEXMINERBE200
+#include "util.h"
+#define DBG_HW_HEXBE200
+#define DBG_HW_HEXBE200_PRINT
+
+/* hexminerbe200_task/work_reply status Definitions */
+#define HEX_BE200STAT_IDLE 0    /* Idle or data already Sent to the buffer */
+#define HEX_BE200STAT_NEW_WORK 1        /* Request for write in the buffer */
+#define HEX_BE200STAT_WAITING 2 /* Wait For Buffer Empty Position */
+#define HEX_BE200STAT_CLR_BUFF 3        /* Force Buffer Empty */
+#define HEX_BE200STAT_STOP_REQ 4        /* Stop Request */
+#define HEX_BE200STAT_NEW_WORK_CLEAR_OLD 5      /* Clear Buffers and after that fill the first buffer */
+#define HEX_BE200STAT_UNUSED 6
+#define HEX_BE200STAT_RES_HW 12
+#define HEX_BE200STAT_RES_NO_NONCE 13
+
+/* libhex_be200_eatHashData/BUF_reply status Definitions */
+#define HEX_BE200BUF_DATA 0
+#define HEX_BE200BUF_ERR 1
+#define HEX_BE200BUF_SKIP 2
+
+/* MISC */
+#define HEX_BE200NROLL 45
+#define HEX_BE200NROLL_ARR 2*HEX_BE200NROLL + 5
+#define HEXMINERBE200_ARRAY_PIC_SIZE 64
+#define HEXMINERBE200_ARRAY_SIZE HEXMINERBE200_ARRAY_PIC_SIZE
+#define HEXMINERBE200_ARRAY_SIZE_REAL HEXMINERBE200_ARRAY_SIZE - 2
+#define HEX_BE200NONCE_CASH_SIZE 4
+#define HEX_BE200USB_R_SIZE 64
+#define HEX_BE200USB_WR_SIZE 64
+#define HEX_BE200HASH_BUF_SIZE 1024
+#define HEX_BE200HASH_BUF_SIZE_OK HEX_BE200HASH_BUF_SIZE - 4
+#define HEXMINERBE200_BULK_READ_TIMEOUT 1000
+#define HEX_BE200USB_WR_TIME_OUT 500
+#define HEX_BE200MINER_THREADS 1
+#define HEX_BE200DEFAULT_MINER_NUM 0x01
+#define HEX_BE200DEFAULT_ASIC_NUM 0x10
+#define HEXBE200_DEFAULT_RANGE HEX_BE200DEFAULT_ASIC_NUM - 1
+#define HEX_BE200MIN_FREQUENCY 0
+#define HEX_BE200MAX_FREQUENCY 400
+#define HEX_BE200DEFAULT_FREQUENCY 300
+#define HEX_BE200DEFAULT_CORE_VOLTAGE 820       /* in millivolts */
+#define HEX_BE200MIN_COREMV 100 /* in millivolts */
+#define HEX_BE200MAX_COREMV 2001        /* in millivolts */
+struct chip_resultsbe200
+{
+  uint8_t nonce_cache_write_pos;
+  uint32_t nonces[HEX_BE200NONCE_CASH_SIZE];
+};
+struct hexminerbe200_task
+{
+  uint8_t startbyte;
+  uint8_t datalength;
+  uint8_t command;
+  uint16_t address;
+  uint8_t midstate[32];
+  uint32_t merkle[3];
+  uint8_t roll;
+  uint8_t id;
+  uint8_t status;
+  uint8_t dum;
+  uint16_t diff;
+  uint8_t csum;
+  uint8_t pad[4];
+} __attribute__ ((packed, aligned (4)));
+struct workbe200_result
+{
+  uint8_t startbyte;
+  uint8_t datalength;
+  uint8_t command;
+  uint16_t address;
+  uint32_t lastnonce;
+  uint8_t roll;
+  uint8_t lastnonceid;
+  uint16_t lastvoltage;
+  uint8_t lastchippos;
+  uint8_t buf_empty_space;
+  uint8_t csum;
+  uint8_t pad[4];
+} __attribute__ ((packed, aligned (4)));
+struct hexminerbe200_info
+{
+  struct timeval last_wr;
+  int jobs_to_send;
+  int64_t wsem_ustiming;
+  bool shut_read;
+  bool shut_write;
+  bool shut_reset;
+  bool reset_work;
+  bool chips_enabled[HEX_BE200DEFAULT_ASIC_NUM];
+  int usb_bad_reads;
+  int write_pos;
+  int chip_mask;
+#ifdef DBG_HW_HEXBE200
+  int nincdec[HEX_BE200NROLL_ARR];
+#endif
+  int miner_count;
+  int asic_count;
+  int pic_roll;
+  int diff;
+  int core_voltage;
+  int opt_hexminerbe200_skip_hw_res;
+  int opt_hexminerbe200_hw_err_res;
+  int opt_hexminerbe200_nonce_timeout_secs;
+  int frequency;
+  int usb_r_errors;
+  int usb_w_errors;
+  int usb_reset_count;
+  int b_reset_count;
+  int pic_voltage_readings;
+  int hash_read_pos;
+  int hash_write_pos;
+  int dupe[HEX_BE200DEFAULT_ASIC_NUM];
+  int res_hew_err[HEX_BE200DEFAULT_ASIC_NUM];
+  int res_timeout_err[HEX_BE200DEFAULT_ASIC_NUM];
+  int matching_work[HEX_BE200DEFAULT_ASIC_NUM];
+  int hw_err[HEX_BE200DEFAULT_ASIC_NUM];
+  unsigned int work_block_local;
+  unsigned int work_pool_update;
+  unsigned char *readbuf;
+  struct workbe200_result *wr;
+  struct chip_resultsbe200 *array_nonce_cache;
+  struct thr_info *thr;
+  struct work **hexworks;
+  time_t last_chip_valid_work[HEX_BE200DEFAULT_ASIC_NUM];
+  struct hexminerbe200_task *ht;
+};
+struct hexminerbe200_config_task
+{
+  uint8_t startbyte;
+  uint8_t datalength;
+  uint8_t command;
+  uint16_t address;
+  uint16_t hashclock;
+  uint16_t refvoltage;
+  uint32_t difficulty;
+  uint16_t chip_mask;
+  uint8_t csum;
+} __attribute__ ((packed, aligned (4)));
+#define HEX_BE200WORKANSWER_ADR 0x3000
+#define HEX_BE200RES_ADR 0x30AC
+#define HEXMINERBE200_TASK_SIZE (sizeof(struct hexminerbe200_task)-4)
+#define HEX_BE200MAX_WORK_SIZE (sizeof(struct workbe200_result)-4)
+#define HEX_BE200BASE_WORK_SIZE 6
+extern int opt_hexminerbe200_core_voltage;
+extern int opt_hexminerbe200_chip_mask;
+extern int opt_hexminerbe200_hw_err_res;
+extern int opt_hexminerbe200_pic_roll;
+extern int opt_hexminerbe200_nonce_timeout_secs;
+extern int opt_hexminerbe200_diff;
+extern int opt_hexminerbe200_skip_hw_res;
+
+//extern char *libhex_be200_set_config_chip_mask (char *arg);
+
+extern struct hexminerbe200_info **hexminerbe200_info;
+#endif /* USE_HEXMINERBE200 */
+#endif /* HEX_BE200H */
--- cg_o/libhex8.c	1970-01-01 02:00:00.000000000 +0200
+++ cgminer_hex/libhex8.c	2014-09-22 19:28:38.671387123 +0300
@@ -0,0 +1,245 @@
+static void
+reajust_timings (struct cgpu_info *hexminer8)
+{
+  struct hexminer8_info *info = hexminer8->device_data;
+  int i = 0;
+  int engines = 0;
+  while (i < HEX8_DEFAULT_ASIC_NUM)
+    engines += info->engines[i++];
+  if (engines == 0)
+    engines = 6 * 32;
+  info->wsem_ustiming =
+    (int64_t) (0x100000000ll / (info->frequency * 4 * engines));
+  info->ping_period =
+    (int) (1000 * 1000 / info->wsem_ustiming * 60 / (engines / 32) / 17);
+}
+
+static int64_t
+timediff (const struct timeval *a, const struct timeval *b)
+{
+  struct timeval diff;
+  timersub (a, b, &diff);
+  return diff.tv_sec * 1000000 + diff.tv_usec;
+}
+
+/*Thank you Zefir !!! */
+static uint32_t
+libhex8_get_target (double diff)
+{
+  unsigned nBits;
+  int shift = 29;
+  double ftarg = (double) 0x0000ffff / diff;
+  while (ftarg < (double) 0x00008000)
+    {
+      shift--;
+      ftarg *= 256.0;
+    } while (ftarg >= (double) 0x00800000)
+    {
+      shift++;
+      ftarg /= 256.0;
+    } nBits = (int) ftarg + (shift << 24);
+  return nBits;
+}
+
+static bool
+libhex8_cachenonce (struct chip_results8 *nonce_cache, uint32_t nonce)
+{
+  int i = 0;
+  while (i < HEX8_NONCE_CASH_SIZE && nonce_cache->nonces[i] != nonce)
+    i++;
+  if (i < HEX8_NONCE_CASH_SIZE)
+    return false;
+  if (nonce_cache->nonce_cache_write_pos == HEX8_NONCE_CASH_SIZE)
+    nonce_cache->nonce_cache_write_pos = 0;
+  nonce_cache->nonces[nonce_cache->nonce_cache_write_pos++] = nonce;
+  return true;
+}
+
+static void
+libhex8_csum (unsigned char *startptr, unsigned char *endptr,
+              unsigned char *resptr)
+{
+  unsigned char *b = startptr;
+  uint8_t sum = 0;
+  while (b < endptr)
+    sum += *b++;
+  memcpy (resptr, &sum, 1);
+}
+
+static bool
+libhex8_usb_dead (struct cgpu_info *hexminer8)
+{
+  struct cg_usb_device *usbdev;
+  struct hexminer8_info *info = hexminer8->device_data;
+  if (!info)
+    return true;
+  usbdev = hexminer8->usbdev;
+  bool ret = (usbdev == NULL || usbdev->handle == NULL || hexminer8->shutdown
+              || info->shut_read || info->shut_write || info->shut_reset
+              || hexminer8->usbinfo.nodev || hexminer8->deven != DEV_ENABLED);
+  return ret;
+}
+
+static int
+libhex8_sendHashData (struct cgpu_info *hexminer8, unsigned char *sendbuf,
+                      size_t buf_len)
+{
+  struct hexminer8_info *info = hexminer8->device_data;
+  struct cg_usb_device *usbdev;
+  int wrote = 0, written = 0;
+  int err = LIBUSB_SUCCESS;
+  usbdev = hexminer8->usbdev;
+  if (libhex8_usb_dead (hexminer8))
+    goto out;
+  while (written < buf_len && err == LIBUSB_SUCCESS)
+    {
+      err =
+        libusb_bulk_transfer (usbdev->handle, 0x02, sendbuf + written,
+                              MIN (HEX8_USB_WR_SIZE, buf_len - written),
+                              &wrote, HEX8_USB_WR_TIME_OUT);
+      if (err == LIBUSB_SUCCESS)
+        written += wrote;
+    }
+out:
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+    info->shut_write = true;
+  return written;
+}
+
+static void
+libhex8_reset (struct cgpu_info *hexminer8)
+{
+  struct hexminer8_info *info = hexminer8->device_data;
+  struct cg_usb_device *usbdev;
+  int err = LIBUSB_SUCCESS;
+  usbdev = hexminer8->usbdev;
+  if (libhex8_usb_dead (hexminer8))
+    goto out;
+  err = libusb_reset_device (usbdev->handle);
+out:
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+    info->shut_reset = true;
+  info->usb_reset_count++;
+}
+
+static int
+libhex8_readHashData (struct cgpu_info *hexminer8, unsigned char *hash,
+                      int *hash_write_pos, int timeout)
+{
+  struct hexminer8_info *info = hexminer8->device_data;
+  struct cg_usb_device *usbdev;
+  int read = 0;
+  int err = LIBUSB_SUCCESS;
+  usbdev = hexminer8->usbdev;
+  if (libhex8_usb_dead (hexminer8))
+    goto out;
+  err =
+    libusb_bulk_transfer (usbdev->handle, 0x82, hash + *hash_write_pos,
+                          HEX8_USB_R_SIZE, &read, timeout);
+  if (err == LIBUSB_SUCCESS)
+    *hash_write_pos += MIN (read, HEX8_USB_R_SIZE);
+out:
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+    info->shut_read = true;
+  return err;
+}
+
+extern bool submit_tested_work_fast_clone (struct thr_info *thr,
+                                           struct work *work, bool diff1);
+static double
+hexminer8_predecode_nonce (struct cgpu_info *hexminer8, struct thr_info *thr,
+                           uint32_t nonce, uint8_t work_id, bool diff1)
+{
+  struct hexminer8_info *info = hexminer8->device_data;
+  if (info->hexworks[work_id]->pool == NULL)
+    return 0;
+  double diff = (diff1
+                 || info->hexworks[work_id]->ping ? 1 : info->
+                 hexworks[work_id]->work_difficulty);
+  if (test_nonce (info->hexworks[work_id], nonce))
+    {
+      submit_tested_work_fast_clone (thr, info->hexworks[work_id], diff1
+                                     || info->hexworks[work_id]->ping);
+      return diff;
+    }
+  return -diff;
+}
+
+static void
+libhex8_getvoltage (uint16_t wr_bukvoltage, int *info_pic_voltage_readings)
+{
+  float voltagehuman;
+  voltagehuman =
+    (float) ((float) wr_bukvoltage * (float) 3300 / (float) ((1 << 12) - 1));
+  *info_pic_voltage_readings = (int) voltagehuman;
+}
+
+static void
+libhex8_setvoltage (int info_voltage, uint16_t * refvoltage)
+{
+  uint16_t voltageadc;
+  voltageadc =
+    (uint16_t) ((float) info_voltage / (float) 1000 / (float) 3.3 *
+                ((1 << 12) - 1));
+  *refvoltage = htole16 (voltageadc);
+}
+
+static int
+libhex8_eatHashData (struct work8_result *wr, unsigned char *hash,
+                     int *hash_read_pos, int *hash_write_pos)
+{
+  uint8_t psum;
+  int wrpos;
+  unsigned char *csum_pos;
+  bool ok;
+  int places = 0;
+eat:
+  while (*hash_read_pos < *hash_write_pos && hash[*hash_read_pos] != 0x53)
+    *hash_read_pos += 1;
+  places = *hash_write_pos - *hash_read_pos;
+  if (places < 8)
+    return HEX8_BUF_SKIP;
+  memcpy ((char *) &wr->startbyte, &hash[*hash_read_pos],
+          HEX8_BASE_WORK_SIZE - 1);
+  wr->address = htole16 (wr->address);
+  ok = (wr->command == 0x52)
+    && ((wr->address == HEX8_WORKANSWER_ADR && wr->datalength == 0x06)
+        || (wr->address == 0x3008 && wr->datalength == 1));
+  if (!ok)
+    {
+      *hash_read_pos += 1;
+      goto eat;
+    }
+  if (places < HEX8_BASE_WORK_SIZE + wr->datalength * 2)
+    return HEX8_BUF_SKIP;
+  csum_pos =
+    hash + *hash_read_pos + HEX8_BASE_WORK_SIZE + wr->datalength * 2 - 1;
+  libhex8_csum (hash + *hash_read_pos, csum_pos, &psum);
+  if (psum != *csum_pos)
+    {
+      *hash_read_pos += 1;
+      return HEX8_BUF_ERR;
+    }
+  wrpos = (wr->address - HEX8_WORKANSWER_ADR) + HEX8_BASE_WORK_SIZE - 1;
+  memcpy ((char *) &wr->startbyte + wrpos,
+          &hash[*hash_read_pos + HEX8_BASE_WORK_SIZE - 1],
+          wr->datalength * 2);
+  *hash_read_pos += HEX8_BASE_WORK_SIZE + wr->datalength * 2;
+  return HEX8_BUF_DATA;
+}
+
+static void
+libhex8_set_word (struct cgpu_info *hexminer8, uint16_t address,
+                  uint16_t word)
+{
+  unsigned char status[10];
+  uint16_t wr_adr = htole16 (address);
+  uint16_t ledata = htole16 (word);
+  status[0] = 0x53;
+  status[1] = 0x01;
+  status[2] = 0x57;
+  memcpy (status + 3, &wr_adr, 2);
+  memcpy (status + 5, &ledata, 2);
+  libhex8_csum (status, status + 7, status + 7);
+  libhex8_sendHashData (hexminer8, status, 8);
+}
--- cg_o/lib_mcp2210_hexu.c	1970-01-01 02:00:00.000000000 +0200
+++ cgminer_hex/lib_mcp2210_hexu.c	2014-09-22 19:28:38.671387123 +0300
@@ -0,0 +1,417 @@
+/*$T indentinput.c GC 1.140 10/16/13 10:20:34 */
+/*
+Special thanks to Luke Dashjr - Nanofory code was adopted from bfgminer - mcp2210.c
+*/
+
+static void
+libhexu_spi_emit_buf_reverse (unsigned char *buf, const void *p, size_t sz)
+{
+  const unsigned char *str = p;
+  size_t i;
+  for (i = 0; i < sz; ++i)
+    {
+      unsigned char v = str[i];
+      v = ((v & 0xaa) >> 1) | ((v & 0x55) << 1);
+      v = ((v & 0xcc) >> 2) | ((v & 0x33) << 2);
+      v = ((v & 0xf0) >> 4) | ((v & 0x0f) << 4);
+      *buf++ = v;
+    }
+}
+
+static void
+libhexu_spi_emit_data (size_t * pos, unsigned char *where, uint16_t addr,
+                       const void *buf, size_t len)
+{
+  unsigned char *b = where + *pos;
+  if (len < 4 || len > 128)
+    return;
+  *pos += len + 3;
+  *b++ = (len / 4 - 1) | 0xE0;
+  *b++ = (addr >> 8) & 0xFF;
+  *b++ = addr & 0xFF;
+  libhexu_spi_emit_buf_reverse (b, buf, len);
+}
+
+static void
+libhexu_bitfury_config_reg (size_t * pos, unsigned char *where, int cfgreg,
+                            int ena)
+{
+  static const uint8_t enaconf[4] = { 0xc1, 0x6a, 0x59, 0xe3 };
+  static const uint8_t disconf[4] = { 0, 0, 0, 0 };
+
+  if (ena)
+    libhexu_spi_emit_data (pos, where, 0x7000 + cfgreg * 32, enaconf, 4);
+  else
+    libhexu_spi_emit_data (pos, where, 0x7000 + cfgreg * 32, disconf, 4);
+}
+
+static void
+libhexu_spi_send_conf (size_t * pos, unsigned char *where)
+{
+  int i;
+  for (i = 7; i <= 11; ++i)
+    libhexu_bitfury_config_reg (pos, where, i, 0);
+  libhexu_bitfury_config_reg (pos, where, 6, 1);
+  libhexu_bitfury_config_reg (pos, where, 4, 1);
+  for (i = 1; i <= 3; ++i)
+    libhexu_bitfury_config_reg (pos, where, i, 0);
+  libhexu_spi_emit_data (pos, where, 0x0100, bitfury_counters, 16);
+}
+
+static void
+libhexu_spi_emit_break (size_t * pos, unsigned char *where)
+{
+  unsigned char *b = where + *pos;
+  *b = '\x4';
+  *pos += 1;
+}
+
+static bool
+hex_mcp2210_io (struct cgpu_info *hexmineru, uint8_t * const cmd,
+                uint8_t * const buf)
+{
+  int r_b = 0;
+  return (64 == libhexu_sendHashData (hexmineru, cmd, 64, 300) &&
+          64 == libhexu_readHashData (hexmineru, buf, &r_b, 300));
+}
+
+static bool
+libhexu_mcp2210_get_configs (struct cgpu_info *hexmineru)
+{
+  uint8_t cmd[64], buf[64];
+  memset (cmd, 0, 64);
+  memset (buf, 0, 64);
+  cmd[0] = 0x41;
+  if (!hex_mcp2210_io (hexmineru, cmd, buf))
+    {
+      applog (LOG_ERR, "%s: Failed to get current %s config", __func__,
+              "SPI");
+      return false;
+    }
+  memcpy (hexmineru->cfg_spi, &buf[4], sizeof (hexmineru->cfg_spi));
+
+  cmd[0] = 0x20;
+  if (!hex_mcp2210_io (hexmineru, cmd, buf))
+    {
+      applog (LOG_ERR, "%s: Failed to get current %s config", __func__,
+              "GPIO");
+      return false;
+    }
+  memcpy (hexmineru->cfg_gpio, &buf[4], sizeof (hexmineru->cfg_gpio));
+  return true;
+}
+
+static bool
+hex_mcp2210_set_cfg_gpio (struct cgpu_info *hexmineru)
+{
+  uint8_t cmd[64], buf[64];
+  memset (cmd, 0, 64);
+  memset (buf, 0, 64);;
+  cmd[0] = 0x21;
+  memcpy (&cmd[4], hexmineru->cfg_gpio, 0xe);
+  if (!hex_mcp2210_io (hexmineru, cmd, buf))
+    {
+      applog (LOG_ERR, "%s: Failed to set current %s config", __func__,
+              "GPIO");
+      return false;
+    }
+
+  if (buf[1] != 0)
+    {
+      applog (LOG_ERR, "%s: Error setting current %s config (%d)", __func__,
+              "GPIO", buf[1]);
+      return false;
+    }
+  return true;
+}
+
+static enum mcp2210_gpio_value
+hex_mcp2210_get_gpio_input (struct cgpu_info *hexmineru, const int pin)
+{
+  uint8_t cmd[64], buf[64];
+  memset (cmd, 0, 64);
+  memset (buf, 0, 64);;
+  cmd[0] = 0x31;
+  const int bit = 1 << (pin % 8);
+  const int byte = (pin / 8);
+  hexmineru->cfg_gpio[pin] = 0;
+  hexmineru->cfg_gpio[byte + 0xb] |= bit;
+  if (!hex_mcp2210_set_cfg_gpio (hexmineru))
+    return MGV_ERROR;
+
+  if (!hex_mcp2210_io (hexmineru, cmd, buf))
+    {
+      applog (LOG_ERR, "%s: Failed to get current GPIO input values",
+              __func__);
+      return MGV_ERROR;
+    }
+  if (buf[byte + 4] & bit)
+    return MGV_HIGH;
+  else
+    return MGV_LOW;
+}
+
+static bool
+hex_mcp2210_set_gpio_output (struct cgpu_info *hexmineru, const int pin,
+                             const enum mcp2210_gpio_value d)
+{
+  const int bit = 1 << (pin % 8);
+  const int byte = (pin / 8);
+  hexmineru->cfg_gpio[pin] = 0;
+  hexmineru->cfg_gpio[byte + 0xb] &= ~bit;
+  if (d == MGV_HIGH)
+    hexmineru->cfg_gpio[byte + 9] |= bit;
+  else
+    hexmineru->cfg_gpio[byte + 9] &= ~bit;
+  return hex_mcp2210_set_cfg_gpio (hexmineru);
+}
+
+static bool
+hex_mcp2210_spi_cancel (struct cgpu_info *hexmineru)
+{
+  uint8_t cmd[64], buf[64];
+  memset (cmd, 0, 64);
+  memset (buf, 0, 64);;
+  cmd[0] = 0x11;
+  if (!hex_mcp2210_io (hexmineru, cmd, buf))
+    return false;
+  return (buf[1] == 0);
+}
+
+static bool
+hex_mcp2210_set_cfg_spi (struct cgpu_info *hexmineru)
+{
+  uint8_t cmd[64], buf[64];
+
+  memset (cmd, 0, 64);
+  memset (buf, 0, 64);;
+  cmd[0] = 0x40;
+  memcpy (&cmd[4], hexmineru->cfg_spi, sizeof (hexmineru->cfg_spi));
+  if (!hex_mcp2210_io (hexmineru, cmd, buf))
+    {
+      applog (LOG_ERR, "%s: Failed to set current %s config", __func__,
+              "SPI");
+      return false;
+    }
+
+  if (buf[1] != 0)
+    {
+      applog (LOG_ERR, "%s: Error setting current %s config (%d)", __func__,
+              "SPI", buf[1]);
+      return false;
+    }
+  return true;
+}
+
+static bool
+hex_mcp2210_configure_spi (struct cgpu_info *hexmineru,
+                           const uint32_t bitrate, const uint16_t idlechipsel,
+                           const uint16_t activechipsel,
+                           const uint16_t chipseltodatadelay,
+                           const uint16_t lastbytetocsdelay,
+                           const uint16_t midbytedelay)
+{
+  uint8_t *const cfg = hexmineru->cfg_spi;
+
+  cfg[0] = (bitrate >> 0x00) & 0xff;
+  cfg[1] = (bitrate >> 0x08) & 0xff;
+  cfg[2] = (bitrate >> 0x10) & 0xff;
+  cfg[3] = (bitrate >> 0x18) & 0xff;
+  cfg[4] = (idlechipsel >> 0) & 0xff;
+  cfg[5] = (idlechipsel >> 8) & 0xff;
+  cfg[6] = (activechipsel >> 0) & 0xff;
+  cfg[7] = (activechipsel >> 8) & 0xff;
+  cfg[8] = (chipseltodatadelay >> 0) & 0xff;
+  cfg[9] = (chipseltodatadelay >> 8) & 0xff;
+  cfg[0xa] = (lastbytetocsdelay >> 0) & 0xff;
+  cfg[0xb] = (lastbytetocsdelay >> 8) & 0xff;
+  cfg[0xc] = (midbytedelay >> 0) & 0xff;
+  cfg[0xd] = (midbytedelay >> 8) & 0xff;
+  return hex_mcp2210_set_cfg_spi (hexmineru);
+}
+
+static bool
+hex_mcp2210_set_spimode (struct cgpu_info *hexmineru, const uint8_t spimode)
+{
+  uint8_t *const cfg = hexmineru->cfg_spi;
+  cfg[0x10] = spimode;
+  return hex_mcp2210_set_cfg_spi (hexmineru);
+}
+
+static bool
+hex_mcp2210_spi_transfer (struct cgpu_info *hexmineru, const void *const tx,
+                          void *const rx, uint8_t sz)
+{
+  uint8_t *const cfg = hexmineru->cfg_spi;
+  struct hexmineru_info *info = hexmineru->device_data;
+  uint8_t cmd[64], buf[64];
+  memset (cmd, 0, 64);
+  memset (buf, 0, 64);;
+  cmd[0] = 0x42;
+  uint8_t *p = rx;
+  if (unlikely (sz > 60))
+    {
+      applog (LOG_ERR, "%s: SPI transfer too long (%d bytes)", __func__, sz);
+      return false;
+    }
+  cfg[0xe] = sz;
+  cfg[0xf] = 0;
+  if (sz != info->ltsz)
+    {
+      if (!hex_mcp2210_set_cfg_spi (hexmineru))
+        return false;
+      info->ltsz = sz;
+    }
+  cmd[1] = sz;
+  memcpy (&cmd[4], tx, sz);
+  if (unlikely (!hex_mcp2210_io (hexmineru, cmd, buf)))
+    {
+      applog (LOG_ERR, "%s: Failed to issue SPI transfer", __func__);
+      return false;
+    }
+  while (true)
+    {
+      switch (buf[1])
+        {
+        case 0:
+          cmd[1] = 0;
+          break;
+        case 0xf8:
+          applog (LOG_DEBUG,
+                  "%s: SPI transfer rejected temporarily (%d bytes remaining)",
+                  __func__, sz);
+          goto retry;
+        default:
+          applog (LOG_ERR, "%s: SPI transfer error (%d) (%d bytes remaining)",
+                  __func__, buf[1], sz);
+          return false;
+        }
+      if (buf[2] >= sz)
+        {
+          if (buf[2] > sz)
+            applog (LOG_ERR, "%s: Received %d extra bytes in SPI transfer",
+                    __func__, sz - buf[2]);
+          memcpy (p, &buf[4], sz);
+          return true;
+        }
+      memcpy (p, &buf[4], buf[2]);
+      p += buf[2];
+      sz -= buf[2];
+    retry:
+      if (unlikely (!hex_mcp2210_io (hexmineru, cmd, buf)))
+        {
+          applog (LOG_ERR,
+                  "%s: Failed to continue SPI transfer (%d bytes remaining)",
+                  __func__, sz);
+          return false;
+        }
+    }
+}
+
+static bool
+hex_nanofury_checkport (struct cgpu_info *hexmineru)
+{
+  int i;
+  const char tmp = 0;
+  char tmprx;
+  for (i = 0; i < 9; ++i)
+    if (MGV_ERROR == hex_mcp2210_get_gpio_input (hexmineru, i))
+      goto fail;
+  if (!hex_mcp2210_set_gpio_output (hexmineru, NANOFURY_GP_PIN_LED, MGV_HIGH))
+    goto fail;
+  if (!hex_mcp2210_set_gpio_output
+      (hexmineru, NANOFURY_GP_PIN_PWR_EN, MGV_HIGH))
+    goto fail;
+  hex_mcp2210_spi_cancel (hexmineru);
+  if (!hex_mcp2210_configure_spi (hexmineru, 200000, 0xffff, 0xffef, 0, 0, 0))
+    goto fail;
+  if (!hex_mcp2210_set_spimode (hexmineru, 0))
+    goto fail;
+  if (!hex_mcp2210_spi_transfer (hexmineru, &tmp, &tmprx, 1))
+    goto fail;
+  if (hex_mcp2210_get_gpio_input (hexmineru, NANOFURY_GP_PIN_SCK_OVR) !=
+      MGV_LOW)
+    goto fail;
+  if (!hex_mcp2210_set_spimode (hexmineru, 2))
+    goto fail;
+  if (!hex_mcp2210_spi_transfer (hexmineru, &tmp, &tmprx, 1))
+    goto fail;
+  if (hex_mcp2210_get_gpio_input (hexmineru, NANOFURY_GP_PIN_SCK_OVR) !=
+      MGV_HIGH)
+    goto fail;
+  if (!hex_mcp2210_set_spimode (hexmineru, 0))
+    goto fail;
+  if (!hex_mcp2210_spi_transfer (hexmineru, &tmp, &tmprx, 1))
+    goto fail;
+  if (hex_mcp2210_get_gpio_input (hexmineru, NANOFURY_GP_PIN_SCK_OVR) !=
+      MGV_LOW)
+    goto fail;
+  return true;
+fail:
+  return false;
+}
+
+static bool
+libhexu_nanofury_spi_reset (struct cgpu_info *hexmineru)
+{
+  int r;
+  char tx[1] = { 0x81 };
+  char buf[1];
+  if (!hex_mcp2210_set_gpio_output
+      (hexmineru, NANOFURY_GP_PIN_SCK_OVR, MGV_HIGH))
+    return false;
+  for (r = 0; r < 16; ++r)
+    if (!hex_mcp2210_spi_transfer (hexmineru, tx, buf, 1))
+      return false;
+  if (hex_mcp2210_get_gpio_input (hexmineru, NANOFURY_GP_PIN_SCK_OVR) ==
+      MGV_ERROR)
+    return false;
+  return true;
+}
+
+static bool
+libhexu_nanofury_spi_txrx (struct cgpu_info *hexmineru, size_t * bufsz,
+                           unsigned char *wrbuf, unsigned char *rdbuf,
+                           bool trash)
+{
+  const uint8_t *ptrwrbuf = wrbuf;
+  uint8_t *ptrrdbuf = rdbuf;
+  size_t speedup = NANOFURY_MAX_BYTES_PER_SPI_TRANSFER;
+  if (*bufsz == 80)
+    speedup = 40;
+  while (*bufsz >= speedup)
+    {
+      if (!hex_mcp2210_spi_transfer (hexmineru, ptrwrbuf, ptrrdbuf, speedup))
+        goto err;
+      if (!trash)
+        ptrrdbuf += speedup;
+      ptrwrbuf += speedup;
+      *bufsz -= speedup;
+    }
+  if (*bufsz > 0)
+    {
+      if (!hex_mcp2210_spi_transfer (hexmineru, ptrwrbuf, ptrrdbuf, *bufsz))
+        goto err;
+    }
+  return true;
+err:
+  return false;
+}
+
+static void
+libhexu_spi_send_init (size_t * pos, unsigned char *where)
+{
+  /* Prepare internal buffers */
+  /* PREPARE BUFFERS (INITIAL PROGRAMMING) */
+  unsigned w[16];
+  memset (&w, 0, sizeof (w));
+  w[3] = htole32 (0xffffffff);
+  w[4] = htole32 (0x80000000);
+  w[15] = htole32 (0x00000280);
+  libhexu_spi_emit_data (pos, where, 0x1000, w, 16 * 4);
+  libhexu_spi_emit_data (pos, where, 0x1400, w, 8 * 4);
+  memset (w, 0, sizeof (w));
+  w[0] = htole32 (0x80000000);
+  w[7] = htole32 (0x100);
+  libhexu_spi_emit_data (pos, where, 0x1900, &w[0], 8 * 4);     /* Prepare MS and W buffers! */
+}
